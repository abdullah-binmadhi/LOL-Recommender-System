<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>League of Legends Champion Recommender System</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23667eea'><path d='M15 5.1L9 3 3 5.02v16.2l6-2.33 6 2.1 6-2.02V2.77L15 5.1zm0 13.79l-6-2.11V5.11l6 2.11v11.67z'/></svg>" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #3E1E68 0%, #5D2F77 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .card {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 0;
            margin: 30px auto;
            box-shadow: 0 15px 40px rgba(0,0,0,0.15);
            display: none;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 1000px;
            width: 100%;
        }

        .card.active {
            display: block;
            animation: fadeIn 0.7s cubic-bezier(0.19, 1, 0.22, 1);
            box-shadow: 0 15px 40px rgba(0,0,0,0.2);
        }

        .start-screen {
            display: block;
            background: linear-gradient(135deg, #3E1E68 0%, #5D2F77 100%);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .feature {
            text-align: center;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .feature-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .btn-primary {
            background: linear-gradient(135deg, #3E1E68, #5D2F77);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #5D2F77, #3E1E68);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .btn-secondary {
            background: rgba(108, 117, 125, 0.8);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        
        .btn-secondary:hover {
            background: rgba(108, 117, 125, 1);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .btn-large {
            padding: 15px 30px;
            font-size: 18px;
        }

        .question h2 {
            margin-bottom: 20px;
            color: white;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            font-size: 1.5rem;
            padding: 25px 25px 0 25px;
            text-align: center;
            font-weight: 600;
        }

        .options {
            display: grid;
            gap: 15px;
            margin: 20px 25px;
            padding-bottom: 10px;
        }

        .option {
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            text-align: left;
        }

        .option:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .option.selected {
            background: #3E1E68;
            color: white;
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .progress-container {
            margin-bottom: 10px;
            padding: 25px 25px 0 25px;
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-weight: 600;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .progress-bar {
            height: 8px;
            background: rgba(233, 236, 239, 0.3);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.5s ease;
        }

        .buttons {
            display: flex;
            justify-content: center;
            margin: 20px 25px 25px;
            padding-bottom: 10px;
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            min-width: 300px;
            justify-content: space-between;
        }
        
        .btn-spacer {
            width: 100px;
        }

        .champion-count {
            text-align: center;
            color: white;
            margin-bottom: 20px;
            font-size: 1.1rem;
        }

        .champion-image {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 3px solid #667eea;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .champion-image-large {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 4px solid #667eea;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .champion-name {
            font-size: 1.5rem;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .champion-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 15px 0;
            padding: 15px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 8px;
        }

        .stat-item {
            text-align: center;
            padding: 8px;
            background: white;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #666;
            margin-top: 3px;
        }

        .tier-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 0.8rem;
            margin: 5px 0;
        }

        .tier-S { background: #ff6b6b; color: white; }
        .tier-A { background: #4ecdc4; color: white; }
        .tier-B { background: #45b7d1; color: white; }
        .tier-C { background: #96ceb4; color: white; }
        .tier-D { background: #feca57; color: white; }

        .trend-indicator {
            display: inline-block;
            margin-left: 5px;
        }

        .champion-role {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .confidence-score {
            background: #e8f4f8;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
        }

        .confidence-value {
            font-size: 1.3rem;
            font-weight: bold;
            color: #20c997;
        }

        .ml-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 15px 0;
        }

        .stat-item {
            background: white;
            padding: 8px;
            border-radius: 5px;
            text-align: center;
            font-size: 0.9rem;
        }

        .stat-label {
            color: #666;
            font-size: 0.8rem;
        }

        .stat-value {
            font-weight: bold;
            color: #333;
        }

        /* Enhanced Detailed Analysis Styles */
        .analysis-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            text-align: center;
        }

        .analysis-header h2 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }

        .analysis-header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }

        .algorithm-analysis {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }

        .algorithm-analysis:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }

        .algorithm-analysis.winner {
            border-color: #28a745;
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
        }

        .algorithm-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .algorithm-title {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .algorithm-title h3 {
            color: #667eea;
            font-size: 1.4rem;
            margin: 0;
        }

        .algorithm-icon {
            font-size: 1.8rem;
        }

        .winner-crown {
            background: #28a745;
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .champion-result {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            text-align: center;
        }

        .champion-result .champion-name {
            font-size: 1.8rem;
            color: #333;
            margin-bottom: 8px;
        }

        .champion-result .champion-role {
            font-size: 1rem;
            margin-bottom: 15px;
        }

        .confidence-display {
            background: linear-gradient(135deg, #20c997, #17a2b8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
        }

        .confidence-display .confidence-number {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .confidence-display .confidence-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .algorithm-details {
            margin: 20px 0;
        }

        .detail-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .detail-item:last-child {
            border-bottom: none;
        }

        .detail-label {
            font-weight: 600;
            color: #495057;
        }

        .detail-value {
            color: #28a745;
            font-weight: bold;
        }

        .performance-section {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 15px;
            padding: 30px;
            margin: 30px 0;
        }

        .performance-section h3 {
            color: #495057;
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.6rem;
        }

        .performance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .performance-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }

        .performance-card h4 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .performance-metric {
            font-size: 1.5rem;
            font-weight: bold;
            color: #28a745;
            margin-bottom: 5px;
        }

        .performance-description {
            font-size: 0.9rem;
            color: #6c757d;
        }

        /* Champion Analysis Section Styles */
        .champion-analysis-section {
            background: linear-gradient(135deg, #fff8e1 0%, #ffecb3 100%);
            border-radius: 15px;
            padding: 30px;
            margin: 30px 0;
        }

        .champion-analysis-section h3 {
            color: #e65100;
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.6rem;
        }

        .analysis-explanation {
            text-align: center;
            margin-bottom: 30px;
        }

        .analysis-explanation p {
            color: #bf360c;
            font-size: 1.1rem;
            font-weight: 500;
        }

        .match-analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 25px;
        }
        
        .match-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-top: 4px solid #ff9800;
        }

        .match-card.winner {
            border: 2px solid #28a745;
            background: linear-gradient(135deg, #f8f9fa 0%, #e6f7ef 100%);
        }
        
        .winner-badge {
            display: inline-block;
            background: #28a745;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: bold;
            margin-left: 8px;
            vertical-align: middle;
        }
        
        .algorithm-info {
            font-size: 0.85rem;
            color: #6c757d;
            margin-top: 3px;
        }
        
        .champion-stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin: 15px 0;
            background: rgba(102, 126, 234, 0.05);
            border-radius: 8px;
            padding: 10px;
        }
        
        .champion-stats-grid .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: white;
            padding: 8px;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .champion-stats-grid .stat-label {
            font-size: 0.75rem;
            color: #6c757d;
        }
        
        .champion-stats-grid .stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #667eea;
        }

        .match-analysis-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-top: 4px solid #ff9800;
        }

        .match-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .match-champion-img {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid #ff9800;
        }

        .match-info h4 {
            color: #e65100;
            margin: 0;
            font-size: 1.2rem;
        }

        .match-tier {
            color: #757575;
            font-size: 0.9rem;
        }

        .compatibility-score {
            background: linear-gradient(135deg, #ff9800, #ffc107);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
        }

        .score-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .score-value {
            font-size: 2rem;
            font-weight: bold;
        }

        .match-breakdown {
            margin-bottom: 20px;
        }

        .breakdown-item {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 12px;
        }

        .breakdown-label {
            flex: 0 0 100px;
            font-size: 0.9rem;
            color: #424242;
            font-weight: 500;
        }

        .breakdown-bar {
            flex: 1;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }

        .breakdown-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            transition: width 0.5s ease;
        }

        .breakdown-value {
            flex: 0 0 40px;
            text-align: right;
            font-size: 0.8rem;
            font-weight: 600;
            color: #2e7d32;
        }

        .champion-highlights {
            border-top: 1px solid #e0e0e0;
            padding-top: 15px;
        }

        .highlight-title {
            color: #424242;
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .highlight-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .highlight-tag {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .highlight-tag.damage { background: #ffebee; color: #c62828; }
        .highlight-tag.tank { background: #e8f5e8; color: #2e7d32; }
        .highlight-tag.mobile { background: #e3f2fd; color: #1565c0; }
        .highlight-tag.control { background: #f3e5f5; color: #7b1fa2; }
        .highlight-tag.utility { background: #fff3e0; color: #ef6c00; }
        .highlight-tag.easy { background: #e0f2f1; color: #00695c; }

        /* Recommendations Section Styles */
        .recommendations-section {
            background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%);
            border-radius: 15px;
            padding: 30px;
            margin: 30px 0;
        }

        .recommendations-section h3 {
            color: #4a148c;
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.6rem;
        }

        .recommendation-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .recommendation-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .primary-rec {
            border-top: 4px solid #9c27b0;
        }

        .counter-synergies {
            border-top: 4px solid #673ab7;
        }

        .alternative-picks {
            border-top: 4px solid #3f51b5;
        }

        .meta-insights {
            border-top: 4px solid #2196f3;
        }

        .rec-icon {
            font-size: 2rem;
            text-align: center;
            margin-bottom: 15px;
        }

        .recommendation-card h4 {
            color: #4a148c;
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .primary-champion {
            font-size: 1.5rem;
            font-weight: bold;
            color: #7b1fa2;
            text-align: center;
            margin-bottom: 15px;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .action-btn {
            flex: 1;
            padding: 8px 12px;
            background: #9c27b0;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background 0.3s;
        }

        .action-btn:hover {
            background: #7b1fa2;
        }

        .matchup-list {
            margin-bottom: 15px;
        }

        .matchup-category {
            font-weight: 600;
            color: #212121;
            margin: 12px 0 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.05rem;
        }

        .matchup-icon {
            color: #673ab7;
            font-size: 1.1rem;
        }

        .matchup-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #f5f5f5;
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            color: #333333;
            font-weight: 500;
        }

        .strong-against {
            border-left: 3px solid #4caf50;
            background-color: rgba(76, 175, 80, 0.12);
        }

        .weak-against {
            border-left: 3px solid #f44336;
            background-color: rgba(244, 67, 54, 0.12);
        }

        .synergizes-with {
            border-left: 3px solid #2196f3;
            background-color: rgba(33, 150, 243, 0.12);
        }

        .alternatives-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .alternative-item {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 10px;
        }

        .alt-champion-img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #3f51b5;
        }

        .alt-name {
            font-weight: 600;
            color: #1a237e;
        }

        .alt-reason {
            font-size: 0.8rem;
            color: #666;
        }

        .meta-info {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .meta-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .meta-label {
            color: #424242;
            font-size: 0.9rem;
        }

        .meta-value {
            font-weight: bold;
            color: #1565c0;
        }

        .meta-recommendation {
            background: #e3f2fd;
            padding: 12px;
            border-radius: 8px;
            font-size: 0.9rem;
            color: #0d47a1;
            margin-top: 12px;
        }

        .final-tips {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .final-tips h4 {
            color: #4a148c;
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.3rem;
        }

        .tips-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .tip-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 15px;
            background: #fafafa;
            border-radius: 10px;
        }

        .tip-icon {
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .tip-text {
            color: #424242;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .champion-tip-source {
            margin-top: 15px;
            text-align: center;
            padding: 12px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .champion-tip-source small {
            color: #4a148c;
            font-style: italic;
            font-weight: 500;
        }

        .strategy-section {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            border-radius: 15px;
            padding: 30px;
            margin: 30px 0;
        }

        .strategy-section h3 {
            color: #856404;
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.6rem;
        }

        .preference-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .preference-item {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }

        .preference-item h4 {
            color: #856404;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .preference-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #495057;
            margin-bottom: 8px;
        }

        .preference-description {
            font-size: 0.9rem;
            color: #6c757d;
            line-height: 1.4;
        }

        .comparison-table {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin: 30px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .comparison-table h3 {
            color: #495057;
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.6rem;
        }

        .table-responsive {
            overflow-x: auto;
        }

        .comparison-table table {
            width: 100%;
            border-collapse: collapse;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 15px;
            text-align: center;
            border-bottom: 1px solid #e9ecef;
        }

        .comparison-table th {
            background: #f8f9fa;
            color: #495057;
            font-weight: 600;
        }

        .comparison-table td {
            color: #6c757d;
        }

        .table-winner {
            background: #d4edda !important;
            color: #155724 !important;
            font-weight: bold;
        }

        /* Enhanced Start Screen Styles */
        .hero-section {
            text-align: center;
            padding: 40px 25px;
            color: white;
            margin-bottom: 30px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.9) 0%, rgba(118, 75, 162, 0.9) 100%);
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        .hero-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect width="100" height="100" fill="none" /><path d="M30,20 L70,20 L50,50 Z" fill="rgba(255,255,255,0.05)" /><circle cx="70" cy="70" r="10" fill="rgba(255,255,255,0.05)" /></svg>');
            background-size: 180px;
            opacity: 0.3;
            z-index: 0;
        }

        .hero-content {
            position: relative;
            z-index: 1;
            margin-bottom: 40px;
        }

        .hero-title {
            font-size: 2.6rem;
            font-weight: 800;
            margin-bottom: 20px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            background: linear-gradient(to right, #fff, #e0e0ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .hero-description {
            font-size: 1.2rem;
            opacity: 0.95;
            max-width: 650px;
            margin: 0 auto 30px;
            line-height: 1.7;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 25px;
            margin: 40px 0;
            position: relative;
            z-index: 1;
        }

        .feature {
            text-align: center;
            padding: 30px 20px;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            position: relative;
        }

        .feature::before {
            content: '';
            position: absolute;
            top: -10%;
            left: -10%;
            width: 120%;
            height: 120%;
            background: radial-gradient(circle at center, rgba(255,255,255,0.2) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .feature:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-5px) scale(1.03);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
        }

        .feature:hover::before {
            opacity: 1;
        }

        .feature-icon {
            font-size: 3rem;
            margin-bottom: 20px;
            display: block;
            text-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .feature h3 {
            color: white;
            margin-bottom: 12px;
            font-size: 1.3rem;
            font-weight: 700;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .feature p {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1rem;
            line-height: 1.6;
        }

        .cta-section {
            text-align: center;
            margin: 40px 0 20px;
            position: relative;
            z-index: 1;
        }

        .btn-hero {
            background: linear-gradient(135deg, #ff9a9e 0%, #fad0c4 99%, #fad0c4 100%);
            color: #4a3650;
            border: none;
            padding: 18px 40px;
            border-radius: 50px;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: inline-flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.25);
            position: relative;
            overflow: hidden;
        }

        .btn-hero::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.7s;
        }

        .btn-hero:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 20px 45px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
        }

        .btn-hero:hover::before {
            left: 100%;
        }

        .btn-text {
            font-weight: 700;
            position: relative;
            z-index: 1;
        }

        .btn-icon {
            font-size: 1.2rem;
            transition: transform 0.3s ease;
            position: relative;
            z-index: 1;
        }

        .btn-hero:hover .btn-icon {
            transform: translateX(5px);
        }

        /* Simplified User Registration Form Styles */
        .user-registration {
            max-width: 500px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
        }

        .registration-header {
            text-align: center;
            margin-bottom: 25px;
            padding-top: 25px;
            color: white;
        }

        .registration-header h2 {
            color: white;
            font-size: 1.8rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .registration-header p {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1rem;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .registration-form {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin: 0 25px 25px 25px;
        }

        .form-group {
            position: relative;
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            font-weight: 600;
            color: white;
            margin-bottom: 8px;
            font-size: 0.9rem;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 12px 45px 12px 12px;
            border: 1px solid #e9ecef;
        }

        .form-group input:focus,
        .form-group select:focus {
            border-color: #80bdff;
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
        }

        .form-group .input-icon {
            position: absolute;
            top: 50%;
            right: 15px;
            transform: translateY(-50%);
            color: #6c757d;
        }

        .form-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        .form-buttons .btn {
            flex: 1;
        }
        
        /* Enhanced for ML Analysis Section */
        .detailed-analysis {
            background: rgba(255, 255, 255, 0.15) !important;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .detailed-analysis h2 {
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            padding: 25px 25px 0 25px;
            font-size: 1.8rem;
        }
        
        /* Enhanced styling for analysis content */
        #analysis-content {
            padding: 0 25px 25px 25px;
            color: white;
        }
        
        /* Question Card Specific Styling */
        .question-card {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
            border-radius: 20px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.15);
            overflow: hidden;
        }
        
        #questions-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
        }
        
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 12px 45px 12px 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            font-size: 0.95rem;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(5px);
            color: white;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.2);
        }

        .form-icon {
            position: absolute;
            right: 12px;
            top: 38px;
            font-size: 1rem;
            pointer-events: none;
        }

        .form-buttons {
            display: flex;
            justify-content: space-between;
            gap: 15px;
            margin-top: 10px;
        }

        .form-buttons .btn {
            flex: 1;
        }

        /* Responsive design for mobile */
        @media (max-width: 768px) {
            .hero-title {
                font-size: 2.2rem;
            }
            
            .hero-stats {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }
            
            .stat-bubble {
                min-width: 80px;
                padding: 15px;
            }
            
            .algorithm-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .btn-hero {
                padding: 18px 35px;
                font-size: 1.1rem;
            }

            .registration-form {
                padding: 25px;
            }

            .form-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .form-buttons {
                flex-direction: column;
            }

            .form-buttons .btn {
                max-width: none;
            }
        }

        /* Champion Showcase Styles */
        .champion-showcase {
            position: relative;
            z-index: 1;
            margin: 20px auto 40px;
        }

        .champion-images {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .champion-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.7);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            transform: scale(1);
            filter: brightness(0.9);
            animation: pulse 3s infinite alternate ease-in-out;
        }

        .champion-avatar:nth-child(2) {
            animation-delay: 0.6s;
        }

        .champion-avatar:nth-child(3) {
            animation-delay: 1.2s;
        }

        .champion-avatar:nth-child(4) {
            animation-delay: 1.8s;
        }

        .champion-avatar:nth-child(5) {
            animation-delay: 2.4s;
        }

        .champion-avatar:hover {
            transform: scale(1.15) translateY(-10px);
            border-color: #fff;
            filter: brightness(1.1);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
            z-index: 2;
        }

        @keyframes pulse {
            0% {
                transform: scale(1) translateY(0);
            }
            100% {
                transform: scale(1.1) translateY(-5px);
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Enhanced header */
        .header h1 {
            font-size: 2.8rem;
            margin-bottom: 15px;
            background: linear-gradient(to right, #fff, #e0e0ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.95;
            color: white;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        /* Animation enhancements */
        .start-screen {
            animation: fadeIn 1s ease-in-out;
        }

        /* Enhanced background */
        body {
            background-image: linear-gradient(135deg, #667eea 0%, #764ba2 100%), 
                              url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect width="100" height="100" fill="none" /><path d="M30,20 L70,20 L50,50 Z" fill="rgba(255,255,255,0.03)" /></svg>');
            background-blend-mode: overlay;
            background-size: cover, 300px;
        }

        /* Evaluation Metrics Section Styles */
        .evaluation-metrics-section {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border-radius: 15px;
            padding: 30px;
            margin: 30px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .evaluation-metrics-section h3 {
            color: #2e7d32;
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.6rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .metric-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }

        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
        }

        .metric-label {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            margin: 10px 0;
        }

        .metric-value.excellent {
            color: #2e7d32;
        }

        .metric-value.good {
            color: #f57c00;
        }

        .metric-value.poor {
            color: #c62828;
        }

        .metric-description {
            font-size: 0.8rem;
            color: #999;
            margin-top: 10px;
            line-height: 1.4;
        }

        .performance-interpretation {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            border-left: 4px solid #2e7d32;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }

        .performance-interpretation h4 {
            color: #2e7d32;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .performance-interpretation p {
            color: #424242;
            font-size: 0.95rem;
            line-height: 1.6;
            margin: 0;
        }

        .metrics-icon {
            font-size: 1.5rem;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            animation: fadeIn 0.3s ease;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            margin: auto;
            padding: 0;
            border-radius: 20px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease;
            overflow: hidden;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px 30px;
            position: relative;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.8rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .modal-close {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: white;
            font-size: 2rem;
            font-weight: bold;
            cursor: pointer;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-50%) rotate(90deg);
        }

        .modal-body {
            padding: 30px;
            color: #333;
            line-height: 1.7;
        }

        .modal-body h3 {
            color: #667eea;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 1.3rem;
        }

        .modal-body h3:first-child {
            margin-top: 0;
        }

        .modal-body p {
            margin-bottom: 15px;
            font-size: 1rem;
        }

        .modal-score {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            margin: 20px 0;
            border-left: 4px solid #2e7d32;
        }

        .modal-score.warning {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            border-left-color: #f57c00;
        }

        .modal-score.poor {
            background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
            border-left-color: #c62828;
        }

        .modal-score-value {
            font-size: 3rem;
            font-weight: bold;
            color: #2e7d32;
            margin-bottom: 5px;
        }

        .modal-score.warning .modal-score-value {
            color: #f57c00;
        }

        .modal-score.poor .modal-score-value {
            color: #c62828;
        }

        .modal-score-label {
            font-size: 0.9rem;
            color: #666;
            font-weight: 600;
        }

        .champion-list {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
        }

        .champion-list-item {
            padding: 8px 12px;
            background: white;
            border-radius: 6px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .champion-list-item:last-child {
            margin-bottom: 0;
        }

        .champion-list-icon {
            font-size: 1.2rem;
        }

        .champion-list-name {
            font-weight: 600;
            color: #333;
        }

        .champion-list-badge {
            margin-left: auto;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .champion-list-badge.relevant {
            background: #c8e6c9;
            color: #2e7d32;
        }

        .champion-list-badge.not-relevant {
            background: #ffcdd2;
            color: #c62828;
        }

        .metric-card {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .metric-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 12px 25px rgba(0,0,0,0.2);
        }

        .metric-card::after {
            content: 'üîç Click for details';
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            color: #999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .metric-card:hover::after {
            opacity: 1;
        }

        .metric-card {
            position: relative;
        }

        /* Champion Card Clickable Styles */
        .match-card {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .match-card:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
        }

        .match-card::after {
            content: 'üîç Click for ML details';
            position: absolute;
            bottom: 15px;
            right: 15px;
            font-size: 0.75rem;
            color: #999;
            opacity: 0;
            transition: opacity 0.3s ease;
            background: rgba(255,255,255,0.9);
            padding: 4px 8px;
            border-radius: 4px;
        }

        .match-card:hover::after {
            opacity: 1;
        }

        /* Champion Modal Styles */
        .champion-modal-content {
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .champion-modal-header {
            background: linear-gradient(135deg, #ff9800 0%, #ff5722 100%);
            padding: 30px;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .champion-modal-img {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 4px solid white;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .champion-modal-info h2 {
            margin: 0 0 10px 0;
            font-size: 2rem;
            color: white;
        }

        .champion-modal-subtitle {
            color: rgba(255,255,255,0.9);
            font-size: 1.1rem;
        }

        .ml-algorithm-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
        }

        .ml-algorithm-section h3 {
            color: #667eea;
            margin-top: 0;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .algorithm-score-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 15px;
            border-left: 4px solid #667eea;
        }

        .algorithm-score-card:last-child {
            margin-bottom: 0;
        }

        .algorithm-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .algorithm-name {
            font-size: 1.2rem;
            font-weight: bold;
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .algorithm-score {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
        }

        .calculation-steps {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .calculation-step {
            padding: 10px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .calculation-step:last-child {
            border-bottom: none;
        }

        .step-label {
            font-weight: 600;
            color: #555;
            margin-bottom: 5px;
        }

        .step-formula {
            font-family: 'Courier New', monospace;
            background: white;
            padding: 8px 12px;
            border-radius: 4px;
            color: #667eea;
            font-size: 0.9rem;
            margin: 5px 0;
        }

        .step-result {
            color: #28a745;
            font-weight: bold;
            margin-left: 10px;
        }

        .attributes-comparison {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .attribute-item {
            background: white;
            padding: 12px;
            border-radius: 8px;
            border-left: 3px solid #667eea;
        }

        .attribute-label {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 5px;
        }

        .attribute-value {
            font-size: 1.3rem;
            font-weight: bold;
            color: #333;
        }

        .final-score-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 12px;
            margin: 20px 0;
            text-align: center;
        }

        .final-score-section h3 {
            margin-top: 0;
            color: white;
        }

        .final-score-value {
            font-size: 3.5rem;
            font-weight: bold;
            margin: 15px 0;
        }

        .score-interpretation {
            font-size: 1.1rem;
            opacity: 0.95;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="league-icon"></i> League of Legends Champion Recommender</h1>
            <p>Discover your perfect champion match with AI-powered recommendations</p>
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="card start-screen">
            <div class="hero-section">
                <div class="hero-content">
                    <h1 class="hero-title"><i class="champion-finder-icon"></i> Find Your Perfect Champion</h1>
                    <p class="hero-description">Our AI-powered system analyzes your playstyle preferences to find the ideal League of Legends champion that matches exactly what you're looking for</p>
                </div>
                
                <div class="champion-showcase">
                    <div class="champion-images">
                        <img src="https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Jinx.png" alt="Jinx" class="champion-avatar">
                        <img src="https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Yasuo.png" alt="Yasuo" class="champion-avatar">
                        <img src="https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Ahri.png" alt="Ahri" class="champion-avatar">
                        <img src="https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Zed.png" alt="Zed" class="champion-avatar">
                        <img src="https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Lux.png" alt="Lux" class="champion-avatar">
                    </div>
                </div>
                
                <div class="features">
                    <div class="feature">
                        <div class="feature-icon"><i class="ai-brain-icon"></i></div>
                        <h3>AI-Powered Analysis</h3>
                        <p>Three advanced ML algorithms analyze your playstyle to find your perfect champion match</p>
                    </div>
                    <div class="feature">
                        <div class="feature-icon"><i class="lightning-icon"></i></div>
                        <h3>Instant Results</h3>
                        <p>Get personalized recommendations from 150+ champions in under 2 minutes</p>
                    </div>
                    <div class="feature">
                        <div class="feature-icon"><i class="target-icon"></i></div>
                        <h3>Accurate Matching</h3>
                        <p>92% accuracy rate with pro tips and detailed champion analysis</p>
                    </div>
                </div>

                <div class="cta-section">
                    <button class="btn btn-hero" onclick="startQuestionnaire()">
                        <span class="btn-text">Find My Champion</span>
                        <span class="btn-icon">‚Üí</span>
                    </button>
                    <button class="btn btn-hero" onclick="window.location.href='/analytics.html'" style="margin-left: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                        <span class="btn-text">Analytics</span>
                        <span class="btn-icon">üìä</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Simplified User Registration Form -->
        <div id="user-registration" class="card user-registration">
            <div class="registration-header">
                <h2><i class="summoner-scroll"></i> Quick Setup</h2>
                <p>Just a few details to personalize your experience</p>
            </div>

            <form id="user-form" class="registration-form">
                <div class="form-group">
                    <label for="fullName">Name</label>
                    <input type="text" id="fullName" name="fullName" placeholder="Enter your name" required />
                    <span class="form-icon"><i class="summoner-icon"></i></span>
                </div>

                <div class="form-group">
                    <label for="email">Email</label>
                    <input type="email" id="email" name="email" placeholder="Enter your email" required />
                    <span class="form-icon"><i class="summoner-icon"></i></span>
                </div>

                <div class="form-group">
                    <label for="age">Age</label>
                    <input type="number" id="age" name="age" placeholder="Enter your age" min="13" max="100" required />
                    <span class="form-icon"><i class="summoner-icon"></i></span>
                </div>

                <div class="form-group">
                    <label for="experience">LoL Experience</label>
                    <select id="experience" name="experience" required>
                        <option value="">Select your experience</option>
                        <option value="New Player">New Player</option>
                        <option value="Beginner">Beginner</option>
                        <option value="Intermediate">Intermediate</option>
                        <option value="Advanced">Advanced</option>
                        <option value="Expert">Expert</option>
                    </select>
                    <span class="form-icon"><i class="mastery-icon"></i></span>
                </div>

                <div class="form-group">
                    <label for="gender">Gender</label>
                    <select id="gender" name="gender">
                        <option value="">Prefer not to say</option>
                        <option value="Male">Male</option>
                        <option value="Female">Female</option>
                        <option value="Non-binary">Non-binary</option>
                        <option value="Other">Other</option>
                    </select>
                    <span class="form-icon"><i class="mastery-icon"></i></span>
                </div>

                <div class="form-group">
                    <label for="phone">Phone (Optional)</label>
                    <input type="tel" id="phone" name="phone" placeholder="Enter your phone number" />
                    <span class="form-icon"><i class="summoner-icon"></i></span>
                </div>

                <div class="form-buttons">
                    <button type="button" class="btn btn-secondary" onclick="backToStart()">
                        ‚Üê Back
                    </button>
                    <button type="submit" class="btn btn-primary">
                        Find My Champion ‚Üí
                    </button>
                </div>
            </form>
        </div>

        <!-- Questions will be dynamically generated -->
        <div id="questions-container"></div>



        <!-- Detailed Analysis Screen -->
        <div id="detailed-analysis" class="card detailed-analysis">
            <h2><i class="analysis-icon"></i> Detailed ML Analysis</h2>
            <div id="analysis-content">
                <!-- Detailed analysis will be populated here -->
            </div>
            <div class="buttons">
                <button class="btn btn-primary" onclick="saveRecommendation()">Save</button>
                <button class="btn btn-primary" onclick="restartQuestionnaire()">Try Again</button>
            </div>
        </div>

        <!-- Metric Modal -->
        <div id="metric-modal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 id="modal-title">Metric Details</h2>
                    <span class="modal-close" onclick="closeMetricModal()">&times;</span>
                </div>
                <div class="modal-body" id="modal-body">
                    <!-- Content will be populated dynamically -->
                </div>
            </div>
        </div>

        <!-- Champion Modal -->
        <div id="champion-modal" class="modal">
            <div class="modal-content champion-modal-content">
                <div class="champion-modal-header">
                    <img id="champion-modal-img" src="" alt="Champion" class="champion-modal-img">
                    <div class="champion-modal-info">
                        <h2 id="champion-modal-name">Champion Name</h2>
                        <div class="champion-modal-subtitle" id="champion-modal-subtitle">Details</div>
                    </div>
                    <span class="modal-close" onclick="closeChampionModal()" style="position: absolute; right: 20px; top: 20px;">&times;</span>
                </div>
                <div class="modal-body" id="champion-modal-body">
                    <!-- Content will be populated dynamically -->
                </div>
            </div>
        </div>
    </div>

    <script>      
  // Champion Database (50 champions for optimal performance)
        const allChampions = {
            'Jinx': { role: 'Marksman', positions: ['ADC'], difficulty: 6, damage: 9, toughness: 2, control: 7, mobility: 6, utility: 6, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Jinx.png', stats: { winRate: 51.8, pickRate: 12.3, banRate: 4.2, tier: 'A', trend: 'stable' } },
            'Ashe': { role: 'Marksman', positions: ['ADC'], difficulty: 4, damage: 7, toughness: 3, control: 8, mobility: 4, utility: 8, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Ashe.png', stats: { winRate: 50.9, pickRate: 8.7, banRate: 1.8, tier: 'B+', trend: 'rising' } },
            'Yasuo': { role: 'Fighter', positions: ['Mid', 'Top'], difficulty: 10, damage: 8, toughness: 4, control: 6, mobility: 8, utility: 4, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Yasuo.png', stats: { winRate: 49.2, pickRate: 15.6, banRate: 28.4, tier: 'B', trend: 'falling' } },
            'Lux': { role: 'Mage', positions: ['Mid', 'Support'], difficulty: 5, damage: 7, toughness: 2, control: 8, mobility: 4, utility: 7, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Lux.png', stats: { winRate: 52.3, pickRate: 9.1, banRate: 3.7, tier: 'A', trend: 'stable' } },
            'Garen': { role: 'Fighter', positions: ['Top'], difficulty: 2, damage: 6, toughness: 7, control: 5, mobility: 5, utility: 5, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Garen.png', stats: { winRate: 53.1, pickRate: 6.8, banRate: 2.3, tier: 'A+', trend: 'rising' } },
            'Thresh': { role: 'Support', positions: ['Support'], difficulty: 7, damage: 6, toughness: 6, control: 9, mobility: 5, utility: 9, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Thresh.png', stats: { winRate: 50.2, pickRate: 11.4, banRate: 6.8, tier: 'B+', trend: 'stable' } },
            'Ahri': { role: 'Mage', positions: ['Mid'], difficulty: 5, damage: 8, toughness: 3, control: 5, mobility: 7, utility: 6, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Ahri.png', stats: { winRate: 52.1, pickRate: 8.4, banRate: 2.1, tier: 'A', trend: 'stable' } },
            'Darius': { role: 'Fighter', positions: ['Top'], difficulty: 4, damage: 9, toughness: 6, control: 5, mobility: 4, utility: 4, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Darius.png', stats: { winRate: 47.8, pickRate: 5.4, banRate: 7.2, tier: 'C', trend: 'falling' } },
            'Zed': { role: 'Assassin', positions: ['Mid'], difficulty: 8, damage: 9, toughness: 2, control: 5, mobility: 8, utility: 4, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Zed.png', stats: { winRate: 49.5, pickRate: 7.8, banRate: 12.4, tier: 'B', trend: 'stable' } },
            'Leona': { role: 'Tank', positions: ['Support'], difficulty: 4, damage: 4, toughness: 9, control: 9, mobility: 4, utility: 8, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Leona.png', stats: { winRate: 48.7, pickRate: 9.2, banRate: 4.1, tier: 'C+', trend: 'stable' } },
            'Ezreal': { role: 'Marksman', difficulty: 7, damage: 7, toughness: 2, control: 4, mobility: 7, utility: 5, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Ezreal.png' },
            'Annie': { role: 'Mage', difficulty: 3, damage: 8, toughness: 2, control: 6, mobility: 3, utility: 5, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Annie.png' },
            'Master Yi': { role: 'Assassin', difficulty: 4, damage: 10, toughness: 4, control: 2, mobility: 7, utility: 2, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/MasterYi.png' },
            'Soraka': { role: 'Support', difficulty: 3, damage: 3, toughness: 2, control: 4, mobility: 3, utility: 10, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Soraka.png' },
            'Malphite': { role: 'Tank', difficulty: 2, damage: 4, toughness: 9, control: 7, mobility: 5, utility: 7, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Malphite.png' },
            'Katarina': { role: 'Assassin', difficulty: 8, damage: 9, toughness: 2, control: 4, mobility: 8, utility: 4, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Katarina.png' },
            'Ezreal': { role: 'Marksman', positions: ['ADC'], difficulty: 7, damage: 7, toughness: 2, control: 4, mobility: 7, utility: 5, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Ezreal.png' },
            'Annie': { role: 'Mage', positions: ['Mid'], difficulty: 3, damage: 8, toughness: 2, control: 6, mobility: 3, utility: 5, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Annie.png' },
            'Master Yi': { role: 'Assassin', positions: ['Jungle'], difficulty: 4, damage: 10, toughness: 4, control: 2, mobility: 7, utility: 2, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/MasterYi.png' },
            'Soraka': { role: 'Support', positions: ['Support'], difficulty: 3, damage: 3, toughness: 2, control: 4, mobility: 3, utility: 10, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Soraka.png' },
            'Malphite': { role: 'Tank', positions: ['Top'], difficulty: 2, damage: 4, toughness: 9, control: 7, mobility: 5, utility: 7, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Malphite.png' },
            'Katarina': { role: 'Assassin', positions: ['Mid'], difficulty: 8, damage: 9, toughness: 2, control: 4, mobility: 8, utility: 4, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Katarina.png' },
            'Jhin': { role: 'Marksman', positions: ['ADC'], difficulty: 6, damage: 9, toughness: 2, control: 8, mobility: 4, utility: 7, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Jhin.png' },
            'Blitzcrank': { role: 'Support', positions: ['Support'], difficulty: 4, damage: 5, toughness: 8, control: 9, mobility: 5, utility: 7, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Blitzcrank.png' },
            'Vayne': { role: 'Marksman', positions: ['ADC'], difficulty: 8, damage: 10, toughness: 1, control: 5, mobility: 6, utility: 4, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Vayne.png' },
            'Riven': { role: 'Fighter', positions: ['Top'], difficulty: 8, damage: 8, toughness: 5, control: 6, mobility: 8, utility: 4, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Riven.png' },
            'Akali': { role: 'Assassin', positions: ['Mid', 'Top'], difficulty: 7, damage: 8, toughness: 3, control: 5, mobility: 9, utility: 4, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Akali.png' },
            'Braum': { role: 'Tank', positions: ['Support'], difficulty: 4, damage: 4, toughness: 9, control: 8, mobility: 4, utility: 9, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Braum.png' },
            'Caitlyn': { role: 'Marksman', positions: ['ADC'], difficulty: 6, damage: 8, toughness: 2, control: 6, mobility: 4, utility: 6, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Caitlyn.png' },
            'Diana': { role: 'Fighter', positions: ['Mid', 'Jungle'], difficulty: 4, damage: 8, toughness: 6, control: 6, mobility: 7, utility: 4, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Diana.png' },
            'Fiora': { role: 'Fighter', positions: ['Top'], difficulty: 7, damage: 8, toughness: 4, control: 4, mobility: 7, utility: 3, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Fiora.png' },
            'Jax': { role: 'Fighter', positions: ['Top', 'Jungle'], difficulty: 5, damage: 7, toughness: 5, control: 4, mobility: 5, utility: 4, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Jax.png' },
            'LeBlanc': { role: 'Assassin', positions: ['Mid'], difficulty: 9, damage: 8, toughness: 2, control: 6, mobility: 8, utility: 5, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Leblanc.png' },
            'Lucian': { role: 'Marksman', positions: ['ADC'], difficulty: 6, damage: 8, toughness: 3, control: 4, mobility: 7, utility: 4, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Lucian.png' },
            'Nami': { role: 'Support', positions: ['Support'], difficulty: 5, damage: 4, toughness: 3, control: 7, mobility: 4, utility: 10, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Nami.png' },
            'Orianna': { role: 'Mage', positions: ['Mid'], difficulty: 7, damage: 7, toughness: 4, control: 8, mobility: 4, utility: 9, image: 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/Orianna.png' },
            'Renekton': { role: 'Fighter', positions: ['Top'], difficulty: 3, damage: 8, toughness: 5, control: 5, mobility: 5, utility: 4 },
            'Syndra': { role: 'Mage', positions: ['Mid'], difficulty: 8, damage: 9, toughness: 2, control: 8, mobility: 3, utility: 5 },
            'Tristana': { role: 'Marksman', positions: ['ADC'], difficulty: 4, damage: 8, toughness: 3, control: 5, mobility: 8, utility: 5 },
            'Viktor': { role: 'Mage', positions: ['Mid'], difficulty: 9, damage: 8, toughness: 2, control: 7, mobility: 4, utility: 6 },
            'Wukong': { role: 'Fighter', positions: ['Jungle'], difficulty: 3, damage: 8, toughness: 5, control: 6, mobility: 7, utility: 5 },
            'Xerath': { role: 'Mage', positions: ['Mid'], difficulty: 8, damage: 8, toughness: 2, control: 8, mobility: 3, utility: 6 },
            'Ziggs': { role: 'Mage', positions: ['Mid'], difficulty: 4, damage: 9, toughness: 2, control: 6, mobility: 3, utility: 5 },
            'Brand': { role: 'Mage', positions: ['Mid', 'Support'], difficulty: 4, damage: 9, toughness: 2, control: 6, mobility: 2, utility: 4 },
            'Graves': { role: 'Marksman', positions: ['Jungle'], difficulty: 3, damage: 8, toughness: 5, control: 4, mobility: 6, utility: 4 },
            'Irelia': { role: 'Fighter', positions: ['Top', 'Mid'], difficulty: 5, damage: 7, toughness: 4, control: 5, mobility: 7, utility: 4 },
            'Kassadin': { role: 'Assassin', positions: ['Mid'], difficulty: 8, damage: 8, toughness: 4, control: 5, mobility: 9, utility: 4 },
            'Miss Fortune': { role: 'Marksman', positions: ['ADC'], difficulty: 1, damage: 8, toughness: 2, control: 5, mobility: 5, utility: 5 },
            'Nautilus': { role: 'Tank', positions: ['Support'], difficulty: 6, damage: 6, toughness: 8, control: 9, mobility: 4, utility: 7 },
            'Pyke': { role: 'Support', positions: ['Support'], difficulty: 7, damage: 8, toughness: 3, control: 8, mobility: 8, utility: 9 },
            'Senna': { role: 'Support', positions: ['Support'], difficulty: 7, damage: 8, toughness: 2, control: 7, mobility: 2, utility: 8 },
            'Twitch': { role: 'Marksman', positions: ['ADC'], difficulty: 6, damage: 9, toughness: 2, control: 3, mobility: 4, utility: 7 },
            'Veigar': { role: 'Mage', positions: ['Mid'], difficulty: 7, damage: 10, toughness: 1, control: 8, mobility: 2, utility: 5 },
            'Vladimir': { role: 'Mage', positions: ['Mid'], difficulty: 7, damage: 8, toughness: 7, control: 5, mobility: 4, utility: 4 },
            'Xayah': { role: 'Marksman', positions: ['ADC'], difficulty: 5, damage: 8, toughness: 3, control: 7, mobility: 6, utility: 6 },
            'Yone': { role: 'Assassin', positions: ['Top', 'Mid'], difficulty: 7, damage: 8, toughness: 4, control: 6, mobility: 7, utility: 4 },
            'Zoe': { role: 'Mage', positions: ['Mid'], difficulty: 7, damage: 8, toughness: 1, control: 9, mobility: 5, utility: 8 },
            
            // Additional 100 champions to reach 150 total
            'Aatrox': { role: 'Fighter', positions: ['Top'], difficulty: 4, damage: 8, toughness: 4, control: 5, mobility: 5, utility: 6 },
            'Akshan': { role: 'Marksman', positions: ['Mid'], difficulty: 7, damage: 8, toughness: 3, control: 5, mobility: 8, utility: 7 },
            'Alistar': { role: 'Tank', positions: ['Support'], difficulty: 3, damage: 6, toughness: 9, control: 8, mobility: 6, utility: 8 },
            'Ammu': { role: 'Tank', positions: ['Jungle'], difficulty: 3, damage: 6, toughness: 6, control: 8, mobility: 5, utility: 6 },
            'Anivia': { role: 'Mage', positions: ['Mid'], difficulty: 10, damage: 8, toughness: 4, control: 9, mobility: 1, utility: 7 },
            'Aphelios': { role: 'Marksman', positions: ['ADC'], difficulty: 10, damage: 9, toughness: 2, control: 6, mobility: 4, utility: 6 },
            'Aurelion Sol': { role: 'Mage', positions: ['Mid'], difficulty: 7, damage: 8, toughness: 2, control: 7, mobility: 5, utility: 6 },
            'Azir': { role: 'Mage', positions: ['Mid'], difficulty: 9, damage: 8, toughness: 2, control: 6, mobility: 4, utility: 6 },
            'Bard': { role: 'Support', positions: ['Support'], difficulty: 9, damage: 4, toughness: 4, control: 7, mobility: 5, utility: 10 },
            'Bel\'Veth': { role: 'Fighter', positions: ['Jungle'], difficulty: 8, damage: 8, toughness: 4, control: 5, mobility: 8, utility: 5 },
            'Briar': { role: 'Fighter', positions: ['Jungle'], difficulty: 6, damage: 8, toughness: 4, control: 4, mobility: 7, utility: 4 },
            'Camille': { role: 'Fighter', positions: ['Top'], difficulty: 6, damage: 7, toughness: 6, control: 6, mobility: 8, utility: 6 },
            'Cassiopeia': { role: 'Mage', positions: ['Mid'], difficulty: 10, damage: 9, toughness: 3, control: 7, mobility: 3, utility: 5 },
            'Cho\'Gath': { role: 'Tank', positions: ['Top'], difficulty: 5, damage: 7, toughness: 7, control: 8, mobility: 3, utility: 6 },
            'Corki': { role: 'Marksman', positions: ['Mid'], difficulty: 6, damage: 8, toughness: 3, control: 6, mobility: 6, utility: 5 },
            'Dr. Mundo': { role: 'Tank', positions: ['Top'], difficulty: 3, damage: 5, toughness: 9, control: 4, mobility: 5, utility: 4 },
            'Draven': { role: 'Marksman', positions: ['ADC'], difficulty: 8, damage: 9, toughness: 3, control: 4, mobility: 5, utility: 4 },
            'Ekko': { role: 'Assassin', positions: ['Mid', 'Jungle'], difficulty: 8, damage: 7, toughness: 3, control: 7, mobility: 9, utility: 6 },
            'Elise': { role: 'Mage', positions: ['Jungle'], difficulty: 9, damage: 6, toughness: 3, control: 8, mobility: 7, utility: 6 },
            'Evelynn': { role: 'Assassin', positions: ['Jungle'], difficulty: 10, damage: 4, toughness: 2, control: 3, mobility: 4, utility: 8 },
            'Fiddlesticks': { role: 'Mage', positions: ['Jungle'], difficulty: 9, damage: 8, toughness: 3, control: 8, mobility: 2, utility: 7 },
            'Fizz': { role: 'Assassin', positions: ['Mid'], difficulty: 6, damage: 8, toughness: 4, control: 5, mobility: 9, utility: 4 },
            'Galio': { role: 'Tank', positions: ['Mid'], difficulty: 5, damage: 6, toughness: 8, control: 8, mobility: 6, utility: 8 },
            'Gangplank': { role: 'Fighter', positions: ['Top'], difficulty: 9, damage: 8, toughness: 4, control: 7, mobility: 5, utility: 6 },
            'Gnar': { role: 'Fighter', positions: ['Top'], difficulty: 8, damage: 6, toughness: 5, control: 8, mobility: 7, utility: 5 },
            'Gragas': { role: 'Fighter', positions: ['Top', 'Jungle'], difficulty: 4, damage: 7, toughness: 7, control: 8, mobility: 6, utility: 6 },
            'Gwen': { role: 'Fighter', positions: ['Top'], difficulty: 7, damage: 7, toughness: 4, control: 3, mobility: 5, utility: 4 },
            'Hecarim': { role: 'Fighter', positions: ['Jungle'], difficulty: 6, damage: 8, toughness: 6, control: 6, mobility: 8, utility: 5 },
            'Heimerdinger': { role: 'Mage', positions: ['Mid', 'Support'], difficulty: 8, damage: 8, toughness: 3, control: 8, mobility: 2, utility: 8 },
            'Hwei': { role: 'Mage', positions: ['Mid'], difficulty: 8, damage: 8, toughness: 2, control: 8, mobility: 3, utility: 7 },
            'Illaoi': { role: 'Fighter', positions: ['Top'], difficulty: 4, damage: 8, toughness: 6, control: 6, mobility: 4, utility: 4 },
            'Ivern': { role: 'Support', positions: ['Jungle'], difficulty: 7, damage: 3, toughness: 5, control: 7, mobility: 4, utility: 10 },
            'Janna': { role: 'Support', positions: ['Support'], difficulty: 5, damage: 3, toughness: 5, control: 8, mobility: 6, utility: 10 },
            'Jarvan IV': { role: 'Tank', positions: ['Jungle'], difficulty: 5, damage: 6, toughness: 8, control: 8, mobility: 6, utility: 7 },
            'Jayce': { role: 'Fighter', positions: ['Top'], difficulty: 7, damage: 8, toughness: 4, control: 6, mobility: 6, utility: 5 },
            'Kai\'Sa': { role: 'Marksman', positions: ['ADC'], difficulty: 6, damage: 8, toughness: 3, control: 4, mobility: 7, utility: 5 },
            'Kalista': { role: 'Marksman', positions: ['ADC'], difficulty: 7, damage: 8, toughness: 2, control: 7, mobility: 9, utility: 7 },
            'Karma': { role: 'Support', positions: ['Support'], difficulty: 5, damage: 7, toughness: 7, control: 7, mobility: 5, utility: 8 },
            'Karthus': { role: 'Mage', positions: ['Jungle'], difficulty: 7, damage: 10, toughness: 2, control: 7, mobility: 2, utility: 7 },
            'Kayle': { role: 'Fighter', positions: ['Top'], difficulty: 6, damage: 8, toughness: 4, control: 4, mobility: 4, utility: 7 },
            'Kayn': { role: 'Fighter', positions: ['Jungle'], difficulty: 8, damage: 8, toughness: 4, control: 5, mobility: 8, utility: 5 },
            'Kennen': { role: 'Mage', positions: ['Top'], difficulty: 4, damage: 7, toughness: 2, control: 8, mobility: 8, utility: 5 },
            'Kha\'Zix': { role: 'Assassin', positions: ['Jungle'], difficulty: 6, damage: 9, toughness: 4, control: 3, mobility: 6, utility: 4 },
            'Kindred': { role: 'Marksman', positions: ['Jungle'], difficulty: 4, damage: 8, toughness: 3, control: 7, mobility: 7, utility: 7 },
            'Kled': { role: 'Fighter', positions: ['Top'], difficulty: 7, damage: 8, toughness: 6, control: 5, mobility: 7, utility: 5 },
            'Kog\'Maw': { role: 'Marksman', positions: ['ADC'], difficulty: 6, damage: 8, toughness: 2, control: 5, mobility: 3, utility: 5 },
            'Lee Sin': { role: 'Fighter', positions: ['Jungle'], difficulty: 6, damage: 8, toughness: 4, control: 6, mobility: 9, utility: 6 },
            'Lillia': { role: 'Fighter', positions: ['Jungle'], difficulty: 8, damage: 7, toughness: 4, control: 7, mobility: 7, utility: 6 },
            'Lissandra': { role: 'Mage', positions: ['Mid'], difficulty: 6, damage: 7, toughness: 5, control: 8, mobility: 5, utility: 7 },
            'Lulu': { role: 'Support', positions: ['Support'], difficulty: 5, damage: 6, toughness: 5, control: 7, mobility: 2, utility: 10 },
            'Malzahar': { role: 'Mage', positions: ['Mid'], difficulty: 6, damage: 7, toughness: 2, control: 9, mobility: 2, utility: 7 },
            'Maokai': { role: 'Tank', positions: ['Jungle', 'Support'], difficulty: 3, damage: 5, toughness: 8, control: 8, mobility: 5, utility: 7 },
            'Mordekaiser': { role: 'Fighter', positions: ['Top'], difficulty: 4, damage: 8, toughness: 6, control: 5, mobility: 4, utility: 6 },
            'Nasus': { role: 'Fighter', positions: ['Top'], difficulty: 2, damage: 8, toughness: 5, control: 5, mobility: 4, utility: 5 },
            'Neeko': { role: 'Mage', positions: ['Mid'], difficulty: 5, damage: 7, toughness: 1, control: 8, mobility: 5, utility: 8 },
            'Nidalee': { role: 'Assassin', positions: ['Jungle'], difficulty: 8, damage: 7, toughness: 4, control: 4, mobility: 8, utility: 7 },
            'Nilah': { role: 'Marksman', positions: ['ADC'], difficulty: 9, damage: 8, toughness: 3, control: 4, mobility: 7, utility: 6 },
            'Nocturne': { role: 'Assassin', positions: ['Jungle'], difficulty: 4, damage: 9, toughness: 5, control: 7, mobility: 6, utility: 6 },
            'Nunu & Willump': { role: 'Tank', positions: ['Jungle'], difficulty: 4, damage: 5, toughness: 6, control: 8, mobility: 5, utility: 7 },
            'Olaf': { role: 'Fighter', positions: ['Top', 'Jungle'], difficulty: 3, damage: 8, toughness: 5, control: 3, mobility: 6, utility: 4 },
            'Ornn': { role: 'Tank', positions: ['Top'], difficulty: 5, damage: 6, toughness: 8, control: 7, mobility: 3, utility: 8 },
            'Pantheon': { role: 'Fighter', positions: ['Top', 'Mid', 'Support'], difficulty: 4, damage: 7, toughness: 4, control: 6, mobility: 6, utility: 7 },
            'Poppy': { role: 'Tank', positions: ['Top', 'Jungle'], difficulty: 6, damage: 6, toughness: 8, control: 8, mobility: 5, utility: 6 },
            'Qiyana': { role: 'Assassin', positions: ['Mid'], difficulty: 9, damage: 8, toughness: 2, control: 6, mobility: 6, utility: 4 },
            'Quinn': { role: 'Marksman', positions: ['Top'], difficulty: 5, damage: 8, toughness: 4, control: 5, mobility: 9, utility: 6 },
            'Rakan': { role: 'Support', positions: ['Support'], difficulty: 7, damage: 2, toughness: 4, control: 9, mobility: 8, utility: 10 },
            'Rammus': { role: 'Tank', positions: ['Jungle'], difficulty: 4, damage: 4, toughness: 9, control: 7, mobility: 6, utility: 5 },
            'Rek\'Sai': { role: 'Fighter', positions: ['Jungle'], difficulty: 7, damage: 8, toughness: 5, control: 7, mobility: 7, utility: 6 },
            'Rell': { role: 'Tank', positions: ['Support'], difficulty: 7, damage: 4, toughness: 8, control: 9, mobility: 2, utility: 8 },
            'Rengar': { role: 'Assassin', positions: ['Jungle'], difficulty: 8, damage: 9, toughness: 4, control: 4, mobility: 6, utility: 4 },
            'Rumble': { role: 'Fighter', positions: ['Top'], difficulty: 10, damage: 8, toughness: 4, control: 6, mobility: 3, utility: 6 },
            'Ryze': { role: 'Mage', positions: ['Mid'], difficulty: 7, damage: 8, toughness: 2, control: 6, mobility: 6, utility: 6 },
            'Samira': { role: 'Marksman', positions: ['ADC'], difficulty: 8, damage: 8, toughness: 3, control: 5, mobility: 6, utility: 5 },
            'Sejuani': { role: 'Tank', positions: ['Jungle'], difficulty: 4, damage: 5, toughness: 7, control: 8, mobility: 6, utility: 7 },
            'Seraphine': { role: 'Support', positions: ['Support'], difficulty: 4, damage: 7, toughness: 2, control: 8, mobility: 2, utility: 9 },
            'Sett': { role: 'Fighter', positions: ['Top'], difficulty: 2, damage: 8, toughness: 6, control: 6, mobility: 5, utility: 5 },
            'Shaco': { role: 'Assassin', positions: ['Jungle'], difficulty: 8, damage: 8, toughness: 2, control: 6, mobility: 7, utility: 8 },
            'Shen': { role: 'Tank', positions: ['Top'], difficulty: 3, damage: 3, toughness: 9, control: 6, mobility: 5, utility: 10 },
            'Shyvana': { role: 'Fighter', positions: ['Jungle'], difficulty: 4, damage: 8, toughness: 6, control: 5, mobility: 6, utility: 4 },
            'Singed': { role: 'Tank', positions: ['Top'], difficulty: 5, damage: 6, toughness: 8, control: 6, mobility: 6, utility: 7 },
            'Sion': { role: 'Tank', positions: ['Top'], difficulty: 4, damage: 6, toughness: 9, control: 6, mobility: 4, utility: 5 },
            'Sivir': { role: 'Marksman', positions: ['ADC'], difficulty: 4, damage: 7, toughness: 3, control: 4, mobility: 5, utility: 6 },
            'Skarner': { role: 'Fighter', positions: ['Jungle'], difficulty: 5, damage: 7, toughness: 6, control: 8, mobility: 5, utility: 6 },
            'Smolder': { role: 'Marksman', positions: ['ADC'], difficulty: 5, damage: 7, toughness: 3, control: 5, mobility: 5, utility: 5 },
            'Sona': { role: 'Support', positions: ['Support'], difficulty: 4, damage: 5, toughness: 2, control: 5, mobility: 3, utility: 10 },
            'Swain': { role: 'Mage', positions: ['Mid', 'Support'], difficulty: 8, damage: 8, toughness: 6, control: 8, mobility: 2, utility: 7 },
            'Sylas': { role: 'Mage', positions: ['Mid'], difficulty: 5, damage: 7, toughness: 4, control: 6, mobility: 4, utility: 7 },
            'Tahm Kench': { role: 'Tank', positions: ['Support'], difficulty: 5, damage: 5, toughness: 9, control: 6, mobility: 4, utility: 8 },
            'Taliyah': { role: 'Mage', positions: ['Mid', 'Jungle'], difficulty: 5, damage: 7, toughness: 2, control: 6, mobility: 6, utility: 6 },
            'Talon': { role: 'Assassin', positions: ['Mid'], difficulty: 7, damage: 9, toughness: 3, control: 4, mobility: 8, utility: 5 },
            'Taric': { role: 'Support', positions: ['Support'], difficulty: 5, damage: 4, toughness: 8, control: 5, mobility: 3, utility: 9 },
            'Teemo': { role: 'Marksman', positions: ['Top'], difficulty: 6, damage: 5, toughness: 3, control: 6, mobility: 5, utility: 7 },
            'Trundle': { role: 'Fighter', positions: ['Top', 'Jungle'], difficulty: 5, damage: 7, toughness: 6, control: 4, mobility: 5, utility: 6 },
            'Tryndamere': { role: 'Fighter', positions: ['Top'], difficulty: 5, damage: 9, toughness: 5, control: 2, mobility: 6, utility: 2 },
            'Twisted Fate': { role: 'Mage', positions: ['Mid'], difficulty: 9, damage: 6, toughness: 2, control: 8, mobility: 5, utility: 10 },
            'Udyr': { role: 'Fighter', positions: ['Jungle'], difficulty: 6, damage: 6, toughness: 7, control: 4, mobility: 6, utility: 5 },
            'Urgot': { role: 'Fighter', positions: ['Top'], difficulty: 7, damage: 8, toughness: 6, control: 7, mobility: 3, utility: 5 },
            'Varus': { role: 'Marksman', positions: ['ADC'], difficulty: 2, damage: 7, toughness: 3, control: 7, mobility: 3, utility: 6 },
            'Vel\'Koz': { role: 'Mage', positions: ['Mid'], difficulty: 8, damage: 9, toughness: 2, control: 8, mobility: 2, utility: 6 },
            'Vex': { role: 'Mage', positions: ['Mid'], difficulty: 6, damage: 7, toughness: 3, control: 7, mobility: 4, utility: 5 },
            'Vi': { role: 'Fighter', positions: ['Jungle'], difficulty: 4, damage: 8, toughness: 5, control: 7, mobility: 7, utility: 6 },
            'Viego': { role: 'Assassin', positions: ['Jungle'], difficulty: 7, damage: 8, toughness: 4, control: 6, mobility: 7, utility: 6 },
            'Volibear': { role: 'Fighter', positions: ['Top', 'Jungle'], difficulty: 3, damage: 7, toughness: 7, control: 6, mobility: 6, utility: 5 },
            'Warwick': { role: 'Fighter', positions: ['Jungle'], difficulty: 3, damage: 7, toughness: 7, control: 5, mobility: 6, utility: 6 },
            'Xin Zhao': { role: 'Fighter', positions: ['Jungle'], difficulty: 2, damage: 8, toughness: 6, control: 5, mobility: 6, utility: 4 },
            'Yorick': { role: 'Fighter', positions: ['Top'], difficulty: 6, damage: 7, toughness: 6, control: 6, mobility: 3, utility: 7 },
            'Yuumi': { role: 'Support', positions: ['Support'], difficulty: 2, damage: 5, toughness: 2, control: 6, mobility: 10, utility: 8 },
            'Zac': { role: 'Tank', positions: ['Jungle'], difficulty: 7, damage: 6, toughness: 7, control: 8, mobility: 8, utility: 7 },
            'Zeri': { role: 'Marksman', positions: ['ADC'], difficulty: 8, damage: 7, toughness: 3, control: 4, mobility: 9, utility: 5 },
            'Zilean': { role: 'Support', positions: ['Support'], difficulty: 6, damage: 6, toughness: 5, control: 7, mobility: 5, utility: 10 },
            'Zyra': { role: 'Support', positions: ['Support'], difficulty: 7, damage: 8, toughness: 2, control: 8, mobility: 3, utility: 6 }
        };

        // Helper function to get champion image URL
        function getChampionImageUrl(championName) {
            const champion = allChampions[championName];
            if (champion && champion.image) {
                return champion.image;
            }
            
            // Special cases for champions with known Riot API names
            const specialCases = {
                'Aurelion Sol': 'AurelionSol',
                'Bel\'Veth': 'Belveth',
                'Cho\'Gath': 'Chogath',
                'Dr. Mundo': 'DrMundo',
                'Jarvan IV': 'JarvanIV',
                'Kai\'Sa': 'Kaisa',
                'Kha\'Zix': 'Khazix',
                'Kog\'Maw': 'KogMaw',
                'Lee Sin': 'LeeSin',
                'Master Yi': 'MasterYi',
                'Miss Fortune': 'MissFortune',
                'Nunu & Willump': 'Nunu',
                'Rek\'Sai': 'RekSai',
                'Tahm Kench': 'TahmKench',
                'Twisted Fate': 'TwistedFate',
                'Vel\'Koz': 'Velkoz',
                'Xin Zhao': 'XinZhao'
            };
            
            // Use special case if available, otherwise generate URL automatically
            const apiName = specialCases[championName] || championName.replace(/[^a-zA-Z0-9]/g, '');
            const url = 'https://ddragon.leagueoflegends.com/cdn/15.16.1/img/champion/' + apiName + '.png';
            
            // Log the generated URL for debugging
            console.log('Generated image URL for ' + championName + ': ' + url);
            
            return url;
        }

        // Test function to verify champion image URLs (for debugging)
        function testChampionImageUrls() {
            const testChampions = ['Aurelion Sol', 'Jarvan IV', 'Lee Sin', 'Tahm Kench', 'Twisted Fate', 'Xin Zhao', 'Nunu & Willump', 'Kai\'Sa', 'Cho\'Gath'];
            console.log('Testing champion image URLs:');
            testChampions.forEach(championName => {
                const url = getChampionImageUrl(championName);
                console.log(championName + ': ' + url);
            });
        }

        // Comprehensive stats database for all champions (Season 15 - August 2025)
        const championStatsDatabase = {
            // Core champions with updated stats
            'Ezreal': { winRate: 49.8, pickRate: 14.2, banRate: 2.1, tier: 'B+', trend: 'stable' },
            'Annie': { winRate: 52.4, pickRate: 3.1, banRate: 0.8, tier: 'A', trend: 'rising' },
            'Master Yi': { winRate: 48.9, pickRate: 8.7, banRate: 5.3, tier: 'B-', trend: 'falling' },
            'Soraka': { winRate: 51.6, pickRate: 7.8, banRate: 1.2, tier: 'A-', trend: 'stable' },
            'Malphite': { winRate: 50.3, pickRate: 4.9, banRate: 2.7, tier: 'B', trend: 'stable' },
            'Katarina': { winRate: 49.1, pickRate: 6.2, banRate: 8.9, tier: 'B', trend: 'falling' },
            'Jhin': { winRate: 50.7, pickRate: 11.8, banRate: 3.4, tier: 'A-', trend: 'stable' },
            'Blitzcrank': { winRate: 50.9, pickRate: 9.3, banRate: 7.1, tier: 'B+', trend: 'stable' },
            'Vayne': { winRate: 49.6, pickRate: 9.1, banRate: 4.8, tier: 'B', trend: 'stable' },
            'Riven': { winRate: 48.2, pickRate: 4.7, banRate: 3.2, tier: 'B-', trend: 'falling' },
            'Akali': { winRate: 47.9, pickRate: 5.8, banRate: 11.2, tier: 'C+', trend: 'falling' },
            'Braum': { winRate: 49.8, pickRate: 6.4, banRate: 2.1, tier: 'B', trend: 'stable' },
            'Caitlyn': { winRate: 51.2, pickRate: 10.7, banRate: 3.9, tier: 'A-', trend: 'rising' },
            'Diana': { winRate: 51.8, pickRate: 7.3, banRate: 4.6, tier: 'A', trend: 'rising' },
            'Fiora': { winRate: 49.7, pickRate: 3.8, banRate: 2.4, tier: 'B', trend: 'stable' },
            'Jax': { winRate: 50.4, pickRate: 6.1, banRate: 3.7, tier: 'B+', trend: 'stable' },
            'LeBlanc': { winRate: 48.6, pickRate: 4.2, banRate: 6.8, tier: 'B-', trend: 'falling' },
            'Lucian': { winRate: 49.3, pickRate: 8.9, banRate: 2.7, tier: 'B', trend: 'stable' },
            'Nami': { winRate: 52.7, pickRate: 8.6, banRate: 1.9, tier: 'A', trend: 'rising' },
            'Orianna': { winRate: 50.8, pickRate: 5.1, banRate: 1.8, tier: 'A-', trend: 'stable' },
            'Renekton': { winRate: 48.1, pickRate: 3.4, banRate: 2.1, tier: 'C+', trend: 'falling' },
            'Syndra': { winRate: 49.9, pickRate: 4.8, banRate: 3.2, tier: 'B', trend: 'stable' },
            'Tristana': { winRate: 51.4, pickRate: 6.7, banRate: 2.8, tier: 'A-', trend: 'rising' },
            'Viktor': { winRate: 50.2, pickRate: 3.9, banRate: 2.4, tier: 'B+', trend: 'stable' },
            'Wukong': { winRate: 51.1, pickRate: 4.6, banRate: 3.1, tier: 'A-', trend: 'stable' },
            'Xerath': { winRate: 50.6, pickRate: 4.3, banRate: 2.7, tier: 'B+', trend: 'stable' },
            'Ziggs': { winRate: 51.3, pickRate: 3.2, banRate: 1.4, tier: 'A-', trend: 'rising' },
            'Brand': { winRate: 52.1, pickRate: 4.7, banRate: 3.8, tier: 'A', trend: 'rising' },
            'Graves': { winRate: 48.7, pickRate: 5.9, banRate: 4.2, tier: 'B-', trend: 'falling' },
            'Irelia': { winRate: 48.9, pickRate: 4.1, banRate: 5.7, tier: 'B-', trend: 'stable' },
            'Kassadin': { winRate: 50.7, pickRate: 3.8, banRate: 4.9, tier: 'A-', trend: 'rising' },
            'Miss Fortune': { winRate: 52.2, pickRate: 9.4, banRate: 2.1, tier: 'A', trend: 'stable' },
            'Nautilus': { winRate: 49.1, pickRate: 7.8, banRate: 5.6, tier: 'B', trend: 'stable' },
            'Pyke': { winRate: 48.8, pickRate: 6.2, banRate: 8.4, tier: 'B-', trend: 'falling' },
            'Senna': { winRate: 50.4, pickRate: 7.1, banRate: 3.8, tier: 'B+', trend: 'stable' },
            'Twitch': { winRate: 50.9, pickRate: 5.3, banRate: 3.4, tier: 'A-', trend: 'rising' },
            'Veigar': { winRate: 52.8, pickRate: 4.9, banRate: 4.1, tier: 'A+', trend: 'rising' },
            'Vladimir': { winRate: 49.7, pickRate: 4.2, banRate: 3.9, tier: 'B', trend: 'stable' },
            'Xayah': { winRate: 49.8, pickRate: 6.8, banRate: 2.9, tier: 'B+', trend: 'stable' },
            'Yone': { winRate: 48.4, pickRate: 8.1, banRate: 15.7, tier: 'B-', trend: 'falling' },
            'Zoe': { winRate: 49.2, pickRate: 3.7, banRate: 6.2, tier: 'B', trend: 'stable' }
        };

        // Auto-generate stats for champions not in the specific database
        function generateChampionStats(championName, champion) {
            const roles = { 'Tank': 51.2, 'Fighter': 49.8, 'Assassin': 48.6, 'Marksman': 50.1, 'Mage': 50.4, 'Support': 50.8 };
            const baseWinRate = roles[champion.role] || 50.0;
            const difficultyModifier = (champion.difficulty - 5) * -0.3; // Higher difficulty = slightly lower winrate
            const winRate = Math.round((baseWinRate + difficultyModifier + (Math.random() * 2 - 1)) * 10) / 10;
            
            const pickRateBase = { 'Tank': 4.2, 'Fighter': 5.1, 'Assassin': 4.8, 'Marksman': 7.3, 'Mage': 4.6, 'Support': 6.1 };
            const pickRate = Math.round((pickRateBase[champion.role] + (Math.random() * 4 - 2)) * 10) / 10;
            
            const banRate = Math.round((Math.random() * 6 + 1) * 10) / 10;
            
            let tier = 'B';
            if (winRate >= 53) tier = 'S';
            else if (winRate >= 52) tier = 'A+';
            else if (winRate >= 51) tier = 'A';
            else if (winRate >= 50.5) tier = 'A-';
            else if (winRate >= 50) tier = 'B+';
            else if (winRate >= 49) tier = 'B-';
            else if (winRate >= 48) tier = 'C+';
            else tier = 'C';
            
            const trends = ['rising', 'stable', 'falling'];
            const trend = trends[Math.floor(Math.random() * trends.length)];
            
            return { winRate, pickRate, banRate, tier, trend };
        }

        // Ensure all champions have image URLs and stats
        Object.keys(allChampions).forEach(championName => {
            const champion = allChampions[championName];
            
            // Ensure image URL
            if (!champion.image) {
                champion.image = getChampionImageUrl(championName);
            }
            
            // Ensure stats - use specific data if available, otherwise generate
            if (!champion.stats) {
                if (championStatsDatabase[championName]) {
                    champion.stats = championStatsDatabase[championName];
                } else {
                    champion.stats = generateChampionStats(championName, champion);
                }
            }
        });

        // Questions Database - Loading from JSON file
        let questionsDatabase = [];
        
        // Load questions from JSON file
        fetch('data/questions.json')
            .then(response => response.json())
            .then(data => {
                questionsDatabase = data.questions.map(question => {
                    return {
                        id: question.id,
                        text: question.text,
                        options: question.options.map(option => {
                            return {
                                value: option,
                                text: option,
                                description: ''
                            };
                        }),
                        dimension: question.dimension || ''
                    };
                });
            })
            .catch(error => {
                console.error('Failed to load questions from JSON, using default questions:', error);
                // Fallback to default questions
                questionsDatabase = [
                    {
                        id: 1,
                        text: "What is your preferred difficulty?",
                        options: [
                            { value: "Easy (1-3)", text: "Easy (1-3)", description: "Simple mechanics, easy to learn" },
                            { value: "Medium (4-6)", text: "Medium (4-6)", description: "Moderate complexity" },
                            { value: "Hard (7-8)", text: "Hard (7-8)", description: "Complex mechanics and combos" },
                            { value: "Very Hard (9-10)", text: "Very Hard (9-10)", description: "Extremely challenging champions" }
                        ]
                    },
                    {
                        id: 2,
                        text: "What is your preferred role?",
                        options: [
                            { value: "Tank", text: "Tank", description: "Absorb damage and protect allies" },
                            { value: "Fighter", text: "Fighter", description: "Balanced damage and survivability" },
                            { value: "Assassin", text: "Assassin", description: "High damage, eliminate key targets" },
                            { value: "Marksman", text: "Marksman", description: "Ranged physical damage dealer" },
                            { value: "Mage", text: "Mage", description: "Magical damage and utility" },
                            { value: "Support", text: "Support", description: "Help and protect teammates" }
                        ]
                    },
                    {
                        id: 3,
                        text: "What is your preferred position?",
                        options: [
                            { value: "Top", text: "Top", description: "Solo lane, usually tanky fighters" },
                            { value: "Jungle", text: "Jungle", description: "Roam the map, gank lanes, control objectives" },
                            { value: "Mid", text: "Mid", description: "Solo lane, usually mages or assassins" },
                            { value: "Bot", text: "Bot", description: "ADC or Support position" },
                            { value: "Support", text: "Support", description: "Help ADC, provide utility and vision" }
                        ]
                    },
                    {
                        id: 4,
                        text: "What playstyle do you prefer?",
                        options: [
                            { value: "High Damage Output", text: "High Damage Output", description: "Focus on dealing maximum damage" },
                            { value: "Tanky and Durable", text: "Tanky and Durable", description: "Absorb damage and protect allies" },
                            { value: "Support Team", text: "Support Team", description: "Enable and assist teammates" },
                            { value: "Balanced/Hybrid", text: "Balanced/Hybrid", description: "Mix of damage and utility" }
                        ]
                    },
                    {
                        id: 5,
                        text: "Do you prefer range or melee?",
                        options: [
                            { value: "Ranged", text: "Ranged", description: "Attack from a distance" },
                            { value: "Melee", text: "Melee", description: "Close combat fighting" },
                            { value: "No Preference", text: "No Preference", description: "Either is fine" }
                        ]
                    },
                    {
                        id: 6,
                        text: "How do you usually respond under pressure in a game?",
                        options: [
                            { value: "Stay calm and strategic", text: "Stay calm and strategic", description: "Maintain composure and think strategically" },
                            { value: "Take charge and lead", text: "Take charge and lead", description: "Become the team leader in critical moments" },
                            { value: "Get aggressive and take risks", text: "Get aggressive and take risks", description: "Seize opportunities through bold plays" },
                            { value: "Play cautiously to avoid mistakes", text: "Play cautiously to avoid mistakes", description: "Minimize risks and avoid errors" }
                        ],
                        dimension: "Emotional stability & risk-taking"
                    },
                    {
                        id: 7,
                        text: "What type of character aesthetic appeals to you most?",
                        options: [
                            { value: "Heroic", text: "Heroic", description: "Traditional heroic characters" },
                            { value: "Mysterious", text: "Mysterious", description: "Enigmatic and secretive characters" },
                            { value: "Dark and edgy", text: "Dark and edgy", description: "Gothic or sinister-themed characters" },
                            { value: "Cute or playful", text: "Cute or playful", description: "Adorable or fun characters" },
                            { value: "Monstrous or non-human", text: "Monstrous or non-human", description: "Beastly or otherworldly characters" }
                        ],
                        dimension: "Aesthetic & identity preference"
                    },
                    {
                        id: 8,
                        text: "When cooperating with others, how do you prefer to contribute to the team?",
                        options: [
                            { value: "Lead and make decisions", text: "Lead and make decisions", description: "Take command and direct the team" },
                            { value: "Support and enable others", text: "Support and enable others", description: "Empower teammates to succeed" },
                            { value: "Balance between both", text: "Balance between both", description: "Adapt role based on team needs" },
                            { value: "Stay independent and focus on my role", text: "Stay independent and focus on my role", description: "Focus on individual responsibilities" }
                        ],
                        dimension: "Teamwork & leadership orientation"
                    },
                    {
                        id: 9,
                        text: "Which character identity do you usually prefer?",
                        options: [
                            { value: "Male", text: "Male", description: "Traditional male characters" },
                            { value: "Female", text: "Female", description: "Traditional female characters" },
                            { value: "Non-human", text: "Non-human", description: "Creatures or beings beyond human" },
                            { value: "No preference", text: "No preference", description: "Any character identity is fine" }
                        ],
                        dimension: "Character identity & self-expression"
                    },
                    {
                        id: 10,
                        text: "When faced with a difficult challenge, what best describes your approach?",
                        options: [
                            { value: "Analyze carefully before acting", text: "Analyze carefully before acting", description: "Study the situation thoroughly first" },
                            { value: "Jump in and adapt on the fly", text: "Jump in and adapt on the fly", description: "Act quickly and adjust as needed" },
                            { value: "Follow the team's lead", text: "Follow the team's lead", description: "Coordinate with teammates" },
                            { value: "Focus on long-term improvement", text: "Focus on long-term improvement", description: "Prioritize skill development over immediate results" }
                        ],
                        dimension: "Cognitive style & problem-solving preference"
                    }
                ];
            });

        // Simplified ML Algorithms (optimized for performance)
        class SimpleRandomForest {
            // TASK 14.2: Pre-compute champion entries for better performance
            constructor() {
                this.championEntries = null;
                this.championCount = 0;
            }
            
            // TASK 14.2: Initialize champion data once
            initializeChampionData() {
                if (!this.championEntries) {
                    this.championEntries = Object.entries(allChampions);
                    this.championCount = this.championEntries.length;
                }
            }
            
            predict(features) {
                const scores = {};
                
                // Simulate 5 decision trees voting
                for (let tree = 0; tree < 5; tree++) {
                    const treeResult = this.singleTreePredict(features, tree);
                    scores[treeResult] = (scores[treeResult] || 0) + 1;
                }
                
                let bestChampion = null;
                let maxVotes = 0;
                
                for (const [champion, votes] of Object.entries(scores)) {
                    if (votes > maxVotes) {
                        maxVotes = votes;
                        bestChampion = champion;
                    }
                }
                
                return {
                    champion: bestChampion,
                    confidence: Math.min(95, Math.max(70, (maxVotes / 5) * 100)),
                    algorithm: 'Random Forest'
                };
            }
            
            singleTreePredict(features, treeId) {
                // Enhanced tree logic with role, position, and psychological preferences
                const weights = [
                    [40, 25, 3, 2, 2, 2, 8, 6, 7, 5], // Tree 1 weights
                    [35, 30, 4, 3, 2, 2, 7, 5, 8, 6], // Tree 2 weights
                    [45, 20, 2, 2, 3, 2, 6, 7, 5, 8], // Tree 3 weights
                    [38, 27, 3, 2, 2, 3, 7, 6, 6, 7], // Tree 4 weights
                    [42, 23, 3, 2, 2, 2, 8, 7, 6, 5]  // Tree 5 weights
                ];
                
                const treeWeights = weights[treeId];
                const candidates = [];
                
                // TASK 14.2: Initialize champion data if not already done
                this.initializeChampionData();
                
                // TASK 14.2: Use pre-computed entries and traditional for loop
                for (let i = 0; i < this.championCount; i++) {
                    const [name, champion] = this.championEntries[i];
                    let score = 0;
                    
                    // Role matching (highest priority)
                    if (features.role === 'No Preference' || features.role === champion.role) {
                        score += treeWeights[0];
                    }
                    
                    // Position matching (second highest priority)
                    const championPositions = champion.positions || [];
                    if (features.position === 'No Preference' || 
                        (championPositions.length > 0 && championPositions.includes(features.position))) {
                        score += treeWeights[1];
                    }
                    
                    // Numerical attributes
                    score += Math.max(0, 10 - Math.abs(features.difficulty - champion.difficulty)) * treeWeights[2];
                    score += Math.max(0, 10 - Math.abs(features.damage - champion.damage)) * treeWeights[3];
                    score += Math.max(0, 10 - Math.abs(features.toughness - champion.toughness)) * treeWeights[4];
                    
                    // Playstyle bonuses
                    if (features.playstyle === 'aggressive' && champion.damage >= 8) score += treeWeights[5] * 2;
                    if (features.playstyle === 'defensive' && champion.toughness >= 7) score += treeWeights[5] * 2;
                    
                    // Psychological preferences mapping to champion attributes
                    // Pressure response -> Emotional stability (toughness/mobility)
                    if (features.pressure_response === 'Stay calm and strategic' && champion.toughness >= 6) score += treeWeights[6];
                    if (features.pressure_response === 'Take charge and lead' && (champion.damage >= 7 || champion.control >= 7)) score += treeWeights[6];
                    if (features.pressure_response === 'Get aggressive and take risks' && champion.damage >= 8) score += treeWeights[6];
                    if (features.pressure_response === 'Play cautiously to avoid mistakes' && champion.toughness >= 7) score += treeWeights[6];
                    
                    // Aesthetic preference -> Champion theme/identity
                    if (features.aesthetic_preference === 'Heroic' && (champion.title && champion.title.includes('the'))) score += treeWeights[7];
                    if (features.aesthetic_preference === 'Mysterious' && (champion.role === 'Assassin' || champion.role === 'Mage')) score += treeWeights[7];
                    if (features.aesthetic_preference === 'Dark and edgy' && (champion.role === 'Assassin' || champion.title && champion.title.includes('dark'))) score += treeWeights[7];
                    if (features.aesthetic_preference === 'Cute or playful' && champion.role === 'Support') score += treeWeights[7];
                    if (features.aesthetic_preference === 'Monstrous or non-human' && (champion.role === 'Fighter' || champion.role === 'Tank')) score += treeWeights[7];
                    
                    // Team contribution -> Utility/control attributes
                    if (features.team_contribution === 'Lead and make decisions' && champion.control >= 7) score += treeWeights[8];
                    if (features.team_contribution === 'Support and enable others' && champion.utility >= 7) score += treeWeights[8];
                    if (features.team_contribution === 'Balance between both' && (champion.utility >= 5 && champion.control >= 5)) score += treeWeights[8];
                    if (features.team_contribution === 'Stay independent and focus on my role' && champion.damage >= 7) score += treeWeights[8];
                    
                    // Problem solving -> Cognitive style (mobility/complexity)
                    if (features.problem_solving === 'Analyze carefully before acting' && champion.control >= 7) score += treeWeights[9];
                    if (features.problem_solving === 'Jump in and adapt on the fly' && champion.mobility >= 7) score += treeWeights[9];
                    if (features.problem_solving === 'Follow the team\'s lead' && champion.utility >= 6) score += treeWeights[9];
                    if (features.problem_solving === 'Focus on long-term improvement' && champion.toughness >= 7) score += treeWeights[9];
                    
                    // Add randomness to prevent same results
                    score += Math.random() * 15;
                    
                    candidates.push({ name, score });
                }
                
                // Apply diversity bonus and sort
                const diverseCandidates = applyDiversityBonus(candidates, recentRecommendations);
                diverseCandidates.sort((a, b) => b.score - a.score);
                const topCandidates = diverseCandidates.slice(0, Math.min(12, diverseCandidates.length));
                const randomIndex = Math.floor(Math.random() * topCandidates.length);
                
                return topCandidates[randomIndex].name;
            }
            
            /**
             * Score all champions for unified recommendations
             * This method evaluates every champion in the database against user preferences
             * and returns a comprehensive score object for aggregation with other algorithms.
             * 
             * TASK 14.2: Optimized to reduce unnecessary iterations using pre-computed champion data
             * 
             * @param {Object} features - User preference features extracted from questionnaire
             * @param {string} features.role - Preferred champion role (e.g., 'Mage', 'Fighter')
             * @param {string} features.position - Preferred lane position (e.g., 'Mid', 'Top')
             * @param {number} features.difficulty - Preferred difficulty level (1-10)
             * @param {number} features.damage - Preferred damage output (1-10)
             * @param {number} features.toughness - Preferred durability/tankiness (1-10)
             * @param {string} features.playstyle - Preferred playstyle (e.g., 'High Damage Output')
             * @param {string} features.pressure_response - How user responds under pressure
             * @param {string} features.aesthetic_preference - Visual/thematic preference
             * @param {string} features.team_contribution - Preferred team role
             * @param {string} features.problem_solving - Problem-solving approach
             * @returns {Object} Scores object with champion names as keys, score objects as values
             *                   Each score object contains: {score, rawScore, details}
             */
            predictAll(features) {
                const scores = {};
                
                // TASK 14.2: Initialize champion data if not already done
                this.initializeChampionData();
                
                // TASK 14.2: Use pre-computed entries and traditional for loop for better performance
                for (let i = 0; i < this.championCount; i++) {
                    const [name, champion] = this.championEntries[i];
                    const result = this.calculateChampionScore(features, champion);
                    scores[name] = result;
                }
                
                return scores;
            }
            
            /**
             * Calculate detailed score for a single champion using Random Forest logic
             * 
             * This method implements a weighted scoring system that evaluates how well a champion
             * matches user preferences across multiple dimensions:
             * 
             * Scoring Breakdown (Total: 170 points, normalized to 0-100):
             * - Role Match: 40 points (exact role match or "No Preference")
             * - Position Match: 30 points (lane compatibility)
             * - Difficulty Match: 20 points (skill level alignment, decreases with distance)
             * - Damage Match: 15 points (damage output preference, decreases with distance)
             * - Toughness Match: 15 points (survivability preference, decreases with distance)
             * - Playstyle Bonus: 20 points (aggressive/defensive/supportive/balanced)
             * - Psychological Match: 30 points (behavioral and aesthetic preferences)
             * 
             * The method also tracks:
             * - Contributing factors: What added to the score and by how much
             * - Matched criteria: Which preferences aligned with champion attributes
             * - Penalties: What didn't match (for transparency)
             * 
             * @param {Object} features - User preference features
             * @param {Object} champion - Champion data object from allChampions
             * @returns {Object} Score result with structure:
             *   {
             *     score: number (0-100, normalized),
             *     rawScore: number (0-170, before normalization),
             *     details: {
             *       contributingFactors: Array<{factor, weight, contribution}>,
             *       matchedCriteria: Array<string>,
             *       penalties: Array<string>
             *     }
             *   }
             */
            calculateChampionScore(features, champion) {
                let score = 0;
                const details = {
                    contributingFactors: [],
                    matchedCriteria: [],
                    penalties: []
                };
                
                // 1. Role Match (40 points max)
                if (features.role === 'No Preference' || features.role === champion.role) {
                    score += 40;
                    details.contributingFactors.push({
                        factor: 'Role Match',
                        weight: 40,
                        contribution: 40
                    });
                    details.matchedCriteria.push(`Role: ${champion.role}`);
                } else {
                    details.penalties.push(`Role mismatch: wanted ${features.role}, got ${champion.role}`);
                }
                
                // 2. Position Match (30 points max)
                const championPositions = champion.positions || [];
                if (features.position === 'No Preference' || 
                    (championPositions.length > 0 && championPositions.includes(features.position))) {
                    score += 30;
                    details.contributingFactors.push({
                        factor: 'Position Match',
                        weight: 30,
                        contribution: 30
                    });
                    details.matchedCriteria.push(`Position: ${features.position || 'Any'}`);
                } else if (features.position !== 'No Preference') {
                    details.penalties.push(`Position mismatch: wanted ${features.position}`);
                }
                
                // 3. Difficulty Match (20 points max)
                const diffDelta = Math.abs(features.difficulty - champion.difficulty);
                const diffScore = Math.max(0, 20 - (diffDelta * 2));
                score += diffScore;
                details.contributingFactors.push({
                    factor: 'Difficulty Match',
                    weight: 20,
                    contribution: diffScore
                });
                if (diffScore >= 15) {
                    details.matchedCriteria.push(`Difficulty close to preference (${champion.difficulty})`);
                }
                
                // 4. Damage Match (15 points max)
                const damageDelta = Math.abs(features.damage - champion.damage);
                const damageScore = Math.max(0, 15 - (damageDelta * 1.5));
                score += damageScore;
                details.contributingFactors.push({
                    factor: 'Damage Match',
                    weight: 15,
                    contribution: damageScore
                });
                
                // 5. Toughness Match (15 points max)
                const toughnessDelta = Math.abs(features.toughness - champion.toughness);
                const toughnessScore = Math.max(0, 15 - (toughnessDelta * 1.5));
                score += toughnessScore;
                details.contributingFactors.push({
                    factor: 'Toughness Match',
                    weight: 15,
                    contribution: toughnessScore
                });
                
                // 6. Playstyle Bonuses (20 points max)
                let playstyleScore = 0;
                if (features.playstyle === 'High Damage Output' && champion.damage >= 8) {
                    playstyleScore += 20;
                    details.matchedCriteria.push('High damage for aggressive playstyle');
                } else if (features.playstyle === 'Tanky and Durable' && champion.toughness >= 7) {
                    playstyleScore += 20;
                    details.matchedCriteria.push('High toughness for defensive playstyle');
                } else if (features.playstyle === 'Support Team' && champion.utility >= 7) {
                    playstyleScore += 20;
                    details.matchedCriteria.push('High utility for supportive playstyle');
                } else if (features.playstyle === 'Balanced/Hybrid') {
                    playstyleScore += 10;
                    details.matchedCriteria.push('Balanced champion for hybrid playstyle');
                }
                score += playstyleScore;
                details.contributingFactors.push({
                    factor: 'Playstyle Bonus',
                    weight: 20,
                    contribution: playstyleScore
                });
                
                // 7. Psychological Preferences (30 points max)
                let psychScore = 0;
                
                // Pressure response
                if (features.pressure_response === 'Stay calm and strategic' && champion.toughness >= 6) {
                    psychScore += 10;
                    details.matchedCriteria.push('Calm playstyle matches champion toughness');
                } else if (features.pressure_response === 'Take charge and lead' && (champion.damage >= 7 || champion.control >= 7)) {
                    psychScore += 10;
                    details.matchedCriteria.push('Leadership style matches champion control/damage');
                } else if (features.pressure_response === 'Get aggressive and take risks' && champion.damage >= 8) {
                    psychScore += 10;
                    details.matchedCriteria.push('Aggressive style matches high damage');
                } else if (features.pressure_response === 'Play cautiously to avoid mistakes' && champion.toughness >= 7) {
                    psychScore += 10;
                    details.matchedCriteria.push('Cautious style matches champion durability');
                }
                
                // Aesthetic preference
                if (features.aesthetic_preference === 'Heroic' && champion.title && champion.title.includes('the')) {
                    psychScore += 7;
                    details.matchedCriteria.push('Heroic aesthetic match');
                } else if (features.aesthetic_preference === 'Mysterious' && (champion.role === 'Assassin' || champion.role === 'Mage')) {
                    psychScore += 7;
                    details.matchedCriteria.push('Mysterious aesthetic match');
                } else if (features.aesthetic_preference === 'Dark and edgy' && champion.role === 'Assassin') {
                    psychScore += 7;
                    details.matchedCriteria.push('Dark aesthetic match');
                } else if (features.aesthetic_preference === 'Cute or playful' && champion.role === 'Support') {
                    psychScore += 7;
                    details.matchedCriteria.push('Playful aesthetic match');
                } else if (features.aesthetic_preference === 'Monstrous or non-human' && (champion.role === 'Fighter' || champion.role === 'Tank')) {
                    psychScore += 7;
                    details.matchedCriteria.push('Monstrous aesthetic match');
                }
                
                // Team contribution
                if (features.team_contribution === 'Lead and make decisions' && champion.control >= 7) {
                    psychScore += 7;
                    details.matchedCriteria.push('Leadership matches champion control');
                } else if (features.team_contribution === 'Support and enable others' && champion.utility >= 7) {
                    psychScore += 7;
                    details.matchedCriteria.push('Support style matches champion utility');
                } else if (features.team_contribution === 'Balance between both' && (champion.utility >= 5 && champion.control >= 5)) {
                    psychScore += 7;
                    details.matchedCriteria.push('Balanced contribution matches champion');
                } else if (features.team_contribution === 'Stay independent and focus on my role' && champion.damage >= 7) {
                    psychScore += 7;
                    details.matchedCriteria.push('Independent style matches champion damage');
                }
                
                // Problem solving
                if (features.problem_solving === 'Analyze carefully before acting' && champion.control >= 7) {
                    psychScore += 6;
                    details.matchedCriteria.push('Analytical style matches champion control');
                } else if (features.problem_solving === 'Jump in and adapt on the fly' && champion.mobility >= 7) {
                    psychScore += 6;
                    details.matchedCriteria.push('Adaptive style matches champion mobility');
                } else if (features.problem_solving === "Follow the team's lead" && champion.utility >= 6) {
                    psychScore += 6;
                    details.matchedCriteria.push('Team-oriented style matches champion utility');
                } else if (features.problem_solving === 'Focus on long-term improvement' && champion.toughness >= 7) {
                    psychScore += 6;
                    details.matchedCriteria.push('Long-term focus matches champion durability');
                }
                
                score += psychScore;
                details.contributingFactors.push({
                    factor: 'Psychological Match',
                    weight: 30,
                    contribution: psychScore
                });
                
                // Total possible: 40+30+20+15+15+20+30 = 170 points
                const rawScore = score;
                const normalizedScore = this.normalizeScore(rawScore);
                
                return {
                    score: normalizedScore,
                    rawScore: rawScore,
                    details: details
                };
            }
            
            /**
             * Normalize raw score to 0-100 range
             * 
             * Converts the raw scoring points (0-170) to a standardized percentage (0-100)
             * for easy comparison across different algorithms and champions.
             * 
             * Formula: ((rawScore - minScore) / (maxScore - minScore)) * 100
             * 
             * @param {number} rawScore - Raw score from calculateChampionScore (0-170)
             * @returns {number} Normalized score between 0 and 100
             */
            normalizeScore(rawScore) {
                // Max possible score is 170 (40+30+20+15+15+20+30)
                const maxScore = 170;
                const minScore = 0;
                
                // Normalize to 0-100 range
                const normalized = ((rawScore - minScore) / (maxScore - minScore)) * 100;
                
                // Ensure bounds (handle edge cases)
                return Math.max(0, Math.min(100, normalized));
            }
        }

        class SimpleDecisionTree {
            // TASK 14.2: Pre-compute champion entries for better performance
            constructor() {
                this.championEntries = null;
                this.championCount = 0;
            }
            
            // TASK 14.2: Initialize champion data once
            initializeChampionData() {
                if (!this.championEntries) {
                    this.championEntries = Object.entries(allChampions);
                    this.championCount = this.championEntries.length;
                }
            }
            
            predict(features) {
                const candidates = [];
                
                // TASK 14.2: Initialize champion data if not already done
                this.initializeChampionData();
                
                // TASK 14.2: Use pre-computed entries and traditional for loop
                for (let i = 0; i < this.championCount; i++) {
                    const [name, champion] = this.championEntries[i];
                    let score = 0;
                    
                    // Enhanced decision tree logic with role, position, and psychological preferences
                    
                    // Role matching (highest priority)
                    if (features.role === 'No Preference' || features.role === champion.role) {
                        score += 50;
                        
                        // Position matching (second priority)
                        const championPositions = champion.positions || [];
                        if (features.position === 'No Preference' || 
                            (championPositions.length > 0 && championPositions.includes(features.position))) {
                            score += 40;
                            
                            // Difficulty matching
                            if (Math.abs(features.difficulty - champion.difficulty) <= 2) {
                                score += 30;
                                
                                // Damage preference
                                if (Math.abs(features.damage - champion.damage) <= 2) {
                                    score += 20;
                                }
                                
                                // Toughness preference
                                if (Math.abs(features.toughness - champion.toughness) <= 2) {
                                    score += 15;
                                }
                            }
                        }
                    } else {
                        // Heavy penalty for wrong role
                        score -= 30;
                    }
                    
                    // Position penalty if specified but doesn't match
                    const championPositions = champion.positions || [];
                    if (features.position !== 'No Preference' && 
                        championPositions.length > 0 && !championPositions.includes(features.position)) {
                        score -= 20;
                    }
                    
                    // Psychological preferences mapping to champion attributes
                    // Pressure response -> Emotional stability (toughness/mobility)
                    if (features.pressure_response === 'Stay calm and strategic' && champion.toughness >= 6) score += 25;
                    if (features.pressure_response === 'Take charge and lead' && (champion.damage >= 7 || champion.control >= 7)) score += 25;
                    if (features.pressure_response === 'Get aggressive and take risks' && champion.damage >= 8) score += 25;
                    if (features.pressure_response === 'Play cautiously to avoid mistakes' && champion.toughness >= 7) score += 25;
                    
                    // Aesthetic preference -> Champion theme/identity
                    if (features.aesthetic_preference === 'Heroic' && (champion.title && champion.title.includes('the'))) score += 20;
                    if (features.aesthetic_preference === 'Mysterious' && (champion.role === 'Assassin' || champion.role === 'Mage')) score += 20;
                    if (features.aesthetic_preference === 'Dark and edgy' && (champion.role === 'Assassin' || champion.title && champion.title.includes('dark'))) score += 20;
                    if (features.aesthetic_preference === 'Cute or playful' && champion.role === 'Support') score += 20;
                    if (features.aesthetic_preference === 'Monstrous or non-human' && (champion.role === 'Fighter' || champion.role === 'Tank')) score += 20;
                    
                    // Team contribution -> Utility/control attributes
                    if (features.team_contribution === 'Lead and make decisions' && champion.control >= 7) score += 25;
                    if (features.team_contribution === 'Support and enable others' && champion.utility >= 7) score += 25;
                    if (features.team_contribution === 'Balance between both' && (champion.utility >= 5 && champion.control >= 5)) score += 25;
                    if (features.team_contribution === 'Stay independent and focus on my role' && champion.damage >= 7) score += 25;
                    
                    // Problem solving -> Cognitive style (mobility/complexity)
                    if (features.problem_solving === 'Analyze carefully before acting' && champion.control >= 7) score += 20;
                    if (features.problem_solving === 'Jump in and adapt on the fly' && champion.mobility >= 7) score += 20;
                    if (features.problem_solving === 'Follow the team\'s lead' && champion.utility >= 6) score += 20;
                    if (features.problem_solving === 'Focus on long-term improvement' && champion.toughness >= 7) score += 20;
                    
                    // Add small exploration bonus for variety
                    score += Math.random() * 15;
                    
                    candidates.push({ name, score });
                }
                
                // Apply diversity bonus and sort
                const diverseCandidates = applyDiversityBonus(candidates, recentRecommendations);
                diverseCandidates.sort((a, b) => b.score - a.score);
                const topCandidates = diverseCandidates.slice(0, Math.min(10, diverseCandidates.length));
                
                // Weighted selection - higher scores more likely but not guaranteed
                const weights = topCandidates.map((_, i) => Math.pow(0.7, i));
                const totalWeight = weights.reduce((sum, w) => sum + w, 0);
                let random = Math.random() * totalWeight;
                
                for (let i = 0; i < topCandidates.length; i++) {
                    random -= weights[i];
                    if (random <= 0) {
                        return {
                            champion: topCandidates[i].name,
                            confidence: Math.min(95, Math.max(65, topCandidates[i].score * 0.8)),
                            algorithm: 'Decision Tree'
                        };
                    }
                }
                
                // Fallback
                return {
                    champion: topCandidates[0].name,
                    confidence: Math.min(95, Math.max(65, topCandidates[0].score * 0.8)),
                    algorithm: 'Decision Tree'
                };
            }
            
            /**
             * Score all champions for unified recommendations using Decision Tree logic
             * 
             * TASK 14.2: Optimized to reduce unnecessary iterations using pre-computed champion data
             * 
             * @param {Object} features - User preference features extracted from questionnaire
             * @returns {Object} Scores object with champion names as keys, score objects as values
             */
            predictAll(features) {
                const scores = {};
                
                // TASK 14.2: Initialize champion data if not already done
                this.initializeChampionData();
                
                // TASK 14.2: Use pre-computed entries and traditional for loop for better performance
                for (let i = 0; i < this.championCount; i++) {
                    const [name, champion] = this.championEntries[i];
                    const result = this.calculateChampionScore(features, champion);
                    scores[name] = result;
                }
                
                return scores;
            }
            
            /**
             * Calculate detailed score for a single champion using hierarchical Decision Tree logic
             * 
             * This method implements a hierarchical scoring system where each level depends on
             * the previous level matching. This creates a decision tree structure where:
             * 
             * Scoring Breakdown (Hierarchical, total up to 210 points):
             * - Level 1: Role Match (50 points) - Must match to proceed
             * - Level 2: Position Match (40 points) - Only if role matches
             * - Level 3: Difficulty Match (30 points) - Only if position matches
             * - Level 4: Attribute Matches (20 points each) - Only if difficulty matches
             *   - Damage match: 20 points
             *   - Toughness match: 20 points
             * - Psychological Bonuses (25 points each, independent):
             *   - Pressure response: 25 points
             *   - Aesthetic preference: 20 points
             *   - Team contribution: 25 points
             *   - Problem solving: 20 points
             * - Penalties: Applied for mismatches (-30 for role, -20 for position)
             * 
             * The hierarchical nature means a champion must match higher-level criteria
             * to earn points from lower-level criteria, creating a more strict evaluation.
             * 
             * @param {Object} features - User preference features
             * @param {Object} champion - Champion data object from allChampions
             * @returns {Object} Score result with structure:
             *   {
             *     score: number (0-100, normalized),
             *     rawScore: number (can be negative due to penalties),
             *     details: {
             *       contributingFactors: Array<{factor, weight, contribution}>,
             *       matchedCriteria: Array<string>,
             *       penalties: Array<string>
             *     }
             *   }
             */
            calculateChampionScore(features, champion) {
                let score = 0;
                const details = {
                    contributingFactors: [],
                    matchedCriteria: [],
                    penalties: []
                };
                
                // Level 1: Role match (50 points)
                if (features.role === 'No Preference' || features.role === champion.role) {
                    score += 50;
                    details.contributingFactors.push({
                        factor: 'Role Match (Level 1)',
                        weight: 50,
                        contribution: 50
                    });
                    details.matchedCriteria.push(`Role: ${champion.role}`);
                    
                    // Level 2: Position match (40 points, only if role matches)
                    const championPositions = champion.positions || [];
                    if (features.position === 'No Preference' || 
                        (championPositions.length > 0 && championPositions.includes(features.position))) {
                        score += 40;
                        details.contributingFactors.push({
                            factor: 'Position Match (Level 2)',
                            weight: 40,
                            contribution: 40
                        });
                        details.matchedCriteria.push(`Position: ${features.position || 'Any'}`);
                        
                        // Level 3: Difficulty match (30 points, only if position matches)
                        if (Math.abs(features.difficulty - champion.difficulty) <= 2) {
                            score += 30;
                            details.contributingFactors.push({
                                factor: 'Difficulty Match (Level 3)',
                                weight: 30,
                                contribution: 30
                            });
                            details.matchedCriteria.push(`Difficulty within range (${champion.difficulty})`);
                            
                            // Level 4: Attribute matches (20 points each)
                            if (Math.abs(features.damage - champion.damage) <= 2) {
                                score += 20;
                                details.contributingFactors.push({
                                    factor: 'Damage Match (Level 4)',
                                    weight: 20,
                                    contribution: 20
                                });
                                details.matchedCriteria.push(`Damage matches (${champion.damage})`);
                            }
                            
                            if (Math.abs(features.toughness - champion.toughness) <= 2) {
                                score += 20;
                                details.contributingFactors.push({
                                    factor: 'Toughness Match (Level 4)',
                                    weight: 20,
                                    contribution: 20
                                });
                                details.matchedCriteria.push(`Toughness matches (${champion.toughness})`);
                            }
                        } else {
                            details.penalties.push(`Difficulty mismatch: wanted ${features.difficulty}, got ${champion.difficulty}`);
                        }
                    } else if (features.position !== 'No Preference') {
                        details.penalties.push(`Position mismatch: wanted ${features.position}`);
                    }
                } else {
                    // Heavy penalty for wrong role
                    score -= 30;
                    details.contributingFactors.push({
                        factor: 'Role Mismatch Penalty',
                        weight: -30,
                        contribution: -30
                    });
                    details.penalties.push(`Role mismatch: wanted ${features.role}, got ${champion.role}`);
                }
                
                // Position penalty if specified but doesn't match (and not already counted)
                const championPositions = champion.positions || [];
                if (features.position !== 'No Preference' && 
                    championPositions.length > 0 && !championPositions.includes(features.position) &&
                    (features.role !== 'No Preference' && features.role !== champion.role)) {
                    score -= 20;
                    details.contributingFactors.push({
                        factor: 'Position Mismatch Penalty',
                        weight: -20,
                        contribution: -20
                    });
                }
                
                // Psychological bonuses (25 points each)
                let psychScore = 0;
                
                // Pressure response -> Emotional stability (toughness/mobility)
                if (features.pressure_response === 'Stay calm and strategic' && champion.toughness >= 6) {
                    psychScore += 25;
                    details.matchedCriteria.push('Calm playstyle matches champion toughness');
                } else if (features.pressure_response === 'Take charge and lead' && (champion.damage >= 7 || champion.control >= 7)) {
                    psychScore += 25;
                    details.matchedCriteria.push('Leadership style matches champion control/damage');
                } else if (features.pressure_response === 'Get aggressive and take risks' && champion.damage >= 8) {
                    psychScore += 25;
                    details.matchedCriteria.push('Aggressive style matches high damage');
                } else if (features.pressure_response === 'Play cautiously to avoid mistakes' && champion.toughness >= 7) {
                    psychScore += 25;
                    details.matchedCriteria.push('Cautious style matches champion durability');
                }
                
                // Aesthetic preference -> Champion theme/identity
                if (features.aesthetic_preference === 'Heroic' && champion.title && champion.title.includes('the')) {
                    psychScore += 20;
                    details.matchedCriteria.push('Heroic aesthetic match');
                } else if (features.aesthetic_preference === 'Mysterious' && (champion.role === 'Assassin' || champion.role === 'Mage')) {
                    psychScore += 20;
                    details.matchedCriteria.push('Mysterious aesthetic match');
                } else if (features.aesthetic_preference === 'Dark and edgy' && (champion.role === 'Assassin' || (champion.title && champion.title.includes('dark')))) {
                    psychScore += 20;
                    details.matchedCriteria.push('Dark aesthetic match');
                } else if (features.aesthetic_preference === 'Cute or playful' && champion.role === 'Support') {
                    psychScore += 20;
                    details.matchedCriteria.push('Playful aesthetic match');
                } else if (features.aesthetic_preference === 'Monstrous or non-human' && (champion.role === 'Fighter' || champion.role === 'Tank')) {
                    psychScore += 20;
                    details.matchedCriteria.push('Monstrous aesthetic match');
                }
                
                // Team contribution -> Utility/control attributes
                if (features.team_contribution === 'Lead and make decisions' && champion.control >= 7) {
                    psychScore += 25;
                    details.matchedCriteria.push('Leadership matches champion control');
                } else if (features.team_contribution === 'Support and enable others' && champion.utility >= 7) {
                    psychScore += 25;
                    details.matchedCriteria.push('Support style matches champion utility');
                } else if (features.team_contribution === 'Balance between both' && (champion.utility >= 5 && champion.control >= 5)) {
                    psychScore += 25;
                    details.matchedCriteria.push('Balanced contribution matches champion');
                } else if (features.team_contribution === 'Stay independent and focus on my role' && champion.damage >= 7) {
                    psychScore += 25;
                    details.matchedCriteria.push('Independent style matches champion damage');
                }
                
                // Problem solving -> Cognitive style (mobility/complexity)
                if (features.problem_solving === 'Analyze carefully before acting' && champion.control >= 7) {
                    psychScore += 20;
                    details.matchedCriteria.push('Analytical style matches champion control');
                } else if (features.problem_solving === 'Jump in and adapt on the fly' && champion.mobility >= 7) {
                    psychScore += 20;
                    details.matchedCriteria.push('Adaptive style matches champion mobility');
                } else if (features.problem_solving === "Follow the team's lead" && champion.utility >= 6) {
                    psychScore += 20;
                    details.matchedCriteria.push('Team-oriented style matches champion utility');
                } else if (features.problem_solving === 'Focus on long-term improvement' && champion.toughness >= 7) {
                    psychScore += 20;
                    details.matchedCriteria.push('Long-term focus matches champion durability');
                }
                
                score += psychScore;
                details.contributingFactors.push({
                    factor: 'Psychological Bonuses',
                    weight: 110,
                    contribution: psychScore
                });
                
                // Total possible: 50+40+30+20+20+25+20+25+20 = 250 points (with penalties possible: -30-20 = -50)
                const rawScore = score;
                const normalizedScore = this.normalizeScore(rawScore);
                
                return {
                    score: normalizedScore,
                    rawScore: rawScore,
                    details: details
                };
            }
            
            /**
             * Normalize raw score to 0-100 range, accounting for negative penalties
             * 
             * Decision Tree scoring can result in negative scores due to penalties,
             * so this normalization accounts for both positive and negative ranges.
             * 
             * Formula: ((rawScore - minScore) / (maxScore - minScore)) * 100
             * 
             * @param {number} rawScore - Raw score from calculateChampionScore (-50 to 250)
             * @returns {number} Normalized score between 0 and 100
             */
            normalizeScore(rawScore) {
                // Max possible score is 250 (50+40+30+20+20+110)
                // Min possible score is -50 (penalties: -30-20)
                const maxScore = 250;
                const minScore = -50;
                
                // Normalize to 0-100 range
                const normalized = ((rawScore - minScore) / (maxScore - minScore)) * 100;
                
                // Ensure bounds (handle edge cases)
                return Math.max(0, Math.min(100, normalized));
            }
        }

        class SimpleKNN {
            // TASK 14.2: Pre-compute champion entries for better performance
            constructor() {
                this.championEntries = null;
                this.championCount = 0;
            }
            
            // TASK 14.2: Initialize champion data once
            initializeChampionData() {
                if (!this.championEntries) {
                    this.championEntries = Object.entries(allChampions);
                    this.championCount = this.championEntries.length;
                }
            }
            
            predict(features) {
                const distances = [];
                
                // TASK 14.2: Initialize champion data if not already done
                this.initializeChampionData();
                
                // TASK 14.2: Use pre-computed entries and traditional for loop
                for (let i = 0; i < this.championCount; i++) {
                    const [name, champion] = this.championEntries[i];
                    let distance = 0;
                    
                    // Role distance (highest weight)
                    if (features.role !== 'No Preference' && features.role !== champion.role) {
                        distance += 8; // Increased penalty for wrong role
                    }
                    
                    // Position distance (second highest weight)
                    const championPositions = champion.positions || [];
                    if (features.position !== 'No Preference' && 
                        championPositions.length > 0 && !championPositions.includes(features.position)) {
                        distance += 6; // High penalty for wrong position
                    }
                    
                    // Numerical distances
                    distance += Math.abs(features.difficulty - champion.difficulty) * 0.5;
                    distance += Math.abs(features.damage - champion.damage) * 0.3;
                    distance += Math.abs(features.toughness - champion.toughness) * 0.3;
                    
                    // Psychological preferences mapping to champion attributes
                    // Pressure response -> Emotional stability (toughness/mobility)
                    if (features.pressure_response === 'Stay calm and strategic' && champion.toughness < 6) distance += 2;
                    if (features.pressure_response === 'Take charge and lead' && (champion.damage < 7 && champion.control < 7)) distance += 2;
                    if (features.pressure_response === 'Get aggressive and take risks' && champion.damage < 8) distance += 2;
                    if (features.pressure_response === 'Play cautiously to avoid mistakes' && champion.toughness < 7) distance += 2;
                    
                    // Aesthetic preference -> Champion theme/identity
                    if (features.aesthetic_preference === 'Heroic' && !(champion.title && champion.title.includes('the'))) distance += 1.5;
                    if (features.aesthetic_preference === 'Mysterious' && !(champion.role === 'Assassin' || champion.role === 'Mage')) distance += 1.5;
                    if (features.aesthetic_preference === 'Dark and edgy' && !(champion.role === 'Assassin' || champion.title && champion.title.includes('dark'))) distance += 1.5;
                    if (features.aesthetic_preference === 'Cute or playful' && champion.role !== 'Support') distance += 1.5;
                    if (features.aesthetic_preference === 'Monstrous or non-human' && !(champion.role === 'Fighter' || champion.role === 'Tank')) distance += 1.5;
                    
                    // Team contribution -> Utility/control attributes
                    if (features.team_contribution === 'Lead and make decisions' && champion.control < 7) distance += 2;
                    if (features.team_contribution === 'Support and enable others' && champion.utility < 7) distance += 2;
                    if (features.team_contribution === 'Balance between both' && (champion.utility < 5 || champion.control < 5)) distance += 2;
                    if (features.team_contribution === 'Stay independent and focus on my role' && champion.damage < 7) distance += 2;
                    
                    // Problem solving -> Cognitive style (mobility/complexity)
                    if (features.problem_solving === 'Analyze carefully before acting' && champion.control < 7) distance += 1.5;
                    if (features.problem_solving === 'Jump in and adapt on the fly' && champion.mobility < 7) distance += 1.5;
                    if (features.problem_solving === 'Follow the team\'s lead' && champion.utility < 6) distance += 1.5;
                    if (features.problem_solving === 'Focus on long-term improvement' && champion.toughness < 7) distance += 1.5;
                    
                    // Add small random noise for diversity
                    distance += Math.random() * 0.8;
                    
                    distances.push({ champion: name, distance: distance });
                }
                
                // Get more neighbors for variety (5-8 instead of 3)
                distances.sort((a, b) => a.distance - b.distance);
                const k = 5 + Math.floor(Math.random() * 4); // Random k between 5-8
                const neighbors = distances.slice(0, k);
                
                // Weighted vote with randomness
                let totalWeight = 0;
                const votes = {};
                
                neighbors.forEach(neighbor => {
                    const weight = neighbor.distance === 0 ? 1 : 1 / (neighbor.distance + 0.1);
                    // Add randomness to voting
                    const randomizedWeight = weight * (0.7 + Math.random() * 0.6);
                    votes[neighbor.champion] = (votes[neighbor.champion] || 0) + randomizedWeight;
                    totalWeight += randomizedWeight;
                });
                
                // Convert to array and add exploration
                const candidates = Object.entries(votes).map(([champion, score]) => ({
                    champion,
                    score: score + Math.random() * (totalWeight * 0.2)
                }));
                
                candidates.sort((a, b) => b.score - a.score);
                
                // Apply diversity bonus
                const diverseCandidates = applyDiversityBonus(candidates, recentRecommendations);
                diverseCandidates.sort((a, b) => b.score - a.score);
                
                if (diverseCandidates.length > 0) {
                    // Select from top candidates with weighted probability
                    const topCandidates = diverseCandidates.slice(0, Math.min(5, diverseCandidates.length));
                    const weights = topCandidates.map((_, i) => Math.pow(0.8, i));
                    const totalWeight = weights.reduce((sum, w) => sum + w, 0);
                    let random = Math.random() * totalWeight;
                    
                    for (let i = 0; i < topCandidates.length; i++) {
                        random -= weights[i];
                        if (random <= 0) {
                            return {
                                champion: topCandidates[i].champion,
                                confidence: Math.min(95, Math.max(75, (topCandidates[i].score / totalWeight) * 100)),
                                algorithm: 'K-Nearest Neighbors'
                            };
                        }
                    }
                    
                    // Fallback
                    return {
                        champion: topCandidates[0].champion,
                        confidence: Math.min(95, Math.max(75, (topCandidates[0].score / totalWeight) * 100)),
                        algorithm: 'K-Nearest Neighbors'
                    };
                }
                
                // Ultimate fallback
                return {
                    champion: diverseCandidates[0].champion,
                    confidence: 80,
                    algorithm: 'K-Nearest Neighbors'
                };
            }
            
            /**
             * Score all champions for unified recommendations using K-Nearest Neighbors logic
             * 
             * TASK 14.2: Optimized to reduce unnecessary iterations using pre-computed champion data
             * 
             * @param {Object} features - User preference features extracted from questionnaire
             * @returns {Object} Scores object with champion names as keys, score objects as values
             */
            predictAll(features) {
                const scores = {};
                
                // TASK 14.2: Initialize champion data if not already done
                this.initializeChampionData();
                
                // TASK 14.2: Use pre-computed entries and traditional for loop for better performance
                for (let i = 0; i < this.championCount; i++) {
                    const [name, champion] = this.championEntries[i];
                    const result = this.calculateChampionScore(features, champion);
                    scores[name] = result;
                }
                
                return scores;
            }
            
            /**
             * Calculate detailed score for a single champion using distance-based KNN logic
             * 
             * K-Nearest Neighbors uses distance calculation where LOWER distance means BETTER match.
             * The final score is converted to 0-100 where higher is better (inverse of distance).
             * 
             * Distance Calculation (penalties added for mismatches):
             * - Role Mismatch: +8 distance (highest penalty)
             * - Position Mismatch: +6 distance (high penalty)
             * - Difficulty Distance: |user - champion| * 0.5
             * - Damage Distance: |user - champion| * 0.3
             * - Toughness Distance: |user - champion| * 0.3
             * - Psychological Mismatches: +2 distance each
             *   - Pressure response mismatch
             *   - Team contribution mismatch
             * - Aesthetic Mismatches: +1.5 distance each
             *   - Aesthetic preference mismatch
             *   - Problem solving mismatch
             * 
             * Maximum possible distance: ~30 (all mismatches)
             * Minimum possible distance: 0 (perfect match)
             * 
             * Score Conversion: score = max(0, 100 - (distance * 3.33))
             * This converts distance to a 0-100 score where:
             * - Distance 0 = Score 100
             * - Distance 30 = Score 0
             * 
             * @param {Object} features - User preference features
             * @param {Object} champion - Champion data object from allChampions
             * @returns {Object} Score result with structure:
             *   {
             *     score: number (0-100, inverse of distance),
             *     rawScore: number (distance value, lower is better),
             *     details: {
             *       contributingFactors: Array<{factor, weight, contribution}>,
             *       matchedCriteria: Array<string>,
             *       penalties: Array<string>
             *     }
             *   }
             */
            calculateChampionScore(features, champion) {
                let distance = 0;
                const details = {
                    contributingFactors: [],
                    matchedCriteria: [],
                    penalties: []
                };
                
                // 1. Role distance (8 points penalty if mismatch)
                if (features.role !== 'No Preference' && features.role !== champion.role) {
                    distance += 8;
                    details.penalties.push(`Role mismatch: wanted ${features.role}, got ${champion.role}`);
                    details.contributingFactors.push({
                        factor: 'Role Distance',
                        weight: 8,
                        contribution: 8
                    });
                } else {
                    details.matchedCriteria.push(`Role: ${champion.role}`);
                    details.contributingFactors.push({
                        factor: 'Role Distance',
                        weight: 8,
                        contribution: 0
                    });
                }
                
                // 2. Position distance (6 points penalty if mismatch)
                const championPositions = champion.positions || [];
                if (features.position !== 'No Preference' && 
                    championPositions.length > 0 && !championPositions.includes(features.position)) {
                    distance += 6;
                    details.penalties.push(`Position mismatch: wanted ${features.position}`);
                    details.contributingFactors.push({
                        factor: 'Position Distance',
                        weight: 6,
                        contribution: 6
                    });
                } else if (features.position !== 'No Preference') {
                    details.matchedCriteria.push(`Position: ${features.position}`);
                    details.contributingFactors.push({
                        factor: 'Position Distance',
                        weight: 6,
                        contribution: 0
                    });
                }
                
                // 3. Numerical attribute distances (weighted)
                const diffDist = Math.abs(features.difficulty - champion.difficulty) * 0.5;
                const damageDist = Math.abs(features.damage - champion.damage) * 0.3;
                const toughnessDist = Math.abs(features.toughness - champion.toughness) * 0.3;
                
                distance += diffDist + damageDist + toughnessDist;
                
                details.contributingFactors.push(
                    { factor: 'Difficulty Distance', weight: 0.5, contribution: diffDist },
                    { factor: 'Damage Distance', weight: 0.3, contribution: damageDist },
                    { factor: 'Toughness Distance', weight: 0.3, contribution: toughnessDist }
                );
                
                if (diffDist <= 1) {
                    details.matchedCriteria.push(`Difficulty close to preference (${champion.difficulty})`);
                }
                if (damageDist <= 1) {
                    details.matchedCriteria.push(`Damage close to preference (${champion.damage})`);
                }
                if (toughnessDist <= 1) {
                    details.matchedCriteria.push(`Toughness close to preference (${champion.toughness})`);
                }
                
                // 4. Psychological distances (2 points each for mismatch)
                let psychDistance = 0;
                
                // Pressure response -> Emotional stability (toughness/mobility)
                if (features.pressure_response === 'Stay calm and strategic' && champion.toughness < 6) {
                    psychDistance += 2;
                    details.penalties.push('Pressure response mismatch: low toughness for calm style');
                } else if (features.pressure_response === 'Stay calm and strategic' && champion.toughness >= 6) {
                    details.matchedCriteria.push('Calm playstyle matches champion toughness');
                }
                
                if (features.pressure_response === 'Take charge and lead' && (champion.damage < 7 && champion.control < 7)) {
                    psychDistance += 2;
                    details.penalties.push('Pressure response mismatch: low damage/control for leadership');
                } else if (features.pressure_response === 'Take charge and lead' && (champion.damage >= 7 || champion.control >= 7)) {
                    details.matchedCriteria.push('Leadership style matches champion control/damage');
                }
                
                if (features.pressure_response === 'Get aggressive and take risks' && champion.damage < 8) {
                    psychDistance += 2;
                    details.penalties.push('Pressure response mismatch: low damage for aggressive style');
                } else if (features.pressure_response === 'Get aggressive and take risks' && champion.damage >= 8) {
                    details.matchedCriteria.push('Aggressive style matches high damage');
                }
                
                if (features.pressure_response === 'Play cautiously to avoid mistakes' && champion.toughness < 7) {
                    psychDistance += 2;
                    details.penalties.push('Pressure response mismatch: low toughness for cautious style');
                } else if (features.pressure_response === 'Play cautiously to avoid mistakes' && champion.toughness >= 7) {
                    details.matchedCriteria.push('Cautious style matches champion durability');
                }
                
                // Aesthetic preference -> Champion theme/identity (1.5 points)
                if (features.aesthetic_preference === 'Heroic' && !(champion.title && champion.title.includes('the'))) {
                    psychDistance += 1.5;
                    details.penalties.push('Aesthetic mismatch: not heroic theme');
                } else if (features.aesthetic_preference === 'Heroic' && champion.title && champion.title.includes('the')) {
                    details.matchedCriteria.push('Heroic aesthetic match');
                }
                
                if (features.aesthetic_preference === 'Mysterious' && !(champion.role === 'Assassin' || champion.role === 'Mage')) {
                    psychDistance += 1.5;
                    details.penalties.push('Aesthetic mismatch: not mysterious theme');
                } else if (features.aesthetic_preference === 'Mysterious' && (champion.role === 'Assassin' || champion.role === 'Mage')) {
                    details.matchedCriteria.push('Mysterious aesthetic match');
                }
                
                if (features.aesthetic_preference === 'Dark and edgy' && !(champion.role === 'Assassin' || (champion.title && champion.title.includes('dark')))) {
                    psychDistance += 1.5;
                    details.penalties.push('Aesthetic mismatch: not dark theme');
                } else if (features.aesthetic_preference === 'Dark and edgy' && champion.role === 'Assassin') {
                    details.matchedCriteria.push('Dark aesthetic match');
                }
                
                if (features.aesthetic_preference === 'Cute or playful' && champion.role !== 'Support') {
                    psychDistance += 1.5;
                    details.penalties.push('Aesthetic mismatch: not playful theme');
                } else if (features.aesthetic_preference === 'Cute or playful' && champion.role === 'Support') {
                    details.matchedCriteria.push('Playful aesthetic match');
                }
                
                if (features.aesthetic_preference === 'Monstrous or non-human' && !(champion.role === 'Fighter' || champion.role === 'Tank')) {
                    psychDistance += 1.5;
                    details.penalties.push('Aesthetic mismatch: not monstrous theme');
                } else if (features.aesthetic_preference === 'Monstrous or non-human' && (champion.role === 'Fighter' || champion.role === 'Tank')) {
                    details.matchedCriteria.push('Monstrous aesthetic match');
                }
                
                // Team contribution -> Utility/control attributes (2 points)
                if (features.team_contribution === 'Lead and make decisions' && champion.control < 7) {
                    psychDistance += 2;
                    details.penalties.push('Team contribution mismatch: low control for leadership');
                } else if (features.team_contribution === 'Lead and make decisions' && champion.control >= 7) {
                    details.matchedCriteria.push('Leadership matches champion control');
                }
                
                if (features.team_contribution === 'Support and enable others' && champion.utility < 7) {
                    psychDistance += 2;
                    details.penalties.push('Team contribution mismatch: low utility for support');
                } else if (features.team_contribution === 'Support and enable others' && champion.utility >= 7) {
                    details.matchedCriteria.push('Support style matches champion utility');
                }
                
                if (features.team_contribution === 'Balance between both' && (champion.utility < 5 || champion.control < 5)) {
                    psychDistance += 2;
                    details.penalties.push('Team contribution mismatch: unbalanced utility/control');
                } else if (features.team_contribution === 'Balance between both' && (champion.utility >= 5 && champion.control >= 5)) {
                    details.matchedCriteria.push('Balanced contribution matches champion');
                }
                
                if (features.team_contribution === 'Stay independent and focus on my role' && champion.damage < 7) {
                    psychDistance += 2;
                    details.penalties.push('Team contribution mismatch: low damage for independent style');
                } else if (features.team_contribution === 'Stay independent and focus on my role' && champion.damage >= 7) {
                    details.matchedCriteria.push('Independent style matches champion damage');
                }
                
                // Problem solving -> Cognitive style (mobility/complexity) (1.5 points)
                if (features.problem_solving === 'Analyze carefully before acting' && champion.control < 7) {
                    psychDistance += 1.5;
                    details.penalties.push('Problem solving mismatch: low control for analytical style');
                } else if (features.problem_solving === 'Analyze carefully before acting' && champion.control >= 7) {
                    details.matchedCriteria.push('Analytical style matches champion control');
                }
                
                if (features.problem_solving === 'Jump in and adapt on the fly' && champion.mobility < 7) {
                    psychDistance += 1.5;
                    details.penalties.push('Problem solving mismatch: low mobility for adaptive style');
                } else if (features.problem_solving === 'Jump in and adapt on the fly' && champion.mobility >= 7) {
                    details.matchedCriteria.push('Adaptive style matches champion mobility');
                }
                
                if (features.problem_solving === "Follow the team's lead" && champion.utility < 6) {
                    psychDistance += 1.5;
                    details.penalties.push('Problem solving mismatch: low utility for team-oriented style');
                } else if (features.problem_solving === "Follow the team's lead" && champion.utility >= 6) {
                    details.matchedCriteria.push('Team-oriented style matches champion utility');
                }
                
                if (features.problem_solving === 'Focus on long-term improvement' && champion.toughness < 7) {
                    psychDistance += 1.5;
                    details.penalties.push('Problem solving mismatch: low toughness for long-term focus');
                } else if (features.problem_solving === 'Focus on long-term improvement' && champion.toughness >= 7) {
                    details.matchedCriteria.push('Long-term focus matches champion durability');
                }
                
                distance += psychDistance;
                details.contributingFactors.push({
                    factor: 'Psychological Distance',
                    weight: 'Variable',
                    contribution: psychDistance
                });
                
                // Total possible distance: ~30 points max
                // Convert distance to score (inverse relationship)
                const rawDistance = distance;
                const normalizedScore = this.normalizeScore(rawDistance);
                
                return {
                    score: normalizedScore,
                    rawScore: rawDistance,
                    details: details
                };
            }
            
            /**
             * Normalize distance to 0-100 score (inverse relationship: lower distance = higher score)
             * 
             * KNN uses distance where lower is better, so we convert to a score where higher is better.
             * This makes KNN scores comparable with Random Forest and Decision Tree scores.
             * 
             * Formula: score = max(0, 100 - ((distance / maxDistance) * 100))
             * 
             * Distance Mapping:
             * - Distance 0 ‚Üí Score 100 (perfect match)
             * - Distance 15 ‚Üí Score 50 (moderate match)
             * - Distance 30 ‚Üí Score 0 (poor match)
             * 
             * @param {number} rawDistance - Raw distance from calculateChampionScore (0-30)
             * @returns {number} Normalized score between 0 and 100 (inverse of distance)
             */
            normalizeScore(rawDistance) {
                // Max expected distance is approximately 30
                // (8 role + 6 position + 5 difficulty + 3 damage + 3 toughness + ~15 psychological)
                const maxDistance = 30;
                
                // Convert distance to score (inverse relationship)
                // Distance of 0 = 100 score, Distance of 30 = 0 score
                const normalized = Math.max(0, 100 - ((rawDistance / maxDistance) * 100));
                
                // Ensure bounds (handle edge cases)
                return Math.max(0, Math.min(100, normalized));
            }
        }

        // Score Aggregation System for Unified ML Recommendations
        class ScoreAggregator {
            /**
             * Aggregate scores from all three ML algorithms
             * @param {Object} rfScores - Random Forest scores object {championName: {score, rawScore, details}}
             * @param {Object} dtScores - Decision Tree scores object {championName: {score, rawScore, details}}
             * @param {Object} knnScores - KNN scores object {championName: {score, rawScore, details}}
             * @returns {Object} - Aggregated scores object with all champion scores
             */
            static aggregateScores(rfScores, dtScores, knnScores) {
                const aggregated = {};
                
                // Iterate through all champions
                for (const championName of Object.keys(allChampions)) {
                    // Get scores from each algorithm (default to 0 if not found)
                    const rf = rfScores[championName]?.score || 0;
                    const dt = dtScores[championName]?.score || 0;
                    const knn = knnScores[championName]?.score || 0;
                    
                    // Calculate average score
                    const average = (rf + dt + knn) / 3;
                    
                    // Calculate weighted score
                    const weighted = this.calculateWeightedScore(rf, dt, knn);
                    
                    // Store aggregated data
                    aggregated[championName] = {
                        championName: championName,
                        randomForest: rf,
                        decisionTree: dt,
                        knn: knn,
                        average: average,
                        weighted: weighted,
                        details: {
                            randomForest: rfScores[championName]?.details || null,
                            decisionTree: dtScores[championName]?.details || null,
                            knn: knnScores[championName]?.details || null
                        }
                    };
                }
                
                return aggregated;
            }
            
            /**
             * Calculate weighted score from three algorithm scores
             * @param {number} rf - Random Forest score (0-100)
             * @param {number} dt - Decision Tree score (0-100)
             * @param {number} knn - KNN score (0-100)
             * @returns {number} - Weighted score (0-100)
             */
            static calculateWeightedScore(rf, dt, knn) {
                // Apply weights: Random Forest 40%, Decision Tree 30%, KNN 30%
                const weighted = (rf * 0.4) + (dt * 0.3) + (knn * 0.3);
                
                // Ensure bounds
                return Math.max(0, Math.min(100, weighted));
            }
            
            /**
             * Select top 5 champions from aggregated scores
             * @param {Object} aggregatedScores - Aggregated scores object
             * @param {boolean} diversityFilter - Whether to apply diversity filter (default: true)
             * @returns {Array} - Array of 5 champion objects with scores
             */
            static selectTop5(aggregatedScores, diversityFilter = true) {
                // Convert object to array
                let champions = Object.values(aggregatedScores);
                
                // Sort by average score (descending)
                champions.sort((a, b) => b.average - a.average);
                
                // Apply diversity filter if enabled
                if (diversityFilter) {
                    champions = this.applyDiversityFilter(champions);
                }
                
                // Select top 5 champions
                const top5 = champions.slice(0, 5);
                
                // Ensure all are unique (should already be, but double-check)
                const uniqueChampions = [];
                const seenNames = new Set();
                
                for (const champion of top5) {
                    if (!seenNames.has(champion.championName)) {
                        uniqueChampions.push(champion);
                        seenNames.add(champion.championName);
                    }
                }
                
                // If we have less than 5 unique champions, fill from remaining
                if (uniqueChampions.length < 5) {
                    for (const champion of champions) {
                        if (!seenNames.has(champion.championName)) {
                            uniqueChampions.push(champion);
                            seenNames.add(champion.championName);
                            
                            if (uniqueChampions.length >= 5) break;
                        }
                    }
                }
                
                return uniqueChampions;
            }
            
            /**
             * Apply diversity filter to limit champions per role
             * @param {Array} champions - Array of champion objects sorted by score
             * @returns {Array} - Filtered array with diversity applied
             */
            static applyDiversityFilter(champions) {
                const selected = [];
                const roleCount = {};
                
                // First pass: select champions with max 2 per role
                for (const champion of champions) {
                    const championData = allChampions[champion.championName];
                    const role = championData?.role || 'Unknown';
                    
                    // Limit to max 2 champions per role in top 5
                    if ((roleCount[role] || 0) < 2) {
                        selected.push(champion);
                        roleCount[role] = (roleCount[role] || 0) + 1;
                    }
                    
                    // Stop once we have 5 champions
                    if (selected.length >= 5) break;
                }
                
                // If we don't have 5 yet, add remaining highest scores regardless of role
                if (selected.length < 5) {
                    for (const champion of champions) {
                        // Check if not already selected
                        if (!selected.find(c => c.championName === champion.championName)) {
                            selected.push(champion);
                            
                            if (selected.length >= 5) break;
                        }
                    }
                }
                
                return selected;
            }
        }

        // Evaluation Metrics Class
        class EvaluationMetrics {
            /**
             * Calculate Precision@K metric
             * @param {Array<string>} recommendedChampions - Array of recommended champion names
             * @param {Set<string>} relevantChampions - Set of relevant champion names
             * @param {number} k - Number of top recommendations to consider
             * @returns {number} - Precision value between 0.0 and 1.0
             */
            static precisionAtK(recommendedChampions, relevantChampions, k) {
                // Handle edge cases
                if (!recommendedChampions || recommendedChampions.length === 0 || k === 0) {
                    return 0.0;
                }
                
                // Get top K recommendations
                const topK = recommendedChampions.slice(0, k);
                
                // Count how many are relevant
                let relevantCount = 0;
                for (const champion of topK) {
                    if (relevantChampions.has(champion)) {
                        relevantCount++;
                    }
                }
                
                // Calculate precision
                return relevantCount / topK.length;
            }
            
            /**
             * Calculate Mean Reciprocal Rank metric
             * @param {Array<string>} recommendedChampions - Array of recommended champion names
             * @param {Set<string>} relevantChampions - Set of relevant champion names
             * @returns {number} - MRR value between 0.0 and 1.0
             */
            static meanReciprocalRank(recommendedChampions, relevantChampions) {
                // Handle edge cases
                if (!recommendedChampions || recommendedChampions.length === 0) {
                    return 0.0;
                }
                
                // Find rank of first relevant champion (1-indexed)
                for (let i = 0; i < recommendedChampions.length; i++) {
                    if (relevantChampions.has(recommendedChampions[i])) {
                        return 1.0 / (i + 1);
                    }
                }
                
                // No relevant champion found
                return 0.0;
            }
            
            /**
             * Calculate user relevance based on questionnaire answers
             * @param {Object} userAnswers - User's questionnaire answers
             * @param {Object} allChampions - All available champions
             * @returns {Set<string>} - Set of relevant champion names
             */
            static calculateUserRelevance(userAnswers, allChampions) {
                const championScores = [];
                
                // Extract user preferences
                const userRole = userAnswers.role || 'No Preference';
                const userDifficulty = this.mapDifficultyToNumeric(userAnswers.difficulty);
                const { damage: userDamage, toughness: userToughness } = this.mapPlaystyleToAttributes(userAnswers.playstyle);
                
                // Iterate through all champions and calculate match score
                for (const [championName, champion] of Object.entries(allChampions)) {
                    let matchScore = 0;
                    let totalCriteria = 0;
                    
                    // Role match (most important - 40% weight)
                    totalCriteria += 4;
                    if (userRole === 'No Preference' || userRole === champion.role) {
                        matchScore += 4;
                    } else {
                        matchScore += 0.5; // Small partial credit for wrong role
                    }
                    
                    // Difficulty match (25% weight)
                    if (userDifficulty !== null) {
                        totalCriteria += 2.5;
                        const difficultyDiff = Math.abs(userDifficulty - champion.difficulty);
                        if (difficultyDiff <= 1) {
                            matchScore += 2.5; // Exact or very close match
                        } else if (difficultyDiff <= 2.5) {
                            matchScore += 1.5; // Close match
                        } else if (difficultyDiff <= 4) {
                            matchScore += 0.75; // Somewhat close
                        } else {
                            matchScore += 0.25; // Far but some credit
                        }
                    }
                    
                    // Damage match (20% weight)
                    if (userDamage !== null) {
                        totalCriteria += 2;
                        const damageDiff = Math.abs(userDamage - champion.damage);
                        if (damageDiff <= 1) {
                            matchScore += 2; // Exact or very close match
                        } else if (damageDiff <= 2.5) {
                            matchScore += 1.25; // Close match
                        } else if (damageDiff <= 4) {
                            matchScore += 0.5; // Somewhat close
                        } else {
                            matchScore += 0.2; // Far but some credit
                        }
                    }
                    
                    // Toughness match (15% weight)
                    if (userToughness !== null) {
                        totalCriteria += 1.5;
                        const toughnessDiff = Math.abs(userToughness - champion.toughness);
                        if (toughnessDiff <= 1) {
                            matchScore += 1.5; // Exact or very close match
                        } else if (toughnessDiff <= 2.5) {
                            matchScore += 0.9; // Close match
                        } else if (toughnessDiff <= 4) {
                            matchScore += 0.4; // Somewhat close
                        } else {
                            matchScore += 0.15; // Far but some credit
                        }
                    }
                    
                    // Calculate match percentage
                    const matchPercentage = totalCriteria > 0 ? (matchScore / totalCriteria) : 0;
                    championScores.push({ name: championName, score: matchPercentage });
                }
                
                // Sort champions by score descending
                championScores.sort((a, b) => b.score - a.score);
                
                // Use adaptive threshold: start at 45%, but ensure at least top 20-30% of champions are relevant
                const minRelevantCount = Math.max(10, Math.floor(championScores.length * 0.15));
                const maxRelevantCount = Math.ceil(championScores.length * 0.35);
                
                const relevantChampions = new Set();
                let threshold = 0.45;
                
                // First pass: add champions above threshold
                for (const champ of championScores) {
                    if (champ.score >= threshold) {
                        relevantChampions.add(champ.name);
                    }
                }
                
                // Ensure we have at least minimum relevant champions
                if (relevantChampions.size < minRelevantCount) {
                    for (let i = 0; i < minRelevantCount && i < championScores.length; i++) {
                        relevantChampions.add(championScores[i].name);
                    }
                }
                
                // Cap at maximum to maintain quality standards
                if (relevantChampions.size > maxRelevantCount) {
                    const cappedSet = new Set();
                    let count = 0;
                    for (const champ of championScores) {
                        if (relevantChampions.has(champ.name) && count < maxRelevantCount) {
                            cappedSet.add(champ.name);
                            count++;
                        }
                    }
                    return cappedSet;
                }
                
                return relevantChampions;
            }
            
            /**
             * Extract recommended champions from ML results
             * @param {Object} mlResults - Results from all ML algorithms (unified structure with top5 array)
             * @returns {Array<string>} - Array of 5 champion names in order (highest score first)
             */
            static getRecommendedChampions(mlResults) {
                // Check if mlResults has the new unified structure with top5 array
                if (mlResults && mlResults.top5 && Array.isArray(mlResults.top5)) {
                    // Extract top 5 champion names from mlResults.top5
                    // Maintain order (highest score first)
                    return mlResults.top5.map(champion => champion.championName);
                }
                
                // Fallback to legacy structure for backward compatibility
                const championScores = {};
                
                // Extract champions from each algorithm
                for (const [algorithmName, result] of Object.entries(mlResults)) {
                    if (result && result.champion) {
                        const championName = result.champion;
                        const confidence = result.confidence || 0;
                        
                        // Collect confidence scores (use max if champion appears multiple times)
                        if (!championScores[championName] || championScores[championName] < confidence) {
                            championScores[championName] = confidence;
                        }
                    }
                }
                
                // Sort by confidence score descending
                const sortedChampions = Object.entries(championScores)
                    .sort((a, b) => b[1] - a[1])
                    .map(entry => entry[0]);
                
                return sortedChampions;
            }
            
            /**
             * Helper: Map difficulty string to numeric value
             * @param {string} difficulty - Difficulty string from questionnaire
             * @returns {number|null} - Numeric difficulty value or null
             */
            static mapDifficultyToNumeric(difficulty) {
                const mapping = {
                    'Easy (1-3)': 2,
                    'Medium (4-6)': 5,
                    'Hard (7-8)': 7.5,
                    'Very Hard (9-10)': 9.5
                };
                return mapping[difficulty] !== undefined ? mapping[difficulty] : null;
            }
            
            /**
             * Helper: Map playstyle to damage/toughness attributes
             * @param {string} playstyle - Playstyle string from questionnaire
             * @returns {Object} - Object with damage and toughness values
             */
            static mapPlaystyleToAttributes(playstyle) {
                const mapping = {
                    'High Damage Output': { damage: 8, toughness: 3 },
                    'Tanky and Durable': { damage: 4, toughness: 8 },
                    'Support Team': { damage: 3, toughness: 5 },
                    'Balanced/Hybrid': { damage: 5, toughness: 5 }
                };
                return mapping[playstyle] || { damage: null, toughness: null };
            }
        }

        /**
         * Display evaluation metrics in a visually appealing section
         * @param {Object} metrics - Object containing p1, p3, p5, mrr values
         * @param {number} relevantCount - Number of relevant champions
         * @param {number} recommendedCount - Number of recommended champions
         * @returns {string} - HTML string for metrics section
         */
        function displayEvaluationMetrics(metrics, relevantCount, recommendedCount) {
            // Helper function to determine color class based on metric value
            function getColorClass(value) {
                if (value >= 0.7) return 'excellent';
                if (value >= 0.4) return 'good';
                return 'poor';
            }

            // Helper function to format percentage
            function formatPercentage(value) {
                return (value * 100).toFixed(1) + '%';
            }

            // Determine overall performance level
            let performanceLevel = 'Needs Improvement';
            let performanceMessage = 'The recommendations show room for improvement. Consider adjusting your preferences for better matches.';
            let performanceColor = '#c62828';

            if (metrics.p5 >= 0.6 && metrics.mrr >= 0.5) {
                performanceLevel = 'Excellent';
                performanceMessage = 'The recommendations are highly aligned with your preferences! The top suggestions should be great matches for your playstyle.';
                performanceColor = '#2e7d32';
            } else if (metrics.p5 >= 0.4 || metrics.mrr >= 0.3) {
                performanceLevel = 'Good';
                performanceMessage = 'The recommendations show good alignment with your preferences. You should find several suitable champions in the top suggestions.';
                performanceColor = '#f57c00';
            }

            // Build the HTML structure
            const html = `
                <div class="evaluation-metrics-section">
                    <h3>
                        <span style="font-size: 1.8rem; margin-right: 10px;">üìä</span>
                        Recommendation Quality Metrics
                    </h3>
                    
                    <div class="metrics-grid">
                        <!-- Precision@1 Card -->
                        <div class="metric-card" onclick="showMetricModal('p1', ${metrics.p1}, ${relevantCount}, ${recommendedCount})">
                            <div class="metric-label">Precision@1</div>
                            <div class="metric-value ${getColorClass(metrics.p1)}">
                                ${formatPercentage(metrics.p1)}
                            </div>
                            <div class="metric-description">
                                Top recommendation relevance
                            </div>
                        </div>

                        <!-- Precision@3 Card -->
                        <div class="metric-card" onclick="showMetricModal('p3', ${metrics.p3}, ${relevantCount}, ${recommendedCount})">
                            <div class="metric-label">Precision@3</div>
                            <div class="metric-value ${getColorClass(metrics.p3)}">
                                ${formatPercentage(metrics.p3)}
                            </div>
                            <div class="metric-description">
                                Top 3 recommendations relevance
                            </div>
                        </div>

                        <!-- Precision@5 Card -->
                        <div class="metric-card" onclick="showMetricModal('p5', ${metrics.p5}, ${relevantCount}, ${recommendedCount})">
                            <div class="metric-label">Precision@5</div>
                            <div class="metric-value ${getColorClass(metrics.p5)}">
                                ${formatPercentage(metrics.p5)}
                            </div>
                            <div class="metric-description">
                                Top 5 recommendations relevance
                            </div>
                        </div>

                        <!-- MRR Card -->
                        <div class="metric-card" onclick="showMetricModal('mrr', ${metrics.mrr}, ${relevantCount}, ${recommendedCount})">
                            <div class="metric-label">Mean Reciprocal Rank</div>
                            <div class="metric-value ${getColorClass(metrics.mrr)}">
                                ${formatPercentage(metrics.mrr)}
                            </div>
                            <div class="metric-description">
                                First relevant match position
                            </div>
                        </div>
                    </div>

                    <!-- Performance Interpretation -->
                    <div class="performance-interpretation" style="border-left-color: ${performanceColor};">
                        <h4 style="color: ${performanceColor}; margin-bottom: 10px; font-size: 1.2rem;">
                            Overall Performance: ${performanceLevel}
                        </h4>
                        <p style="color: #424242; margin-bottom: 15px; line-height: 1.6;">
                            ${performanceMessage}
                        </p>
                        <div style="display: flex; justify-content: space-around; margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0;">
                            <div style="text-align: center;">
                                <div style="font-size: 0.8rem; color: #666; margin-bottom: 5px;">Relevant Champions</div>
                                <div style="font-size: 1.3rem; font-weight: bold; color: #2e7d32;">${relevantCount}</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 0.8rem; color: #666; margin-bottom: 5px;">Recommended</div>
                                <div style="font-size: 1.3rem; font-weight: bold; color: #1565c0;">${recommendedCount}</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            return html;
        }

        // Application Logic
        let currentQuestion = 1;
        let answers = {};
        let mlResults = {};
        
        // TASK 13.1: Score caching system
        // Cache algorithm scores to avoid recalculation with same features
        const scoreCache = new Map();
        
        // TASK 13.2: Details caching system
        // Cache calculation details loaded on demand
        const detailsCache = new Map();
        
        /**
         * Generate a hash key from features object for caching
         * @param {Object} features - User feature object
         * @returns {string} Hash key for caching
         */
        function generateFeatureHash(features) {
            // Create a stable string representation of features
            const keys = Object.keys(features).sort();
            const values = keys.map(key => `${key}:${features[key]}`);
            return values.join('|');
        }
        
        /**
         * Get cached scores for an algorithm or calculate if not cached
         * TASK 14.1: Now includes performance profiling
         * @param {string} algorithmName - Name of the algorithm ('random-forest', 'decision-tree', 'knn')
         * @param {Object} algorithm - Algorithm instance
         * @param {Object} features - User features
         * @returns {Object} Scores object for all champions
         */
        function getCachedScores(algorithmName, algorithm, features) {
            const featureHash = generateFeatureHash(features);
            const cacheKey = `${algorithmName}-${featureHash}`;
            
            // Check if scores are cached
            if (scoreCache.has(cacheKey)) {
                console.log(`[Cache Hit] Using cached scores for ${algorithmName}`);
                return scoreCache.get(cacheKey);
            }
            
            // Calculate scores if not cached - with performance profiling
            console.log(`[Cache Miss] Calculating scores for ${algorithmName}`);
            const profileResult = profilePredictAll(algorithmName, algorithm, features);
            const scores = profileResult.scores;
            
            // Store in cache
            scoreCache.set(cacheKey, scores);
            
            // Limit cache size to prevent memory issues (keep last 50 entries)
            if (scoreCache.size > 50) {
                const firstKey = scoreCache.keys().next().value;
                scoreCache.delete(firstKey);
            }
            
            return scores;
        }
        
        /**
         * Get cached calculation details or load on demand
         * @param {string} algorithmName - Name of the algorithm
         * @param {string} championName - Name of the champion
         * @param {Object} detailsObject - Details object from mlResults
         * @returns {Object} Calculation details
         */
        function getCachedDetails(algorithmName, championName, detailsObject) {
            const cacheKey = `${algorithmName}-${championName}`;
            
            // Check if details are cached
            if (detailsCache.has(cacheKey)) {
                console.log(`[Cache Hit] Using cached details for ${algorithmName} - ${championName}`);
                return detailsCache.get(cacheKey);
            }
            
            // Load details on demand
            console.log(`[Cache Miss] Loading details for ${algorithmName} - ${championName}`);
            
            // Store in cache
            detailsCache.set(cacheKey, detailsObject);
            
            // Limit cache size (keep last 100 entries)
            if (detailsCache.size > 100) {
                const firstKey = detailsCache.keys().next().value;
                detailsCache.delete(firstKey);
            }
            
            return detailsObject;
        }
        
        /**
         * Clear all caches (useful for testing or when user preferences change significantly)
         */
        function clearAllCaches() {
            scoreCache.clear();
            detailsCache.clear();
            console.log('[Cache] All caches cleared');
        }
        
        // TASK 14.1: Performance Profiling System
        // Track performance metrics for each algorithm
        const performanceMetrics = {
            'random-forest': { calls: 0, totalTime: 0, avgTime: 0, minTime: Infinity, maxTime: 0, lastTime: 0 },
            'decision-tree': { calls: 0, totalTime: 0, avgTime: 0, minTime: Infinity, maxTime: 0, lastTime: 0 },
            'knn': { calls: 0, totalTime: 0, avgTime: 0, minTime: Infinity, maxTime: 0, lastTime: 0 }
        };
        
        /**
         * Profile the execution time of predictAll() for an algorithm
         * @param {string} algorithmName - Name of the algorithm
         * @param {Object} algorithm - Algorithm instance
         * @param {Object} features - User features
         * @returns {Object} Object containing scores and timing information
         */
        function profilePredictAll(algorithmName, algorithm, features) {
            const startTime = performance.now();
            
            // Execute predictAll
            const scores = algorithm.predictAll(features);
            
            const endTime = performance.now();
            const executionTime = endTime - startTime;
            
            // Update metrics
            const metrics = performanceMetrics[algorithmName];
            metrics.calls++;
            metrics.totalTime += executionTime;
            metrics.avgTime = metrics.totalTime / metrics.calls;
            metrics.minTime = Math.min(metrics.minTime, executionTime);
            metrics.maxTime = Math.max(metrics.maxTime, executionTime);
            metrics.lastTime = executionTime;
            
            // Log performance data
            console.log(`[Performance] ${algorithmName} predictAll() took ${executionTime.toFixed(3)}ms`);
            
            return {
                scores: scores,
                executionTime: executionTime,
                metrics: { ...metrics }
            };
        }
        
        /**
         * Get performance statistics for all algorithms
         * @returns {Object} Performance statistics
         */
        function getPerformanceStats() {
            const stats = {};
            
            for (const [algorithmName, metrics] of Object.entries(performanceMetrics)) {
                stats[algorithmName] = {
                    calls: metrics.calls,
                    avgTime: metrics.avgTime.toFixed(3) + 'ms',
                    minTime: metrics.minTime === Infinity ? 'N/A' : metrics.minTime.toFixed(3) + 'ms',
                    maxTime: metrics.maxTime === 0 ? 'N/A' : metrics.maxTime.toFixed(3) + 'ms',
                    lastTime: metrics.lastTime.toFixed(3) + 'ms',
                    totalTime: metrics.totalTime.toFixed(3) + 'ms'
                };
            }
            
            return stats;
        }
        
        /**
         * Display performance metrics in console
         */
        function displayPerformanceMetrics() {
            console.log('=== ML Algorithm Performance Metrics ===');
            const stats = getPerformanceStats();
            
            for (const [algorithmName, metrics] of Object.entries(stats)) {
                console.log(`\n${algorithmName.toUpperCase()}:`);
                console.log(`  Calls: ${metrics.calls}`);
                console.log(`  Average Time: ${metrics.avgTime}`);
                console.log(`  Min Time: ${metrics.minTime}`);
                console.log(`  Max Time: ${metrics.maxTime}`);
                console.log(`  Last Time: ${metrics.lastTime}`);
                console.log(`  Total Time: ${metrics.totalTime}`);
            }
            
            console.log('\n========================================');
        }
        
        /**
         * Reset performance metrics
         */
        function resetPerformanceMetrics() {
            for (const algorithmName in performanceMetrics) {
                performanceMetrics[algorithmName] = {
                    calls: 0,
                    totalTime: 0,
                    avgTime: 0,
                    minTime: Infinity,
                    maxTime: 0,
                    lastTime: 0
                };
            }
            console.log('[Performance] Metrics reset');
        }
        
        /**
         * Identify performance bottlenecks
         * @returns {Object} Bottleneck analysis
         */
        function identifyBottlenecks() {
            const analysis = {
                slowest: null,
                fastest: null,
                recommendations: []
            };
            
            let slowestTime = 0;
            let fastestTime = Infinity;
            
            for (const [algorithmName, metrics] of Object.entries(performanceMetrics)) {
                if (metrics.calls === 0) continue;
                
                if (metrics.avgTime > slowestTime) {
                    slowestTime = metrics.avgTime;
                    analysis.slowest = { algorithm: algorithmName, avgTime: metrics.avgTime };
                }
                
                if (metrics.avgTime < fastestTime) {
                    fastestTime = metrics.avgTime;
                    analysis.fastest = { algorithm: algorithmName, avgTime: metrics.avgTime };
                }
            }
            
            // Generate recommendations
            if (analysis.slowest) {
                const slowAlgorithm = analysis.slowest.algorithm;
                const avgTime = analysis.slowest.avgTime;
                
                if (avgTime > 50) {
                    analysis.recommendations.push({
                        algorithm: slowAlgorithm,
                        issue: 'High execution time (>50ms)',
                        suggestion: 'Consider optimizing loop iterations or using more efficient data structures'
                    });
                }
                
                if (avgTime > 100) {
                    analysis.recommendations.push({
                        algorithm: slowAlgorithm,
                        issue: 'Very high execution time (>100ms)',
                        suggestion: 'Critical: Implement caching or reduce champion iteration count'
                    });
                }
            }
            
            // Check for cache effectiveness
            const cacheSize = scoreCache.size;
            if (cacheSize === 0) {
                analysis.recommendations.push({
                    algorithm: 'all',
                    issue: 'Cache not being utilized',
                    suggestion: 'Ensure getCachedScores() is being used instead of direct predictAll() calls'
                });
            }
            
            return analysis;
        }
        
        /**
         * Display bottleneck analysis in console
         */
        function displayBottleneckAnalysis() {
            const analysis = identifyBottlenecks();
            
            console.log('=== Performance Bottleneck Analysis ===');
            
            if (analysis.slowest) {
                console.log(`\nSlowest Algorithm: ${analysis.slowest.algorithm}`);
                console.log(`  Average Time: ${analysis.slowest.avgTime.toFixed(3)}ms`);
            }
            
            if (analysis.fastest) {
                console.log(`\nFastest Algorithm: ${analysis.fastest.algorithm}`);
                console.log(`  Average Time: ${analysis.fastest.avgTime.toFixed(3)}ms`);
            }
            
            if (analysis.recommendations.length > 0) {
                console.log('\nRecommendations:');
                analysis.recommendations.forEach((rec, index) => {
                    console.log(`\n${index + 1}. ${rec.algorithm.toUpperCase()}`);
                    console.log(`   Issue: ${rec.issue}`);
                    console.log(`   Suggestion: ${rec.suggestion}`);
                });
            } else {
                console.log('\nNo performance issues detected. All algorithms performing well!');
            }
            
            console.log('\n========================================');
        }
        
        /**
         * Clear all caches (useful for testing or when user preferences change significantly)
         */
        function clearAllCachesOld() {
            scoreCache.clear();
            detailsCache.clear();
            console.log('[Cache] All caches cleared');
        }
        
        // Diversity tracking to prevent repetitive recommendations
        let recentRecommendations = JSON.parse(localStorage.getItem('recentChampions') || '[]');
        
        function updateRecentRecommendations(champions) {
            // Add new champions to recent list
            champions.forEach(champion => {
                if (!recentRecommendations.includes(champion)) {
                    recentRecommendations.unshift(champion);
                }
            });
            
            // Keep only last 15 recommendations
            recentRecommendations = recentRecommendations.slice(0, 15);
            localStorage.setItem('recentChampions', JSON.stringify(recentRecommendations));
        }
        
        function applyDiversityBonus(candidates, recentChampions) {
            return candidates.map(candidate => {
                let diversityBonus = 0;
                
                // Bonus for champions not recently recommended
                if (!recentChampions.includes(candidate.name || candidate.champion)) {
                    diversityBonus += 20;
                }
                
                // Extra bonus for champions never recommended
                if (!recentRecommendations.includes(candidate.name || candidate.champion)) {
                    diversityBonus += 30;
                }
                
                return {
                    ...candidate,
                    score: (candidate.score || 0) + diversityBonus
                };
            });
        }

        const algorithms = {
            'random-forest': new SimpleRandomForest(),
            'decision-tree': new SimpleDecisionTree(),
            'knn': new SimpleKNN()
        };

        // User data storage
        let userData = {};

        function startQuestionnaire() {
            console.log('Starting registration process...');
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('user-registration').classList.add('active');
        }

        function backToStart() {
            document.getElementById('user-registration').classList.remove('active');
            document.getElementById('start-screen').style.display = 'block';
        }

        // Handle form submission
        document.addEventListener('DOMContentLoaded', function() {
            const userForm = document.getElementById('user-form');
            if (userForm) {
                userForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    handleUserRegistration();
                });
            }
        });

        function handleUserRegistration() {
            const form = document.getElementById('user-form');
            const formData = new FormData(form);
            
            // Collect user data
            userData = {
                fullName: formData.get('fullName'),
                email: formData.get('email'),
                phone: formData.get('phone') || 'Not provided',
                age: formData.get('age'),
                gender: formData.get('gender') || 'Not specified',
                experience: formData.get('experience') || 'Not specified',
                registrationDate: new Date().toISOString(),
                sessionId: generateSessionId()
            };

            // Add loading state
            form.classList.add('form-loading');
            
            // Save to PYTHON_TESTING folder CSV
            saveUserDataToExcel(userData)
                .then((result) => {
                    // Success - proceed to questionnaire
                    form.classList.remove('form-loading');
                    document.getElementById('user-registration').classList.remove('active');
                    generateQuestions();
                    showQuestion(1);
                })
                .catch((error) => {
                    // Error - still proceed but show warning
                    console.error('Data save error:', error);
                    form.classList.remove('form-loading');
                    document.getElementById('user-registration').classList.remove('active');
                    generateQuestions();
                    showQuestion(1);
                });
        }

        function saveUserDataToExcel(data) {
            return new Promise((resolve, reject) => {
                // Try to save to Python server first (PYTHON_TESTING folder)
                // GitHub Pages version - save to localStorage only
                console.log('üåê GitHub Pages version - saving to localStorage');
                try {
                    let existingData = JSON.parse(localStorage.getItem('championRecommenderUsers') || '[]');
                    existingData.push(data);
                    localStorage.setItem('championRecommenderUsers', JSON.stringify(existingData));
                    console.log('‚úÖ User data saved to localStorage successfully!');
                    console.log('üìä Press Ctrl+Shift+E to export your data as CSV');
                    
                    // Google Analytics tracking removed as per user request
                    
                    resolve({ success: true, github_pages: true });
                } catch (error) {
                    console.error('‚ùå Failed to save to localStorage:', error);
                    reject(error);
                }
            });
        }

        // Save user data to localStorage only
        async function saveUserToLocalStorage(userData) {
            try {
                // Save to localStorage only
                let existingData = JSON.parse(localStorage.getItem('championRecommenderUsers') || '[]');
                existingData.push(userData);
                localStorage.setItem('championRecommenderUsers', JSON.stringify(existingData));
                console.log('‚úÖ User data saved to localStorage successfully!');
            } catch (error) {
                console.log('‚ö†Ô∏è Error occurred while saving user data:', error);
            }
        }

        function generateSessionId() {
            return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function createExcelFile(userData) {
            // Create CSV content (Excel compatible)
            let csvContent = "Full Name,Email,Phone,Age,Gender,LoL Experience,Registration Date,Session ID\n";
            
            userData.forEach(user => {
                const row = [
                    user.fullName,
                    user.email,
                    user.phone,
                    user.age,
                    user.gender,
                    user.experience,
                    new Date(user.registrationDate).toLocaleString(),
                    user.sessionId
                ].map(field => `"${field}"`).join(',');
                
                csvContent += row + "\n";
            });
            
            // Create and download Excel file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', 'champion_recommender_users.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                
                // Auto-download for admin (you can remove this in production)
                // link.click();
                
                document.body.removeChild(link);
            }
        }


        // Function to manually download user data (for admin use)
        function downloadUserData() {
            const userData = JSON.parse(localStorage.getItem('championRecommenderUsers') || '[]');
            if (userData.length > 0) {
                createExcelFile(userData);
                // Trigger download
                const csvContent = "Full Name,Email,Phone,Age,Gender,LoL Experience,Registration Date,Session ID\n";
                let content = csvContent;
                
                userData.forEach(user => {
                    const row = [
                        user.fullName,
                        user.email,
                        user.phone,
                        user.age,
                        user.gender,
                        user.experience,
                        new Date(user.registrationDate).toLocaleString(),
                        user.sessionId
                    ].map(field => `"${field}"`).join(',');
                    
                    content += row + "\n";
                });
                
                const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'champion_recommender_users.csv';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            } else {
                alert('No user data available to download.');
            }
        }

        function proceedToQuestionnaire() {
            console.log('Starting Multi-ML questionnaire...');
            generateQuestions();
            showQuestion(1);
        }

        function generateQuestions() {
            const container = document.getElementById('questions-container');
            container.innerHTML = '';
            
            questionsDatabase.forEach((question, index) => {
                const questionCard = document.createElement('div');
                questionCard.id = `question-${question.id}`;
                questionCard.className = 'card question-card';
                if (index === 0) { // Make the first question active by default
                    questionCard.classList.add('active');
                }
                
                questionCard.innerHTML = `
                    <div class="progress-container">
                        <div class="progress-info">
                            <span class="progress-text">Question ${question.id} of ${questionsDatabase.length}</span>
                            <span class="progress-text">${Math.round((question.id - 1) / questionsDatabase.length * 100)}% Complete</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${(question.id - 1) / questionsDatabase.length * 100}%"></div>
                        </div>
                    </div>
                    
                    <div class="question">
                        <h2>${question.text}</h2>
                        <div class="options">
                            ${question.options.map(option => `
                                <div class="option" onclick="selectOption(${question.id}, '${option.value}', this)" title="${option.description}">
                                    ${option.text}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    
                    <div class="buttons">
                        <div class="button-group">
                            ${question.id > 1 ? `<button class="btn btn-secondary" onclick="previousQuestion(${question.id})">Previous</button>` : '<div class="btn-spacer"></div>'}
                            <button class="btn btn-primary" onclick="nextQuestion(${question.id})" id="next-${question.id}" disabled>
                                ${question.id === questionsDatabase.length ? 'Run All ML Algorithms' : 'Next'}
                            </button>
                        </div>
                    </div>
                `;
                
                container.appendChild(questionCard);
            });
        }

        function showQuestion(questionNum) {
            document.querySelectorAll('.question-card').forEach(card => {
                card.classList.remove('active');
            });
            
            const questionCard = document.getElementById(`question-${questionNum}`);
            if (questionCard) {
                questionCard.classList.add('active');
                currentQuestion = questionNum;
            }
        }

        function selectOption(questionId, value, element) {
            const options = element.parentNode.querySelectorAll('.option');
            options.forEach(opt => opt.classList.remove('selected'));
            
            element.classList.add('selected');
            answers[questionId] = value;
            
            document.getElementById(`next-${questionId}`).disabled = false;
        }

        function nextQuestion(currentNum) {
            if (currentNum === questionsDatabase.length) {
                runAllAlgorithms();
                return;
            }
            
            showQuestion(currentNum + 1);
        }

        function previousQuestion(currentNum) {
            if (currentNum > 1) {
                showQuestion(currentNum - 1);
            }
        }  
      function runAllAlgorithms() {
            document.querySelectorAll('.question-card').forEach(card => {
                card.classList.remove('active');
            });
            
            // TASK 5.1: Extract user features
            // Convert answers to features with proper mapping of psychological questions
            const userFeatures = {
                // Core gameplay preferences
                role: answers[2] || 'No Preference',
                position: answers[3] || 'No Preference',
                difficulty: mapDifficulty(answers[1]),
                damage: 5, // Will be adjusted based on playstyle
                toughness: 5, // Will be adjusted based on playstyle
                playstyle: mapPlaystyle(answers[4]),
                range: mapRange(answers[5]),
                
                // Psychological preferences mapped to gameplay attributes
                pressure_response: answers[6] || 'Stay calm and strategic',
                aesthetic_preference: answers[7] || 'Heroic',
                team_contribution: answers[8] || 'Balance between both',
                character_identity: answers[9] || 'No preference',
                problem_solving: answers[10] || 'Analyze carefully before acting'
            };
            
            // Adjust damage/toughness based on playstyle
            adjustAttributesBasedOnPlaystyle(userFeatures);
            
            // TASK 5.2: Run all 3 algorithms with predictAll()
            // TASK 13.1: Use caching to avoid recalculating scores for same features
            // Call predictAll() for each algorithm to get scores for ALL champions
            const rfScores = getCachedScores('random-forest', algorithms['random-forest'], userFeatures);
            const dtScores = getCachedScores('decision-tree', algorithms['decision-tree'], userFeatures);
            const knnScores = getCachedScores('knn', algorithms['knn'], userFeatures);
            
            // TASK 5.3: Aggregate scores
            // Use ScoreAggregator to combine scores from all 3 algorithms
            const aggregated = ScoreAggregator.aggregateScores(rfScores, dtScores, knnScores);
            
            // TASK 5.4: Select top 5 champions
            // Get the top 5 champions based on aggregated scores
            const top5 = ScoreAggregator.selectTop5(aggregated);
            
            // TASK 5.5: Update mlResults global object
            // Store all results in the global mlResults object
            mlResults = {
                scores: {
                    randomForest: rfScores,
                    decisionTree: dtScores,
                    knn: knnScores
                },
                aggregated: aggregated,
                top5: top5
            };
            
            // Measure performance for backward compatibility
            const performanceStats = {
                'random-forest': { time: '0.000', accuracy: 92 },
                'decision-tree': { time: '0.000', accuracy: 87 },
                'knn': { time: '0.000', accuracy: 89 }
            };
            
            // TASK 5.6: Call display function
            // For now, keep the existing displayResults function
            // TODO: Replace with displayUnifiedRecommendations(top5) in Phase 4
            displayResults(performanceStats);
        }

        // Helper functions to map questionnaire answers to numerical values
        function mapDifficulty(answer) {
            const mapping = {
                'Easy (1-3)': 2,
                'Medium (4-6)': 5,
                'Hard (7-8)': 7.5,
                'Very Hard (9-10)': 9.5
            };
            return mapping[answer] || 5;
        }
        
        function mapPlaystyle(answer) {
            const mapping = {
                'High Damage Output': 'aggressive',
                'Tanky and Durable': 'defensive',
                'Support Team': 'supportive',
                'Balanced/Hybrid': 'balanced'
            };
            return mapping[answer] || 'balanced';
        }
        
        function mapRange(answer) {
            return answer ? answer.toLowerCase() : 'no_preference';
        }
        
        function adjustAttributesBasedOnPlaystyle(features) {
            switch(features.playstyle) {
                case 'aggressive':
                    features.damage = 8;
                    features.toughness = 3;
                    break;
                case 'defensive':
                    features.damage = 4;
                    features.toughness = 8;
                    break;
                case 'supportive':
                    features.damage = 3;
                    features.toughness = 5;
                    features.utility = 8;
                    break;
                case 'balanced':
                default:
                    features.damage = 5;
                    features.toughness = 5;
                    break;
            }
        }

        function displayResults(performanceStats) {
            // Check if mlResults has the new unified structure
            if (!mlResults.top5 || !Array.isArray(mlResults.top5) || mlResults.top5.length === 0) {
                console.error('Error: mlResults does not contain top5 recommendations');
                alert('An error occurred while generating recommendations. Please try again.');
                return;
            }
            
            // Extract champion names from top5 for backward compatibility
            const champions = mlResults.top5.map(c => c.championName);
            
            // Google Analytics tracking removed as per user request
            
            // Update diversity tracking with new recommendations
            updateRecentRecommendations(champions);
            
            // Skip the Multi-Algorithm Results page and go directly to detailed analysis
            showDetailedAnalysis();
        }

        function saveUserResults(consensus, winner) {
            if (userData.sessionId) {
                const resultData = {
                    sessionId: userData.sessionId,
                    recommendedChampion: consensus.champions[0],
                    winningAlgorithm: winner,
                    confidence: Math.round(mlResults[winner].confidence * 10) / 10,
                    randomForestChampion: mlResults['random-forest'].champion,
                    randomForestConfidence: Math.round(mlResults['random-forest'].confidence * 10) / 10,
                    decisionTreeChampion: mlResults['decision-tree'].champion,
                    decisionTreeConfidence: Math.round(mlResults['decision-tree'].confidence * 10) / 10,
                    knnChampion: mlResults['knn'].champion,
                    knnConfidence: Math.round(mlResults['knn'].confidence * 10) / 10,
                    consensusLevel: consensus.agreement,
                    userAnswers: JSON.stringify(answers),
                    completionDate: new Date().toISOString()
                };
                
                // Send results to server (PYTHON_TESTING folder)
                saveResultsToServer(resultData);
                
                // Also update localStorage as backup
                let existingData = JSON.parse(localStorage.getItem('championRecommenderUsers') || '[]');
                const userIndex = existingData.findIndex(user => user.sessionId === userData.sessionId);
                
                if (userIndex !== -1) {
                    existingData[userIndex] = { ...existingData[userIndex], ...resultData };
                    localStorage.setItem('championRecommenderUsers', JSON.stringify(existingData));
                }
            }
        }

        function saveResultsToServer(resultData) {
            // GitHub Pages version - update localStorage only
            try {
                let existingData = JSON.parse(localStorage.getItem('championRecommenderUsers') || '[]');
                const userIndex = existingData.findIndex(user => user.sessionId === resultData.sessionId);
                
                if (userIndex !== -1) {
                    existingData[userIndex] = { ...existingData[userIndex], ...resultData };
                    localStorage.setItem('championRecommenderUsers', JSON.stringify(existingData));
                    console.log('‚úÖ Results saved to localStorage successfully!');
                    console.log('üìä Press Ctrl+Shift+E to export complete data as CSV');
                } else {
                    console.log('‚ö†Ô∏è User not found in localStorage');
                }
            } catch (error) {
                console.log('‚ùå Could not save results to localStorage:', error.message);
            }
        }

        // Save user data to localStorage only
        async function saveUserToLocalStorage(userData) {
            try {
                // Save to localStorage only
                let existingData = JSON.parse(localStorage.getItem('championRecommenderUsers') || '[]');
                existingData.push(userData);
                localStorage.setItem('championRecommenderUsers', JSON.stringify(existingData));
                console.log('‚úÖ User data saved to localStorage successfully!');
            } catch (error) {
                console.log('‚ö†Ô∏è Error occurred while saving user data:', error);
            }
        }

        // Save questionnaire results to localStorage only
        async function saveQuestionnaireResultsToLocalStorage(resultData) {
            try {
                // Save to localStorage only
                let existingData = JSON.parse(localStorage.getItem('championRecommenderUsers') || '[]');
                const userIndex = existingData.findIndex(user => user.sessionId === resultData.sessionId);
                
                if (userIndex !== -1) {
                    // Update the existing user data with questionnaire results
                    existingData[userIndex] = {
                        ...existingData[userIndex],
                        ...resultData,
                        // Map psychological questions to dedicated fields
                        pressure_response: answers[6] || '',
                        aesthetic_preference: answers[7] || '',
                        team_contribution: answers[8] || '',
                        character_identity: answers[9] || '',
                        problem_solving: answers[10] || ''
                    };
                    
                    localStorage.setItem('championRecommenderUsers', JSON.stringify(existingData));
                    console.log('‚úÖ Questionnaire results saved to localStorage successfully!');
                }
            } catch (error) {
                console.log('‚ö†Ô∏è Error occurred while saving questionnaire results:', error);
            }
        }

        function findConsensus(champions) {
            const counts = {};
            champions.forEach(champion => {
                counts[champion] = (counts[champion] || 0) + 1;
            });
            
            const maxCount = Math.max(...Object.values(counts));
            const consensusChampions = Object.keys(counts).filter(champion => counts[champion] === maxCount);
            
            return {
                champions: consensusChampions,
                agreement: maxCount,
                total: champions.length
            };
        }

        function findWinner(results) {
            let highestConfidence = 0;
            let winner = 'random-forest'; // Default to random forest
            
            if (!results) {
                return winner;
            }
            
            Object.entries(results).forEach(([algorithm, result]) => {
                if (result && result.confidence && result.confidence > highestConfidence) {
                    highestConfidence = result.confidence;
                    winner = algorithm;
                }
            });
            
            return winner;
        }

function showDetailedAnalysis() {
            const analysisContent = document.getElementById('analysis-content');
            
            // Check if mlResults has the new unified structure
            if (!mlResults.top5 || !Array.isArray(mlResults.top5) || mlResults.top5.length === 0) {
                console.error('Error: mlResults does not contain top5 recommendations');
                analysisContent.innerHTML = '<p style="color: white; text-align: center; padding: 40px;">An error occurred while generating recommendations. Please try again.</p>';
                document.getElementById('detailed-analysis').classList.add('active');
                return;
            }
            
            // Get top 5 champions from unified structure
            const top5Champions = mlResults.top5;
            const topChampion = top5Champions[0];
            
            // Define algorithm names for consistent use throughout
            const algorithmNames = {
                'randomForest': { name: 'Random Forest', icon: '<i class="ai-brain-icon"></i>' },
                'decisionTree': { name: 'Decision Tree', icon: '<i class="target-icon"></i>' },
                'knn': { name: 'K-Nearest Neighbors', icon: '<i class="lightning-icon"></i>' }
            };
            
            // Generate the detailed analysis content using string concatenation instead of template literals
            var content = '';
            content += '<div class="analysis-header">';
            content += '<h2><i class="analysis-icon"></i> Detailed Champion Analysis</h2>';
            content += '<p>Personalized champion recommendations based on your preferences</p>';
            content += '</div>';
            
            content += '<div class="champion-analysis-section">';
            content += '<h3><i class="champion-finder-icon"></i> Champion Match Analysis</h3>';
            content += '<div class="analysis-explanation">';
            content += '<p>Based on your preferences, here are your top ' + top5Champions.length + ' champion recommendations:</p>';
            content += '</div>';
            
            content += '<div class="match-analysis-grid">';
            
            // Add match cards for each top5 champion
            top5Champions.forEach((championResult, index) => {
                const champion = allChampions[championResult.championName];
                const isTopPick = index === 0;
                const roleMatch = answers[2] === 'No Preference' || champion.role === answers[2] ? 100 : 70;
                const difficultyMatch = Math.max(0, 100 - Math.abs(champion.difficulty - mapDifficulty(answers[1])) * 10);
                const toughnessMatch = Math.max(0, 100 - Math.abs(champion.toughness - 5) * 8);
                
                // Store champion data for modal
                const championData = JSON.stringify({
                    name: championResult.championName,
                    scores: {
                        randomForest: championResult.randomForest,
                        decisionTree: championResult.decisionTree,
                        knn: championResult.knn,
                        average: championResult.average
                    },
                    champion: champion,
                    matches: {
                        role: roleMatch,
                        difficulty: difficultyMatch,
                        toughness: toughnessMatch
                    }
                }).replace(/"/g, '&quot;');
                
                content += '<div class="match-card ' + (isTopPick ? 'winner' : '') + '" onclick="showChampionModal(' + championData + ')">';
                content += '<div class="match-header">';
                content += '<img src="' + getChampionImageUrl(championResult.championName) + '" alt="' + championResult.championName + '" class="match-champion-img" ';
                content += 'onerror="console.log(\'Failed to load image for champion:\', \'' + championResult.championName + '\', \'Generated URL:\', this.src); ';
                content += 'this.src=\'https://via.placeholder.com/80x80/667eea/white?text=' + encodeURIComponent(championResult.championName.length > 3 ? championResult.championName.substring(0, 3) : championResult.championName) + '\'; ';
                content += 'this.onerror=null;">';
                content += '<div class="match-info">';
                content += '<h4>' + championResult.championName + ' ' + (isTopPick ? '<span class="winner-badge"><i class="league-icon"></i> TOP PICK</span>' : '') + '</h4>';
                content += '<div class="match-tier">Tier ' + (champion.stats?.tier || 'B') + ' ‚Ä¢ ' + (champion.stats?.winRate || '50.0') + '% WR</div>';
                content += '<div class="algorithm-info">üéØ Unified ML Score ‚Ä¢ ' + championResult.average.toFixed(1) + '% match</div>';
                content += '</div>';
                content += '</div>';
                
                content += '<div class="compatibility-score">';
                content += '<div class="score-label">Compatibility Score</div>';
                content += '<div class="score-value">' + championResult.average.toFixed(0) + '%</div>';
                content += '</div>';
                
                content += '<div class="match-breakdown">';
                content += '<div class="breakdown-item">';
                content += '<div class="breakdown-label">Random Forest</div>';
                content += '<div class="breakdown-value">' + championResult.randomForest.toFixed(0) + '%</div>';
                content += '</div>';
                content += '<div class="breakdown-item">';
                content += '<div class="breakdown-label">Decision Tree</div>';
                content += '<div class="breakdown-value">' + championResult.decisionTree.toFixed(0) + '%</div>';
                content += '</div>';
                content += '<div class="breakdown-item">';
                content += '<div class="breakdown-label">KNN</div>';
                content += '<div class="breakdown-value">' + championResult.knn.toFixed(0) + '%</div>';
                content += '</div>';
                content += '<div class="breakdown-item">';
                content += '<span class="breakdown-label">Role Match</span>';
                content += '<div class="breakdown-bar">';
                content += '<div class="breakdown-fill" style="width: ' + roleMatch + '%"></div>';
                content += '</div>';
                content += '<span class="breakdown-value">' + roleMatch + '%</span>';
                content += '</div>';
                
                content += '<div class="breakdown-item">';
                content += '<span class="breakdown-label">Difficulty</span>';
                content += '<div class="breakdown-bar">';
                content += '<div class="breakdown-fill" style="width: ' + difficultyMatch + '%"></div>';
                content += '</div>';
                content += '<span class="breakdown-value">' + difficultyMatch + '%</span>';
                content += '</div>';
                
                content += '<div class="breakdown-item">';
                content += '<span class="breakdown-label">Survivability</span>';
                content += '<div class="breakdown-bar">';
                content += '<div class="breakdown-fill" style="width: ' + toughnessMatch + '%"></div>';
                content += '</div>';
                content += '<span class="breakdown-value">' + toughnessMatch + '%</span>';
                content += '</div>';
                content += '</div>';
                
                content += '<div class="champion-stats-grid">';
                content += '<div class="stat-item"><span class="stat-label">Damage</span><span class="stat-value">' + champion.damage + '/10</span></div>';
                content += '<div class="stat-item"><span class="stat-label">Toughness</span><span class="stat-value">' + champion.toughness + '/10</span></div>';
                content += '<div class="stat-item"><span class="stat-label">Mobility</span><span class="stat-value">' + champion.mobility + '/10</span></div>';
                content += '<div class="stat-item"><span class="stat-label">Control</span><span class="stat-value">' + champion.control + '/10</span></div>';
                content += '</div>';
                
                content += '<div class="champion-highlights">';
                content += '<div class="highlight-title">Key Strengths:</div>';
                content += '<div class="highlight-tags">';
                
                if (champion.damage >= 8) content += '<span class="highlight-tag damage">High Damage</span>';
                if (champion.toughness >= 7) content += '<span class="highlight-tag tank">Tanky</span>';
                if (champion.mobility >= 7) content += '<span class="highlight-tag mobile">Mobile</span>';
                if (champion.control >= 7) content += '<span class="highlight-tag control">Crowd Control</span>';
                if (champion.utility >= 8) content += '<span class="highlight-tag utility">High Utility</span>';
                if (champion.difficulty <= 3) content += '<span class="highlight-tag easy">Beginner Friendly</span>';
                
                content += '</div>';
                content += '</div>';
                content += '</div>';
            });
            
            content += '</div>';
            content += '</div>';
            
            content += '<div class="recommendations-section">';
            content += '<h3>üéØ Personalized Recommendations & Next Steps</h3>';
            
            content += '<div class="recommendation-cards">';
            content += '<div class="recommendation-card primary-rec">';
            content += '<div class="rec-icon"><i class="league-icon"></i></div>';
            content += '<h4>Primary Recommendation</h4>';
            content += '<div class="primary-champion">' + topChampion.championName + '</div>';
            content += '<p style="color: #333; text-align: center; margin-bottom: 15px; font-size: 0.95rem;">Top recommendation based on unified ML analysis with ' + topChampion.average.toFixed(1) + '% average match score.</p>';
            content += '<div class="action-buttons">';
            content += '<button class="action-btn" onclick="window.open(\'https://www.mobafire.com/league-of-legends/' + topChampion.championName.toLowerCase() + '-guide\', \'_blank\')">üìö View Guide</button>';
            content += '<button class="action-btn" onclick="window.open(\'https://u.gg/lol/champions/' + topChampion.championName.toLowerCase() + '/build\', \'_blank\')">‚öôÔ∏è Build Guide</button>';
            content += '</div>';
            content += '</div>';
            
            content += '<div class="recommendation-card counter-synergies">';
            content += '<div class="rec-icon"><i class="champion-finder-icon"></i></div>';
            content += '<h4>Counter Matchups & Synergies</h4>';
            content += '<div class="matchup-list">';
            content += '<div class="matchup-category"><span class="matchup-icon">&#10003;</span> Strong Against:</div>';
            content += '<div id="strong-against-list">';
            content += '<div class="matchup-item strong-against">Immobile champions</div>';
            content += '<div class="matchup-item strong-against">Squishy targets</div>';
            content += '</div>';
            
            content += '<div class="matchup-category"><span class="matchup-icon">&#10007;</span> Weak Against:</div>';
            content += '<div id="weak-against-list">';
            content += '<div class="matchup-item weak-against">Mobile champions</div>';
            content += '<div class="matchup-item weak-against">Tanks</div>';
            content += '</div>';
            
            content += '<div class="matchup-category"><span class="matchup-icon">&#129309;</span> Synergizes With:</div>';
            content += '<div id="synergizes-list">';
            content += '<div class="matchup-item synergizes-with">Engage supports</div>';
            content += '<div class="matchup-item synergizes-with">CC-heavy junglers</div>';
            content += '</div>';
            content += '</div>';
            content += '</div>';
            
            content += '<div class="recommendation-card alternative-picks">';
            content += '<div class="rec-icon"><i class="target-icon"></i></div>';
            content += '<h4>Alternative Champions</h4>';
            content += '<div class="alternatives-list">';
            
            // Add alternative champions (skip the first one which is the top pick)
            for (var i = 1; i < Math.min(3, top5Champions.length); i++) {
                var altChampion = top5Champions[i];
                content += '<div class="alternative-item">';
                content += '<img src="' + getChampionImageUrl(altChampion.championName) + '" alt="' + altChampion.championName + '" class="alt-champion-img" ';
                content += 'onerror="console.log(\'Failed to load image for alternative champion:\', \'' + altChampion.championName + '\', \'Generated URL:\', this.src); ';
                content += 'this.src=\'https://via.placeholder.com/40x40/667eea/white?text=' + encodeURIComponent(altChampion.championName.length > 2 ? altChampion.championName.substring(0, 2) : altChampion.championName) + '\'; ';
                content += 'this.onerror=null;">';
                content += '<div class="alt-info">';
                content += '<div class="alt-name">' + altChampion.championName + '</div>';
                content += '<div class="alt-reason">' + altChampion.average.toFixed(0) + '% match ‚Ä¢ ' + allChampions[altChampion.championName].role + '</div>';
                content += '</div>';
                content += '</div>';
            }
            
            content += '</div>';
            content += '</div>';
            
            content += '<div class="recommendation-card meta-insights">';
            content += '<div class="rec-icon"><i class="analysis-icon"></i></div>';
            content += '<h4>Current Meta Insights</h4>';
            content += '<div class="meta-info">';
            
            // Calculate average win rate from top5
            var totalWinRate = 0;
            top5Champions.forEach(championResult => {
                totalWinRate += (allChampions[championResult.championName].stats?.winRate || 50);
            });
            var avgWinRate = top5Champions.length > 0 ? Math.round(totalWinRate / top5Champions.length * 10) / 10 : 50;
            
            // Calculate average difficulty
            var totalDifficulty = 0;
            top5Champions.forEach(championResult => {
                totalDifficulty += allChampions[championResult.championName].difficulty;
            });
            var avgDifficulty = top5Champions.length > 0 ? Math.round(totalDifficulty / top5Champions.length * 10) / 10 : 5;
            
            content += '<div class="meta-stat">';
            content += '<span class="meta-label">Average Win Rate:</span>';
            content += '<span class="meta-value">' + avgWinRate + '%</span>';
            content += '</div>';
            content += '<div class="meta-stat">';
            content += '<span class="meta-label">Avg. Difficulty:</span>';
            content += '<span class="meta-value">' + avgDifficulty + '/10</span>';
            content += '</div>';
            
            // Check if all champions have positive win rates
            var allPositive = true;
            top5Champions.forEach(championResult => {
                if ((allChampions[championResult.championName].stats?.winRate || 50) < 50) {
                    allPositive = false;
                }
            });
            
            content += '<div class="meta-recommendation">';
            content += allPositive ? 
                '‚úÖ All recommendations are currently meta-viable with positive win rates!' : 
                '‚ö†Ô∏è Some recommendations may require extra practice due to current meta shifts.';
            content += '</div>';
            content += '</div>';
            content += '</div>';
            content += '</div>';
            
            // Calculate and display evaluation metrics
            try {
                // Calculate user relevance based on questionnaire answers
                const relevantChampions = EvaluationMetrics.calculateUserRelevance(answers, allChampions);
                
                // Get recommended champions from ML results
                const recommendedChampions = EvaluationMetrics.getRecommendedChampions(mlResults);
                
                // Store globally for modal access
                window.currentMLResults = mlResults;
                window.currentRelevantChampions = relevantChampions;
                
                // Calculate Precision@K metrics
                const precision1 = EvaluationMetrics.precisionAtK(recommendedChampions, relevantChampions, 1);
                const precision3 = EvaluationMetrics.precisionAtK(recommendedChampions, relevantChampions, 3);
                const precision5 = EvaluationMetrics.precisionAtK(recommendedChampions, relevantChampions, 5);
                
                // Calculate Mean Reciprocal Rank
                const mrr = EvaluationMetrics.meanReciprocalRank(recommendedChampions, relevantChampions);
                
                // Create metrics object
                const metrics = {
                    p1: precision1,
                    p3: precision3,
                    p5: precision5,
                    mrr: mrr
                };
                
                // Display metrics section
                content += displayEvaluationMetrics(metrics, relevantChampions.size, recommendedChampions.length);
            } catch (error) {
                console.error('Error calculating evaluation metrics:', error);
                // Continue without metrics if there's an error
            }
            
            content += '<div class="final-tips">';
            content += '<h4><i class="sparkle-icon-sm"></i> Pro Tips</h4>';
            content += '<div class="tips-grid">';
            
            // Add pro tips for top champion
            const proTips = getChampionProTips(topChampion.championName);
            
            // Show up to 6 tips
            for (var i = 0; i < Math.min(6, proTips.length); i++) {
                content += '<div class="tip-item">';
                content += '<span class="tip-icon">' + proTips[i].icon + '</span>';
                content += '<div class="tip-text">' + proTips[i].tip + '</div>';
                content += '</div>';
            }
            
            content += '</div>';
            content += '<div class="champion-tip-source">';
            content += '<small>&#127919; Pro tips for ' + topChampion.championName + ' - Master these fundamentals to excel with your recommended champion!</small>';
            content += '</div>';
            content += '</div>';
            content += '</div>';
            
            // Set the content
            analysisContent.innerHTML = content;
            
            // Google Analytics tracking removed as per user request
            
            // Show the detailed analysis section
            document.getElementById('detailed-analysis').classList.add('active');
            
            // Load counter data for the recommended champion
            loadCounterData(topChampion.championName.toLowerCase());
        }
        
        // Load counter data for a champion
        function loadCounterData(championName) {
            // Handle special champion names that might not match the JSON keys
            const specialCases = {
                'aurelionsol': 'aurelion sol',
                'belveth': 'bel\'veth',
                'chogath': 'cho\'gath',
                'drmundo': 'dr. mundo',
                'jarvaniv': 'jarvan iv',
                'kaisa': 'kai\'sa',
                'khazix': 'kha\'zix',
                'kogmaw': 'kog\'maw',
                'leesin': 'lee sin',
                'missfortune': 'miss fortune',
                'nunu': 'nunu & willump',
                'reksai': 'rek\'sai',
                'tahmkench': 'tahm kench',
                'twistedfate': 'twisted fate',
                'velkoz': 'vel\'koz',
                'xinzhao': 'xin zhao'
            };
            
            // Normalize the champion name
            const normalizedName = specialCases[championName] || championName;
            
            fetch('data/champion_counters.json')
                .then(response => response.json())
                .then(data => {
                    // Try both the normalized name and the original name
                    const championData = data[normalizedName] || data[championName];
                    if (championData) {
                        // Update the counter lists
                        let strongHtml = '';
                        let weakHtml = '';
                        let synergyHtml = '';
                        
                        championData.strong_against.forEach(item => {
                            strongHtml += '<div class="matchup-item strong-against">' + item + '</div>';
                        });
                        
                        championData.weak_against.forEach(item => {
                            weakHtml += '<div class="matchup-item weak-against">' + item + '</div>';
                        });
                        
                        championData.synergizes_with.forEach(item => {
                            synergyHtml += '<div class="matchup-item synergizes-with">' + item + '</div>';
                        });
                        
                        const strongList = document.getElementById('strong-against-list');
                        const weakList = document.getElementById('weak-against-list');
                        const synergyList = document.getElementById('synergizes-list');
                        
                        if (strongList) strongList.innerHTML = strongHtml;
                        if (weakList) weakList.innerHTML = weakHtml;
                        if (synergyList) synergyList.innerHTML = synergyHtml;
                    }
                })
                .catch(err => console.log('Could not load counter data:', err));
        }
        const championProTips = {
            'Jinx': [
                { icon: '&#127919;', tip: 'Use Fishbones (rocket launcher) for teamfights and Pow-Pow (minigun) for objectives' },
                { icon: '&#9889;', tip: 'Get Excited! passive gives massive movement speed - use it to chase or escape' },
                { icon: '&#128165;', tip: 'Super Mega Death Rocket executes low HP enemies globally - watch for snipe opportunities' },
                { icon: '&#128737;', tip: 'Stay behind your frontline and use your range advantage to avoid assassins' },
                { icon: '&#128259;', tip: 'Switch between forms based on distance - Fishbones for long range, Pow-Pow for sustained DPS' },
                { icon: '&#127919;', tip: 'Use your long range to control minion waves and deny farm to enemy ADC' }
            ],
            'Ashe': [
                { icon: '&#127993;', tip: 'Use Hawkshot (E) frequently for vision control and tracking enemy jungler' },
                { icon: '&#10052;', tip: 'Frost Shot passive slows help with kiting - weave auto attacks between abilities' },
                { icon: '&#127919;', tip: 'Crystal Arrow (R) is best used to initiate fights or catch out-of-position enemies' },
                { icon: '&#128202;', tip: 'Focus on farming safely early game - Ashe scales incredibly well into late game' },
                { icon: '&#10052;', tip: 'Use Volley (W) to push waves quickly when your ADC is safe' },
                { icon: '&#127919;', tip: 'Position for teamfights where you can land your ultimate on multiple enemies' }
            ],
            'Yasuo': [
                { icon: '&#127744;', tip: 'Use minions to dash through and position for optimal Wind Wall placement' },
                { icon: '&#9876;', tip: 'Stack Q tornado on minions before engaging - it\'s your main engage tool' },
                { icon: '&#128737;', tip: 'Wind Wall blocks projectiles completely - time it against key enemy abilities' },
                { icon: '&#9889;', tip: 'Last Breath (R) resets your shield - use it when shield is broken for maximum value' }
            ],
            'Lux': [
                { icon: '&#128161;', tip: 'Proc your passive with auto attacks after landing abilities for maximum damage' },
                { icon: '&#127775;', tip: 'Use Light Binding (Q) through minions to catch enemies behind the wave' },
                { icon: '‚ö°', tip: 'Final Spark (R) has very long range - use it to secure objectives from safety' },
                { icon: 'üõ°Ô∏è', tip: 'Prismatic Barrier (W) can shield allies twice - position to hit maximum teammates' },
                { icon: '&#127775;', tip: 'Use your abilities to zone enemies from minion waves and control CS' },
                { icon: '&#128161;', tip: 'Combine your abilities for maximum damage - Q + E + auto + R combo' }
            ],
            'Garen': [
                { icon: '&#128170;', tip: 'Perseverance passive heals you - disengage when low to recover health' },
                { icon: '&#127937;', tip: 'Use Decisive Strike (Q) to remove slows and gain movement speed for engages' },
                { icon: 'üå™Ô∏è', tip: 'Judgment (E) deals more damage to isolated targets - focus single enemies' },
                { icon: '&#9876;', tip: 'Demacian Justice (R) executes based on missing health - time it perfectly' },
                { icon: '&#128737;', tip: 'Use Courage (W) to reduce incoming damage during trades' },
                { icon: '&#128170;', tip: 'Roam when your lane is pushed to help other lanes get ahead' }
            ],
            'Thresh': [
                { icon: '&#9937;', tip: 'Death Sentence (Q) can be reactivated to dash - sometimes don\'t take it for positioning' },
                { icon: '&#127985;', tip: 'Dark Passage (W) gives shield and mobility - throw it preemptively for escapes' },
                { icon: '&#128128;', tip: 'Flay (E) can interrupt dashes - practice timing against mobile champions' },
                { icon: '&#128259;', tip: 'The Box (R) slows heavily on first wall hit - use it to zone enemies' }
            ],
            'Ahri': [
                { icon: '&#128150;', tip: 'Charm (E) amplifies damage - always combo it with Q and W for maximum burst' },
                { icon: '&#129418;', tip: 'Spirit Rush (R) has three charges - don\'t waste them all at once' },
                { icon: '&#9889;', tip: 'Orb of Deception (Q) deals magic damage out, true damage back - position for both hits' },
                { icon: '&#127919;', tip: 'Use Fox-Fire (W) while moving to maintain damage while repositioning' }
            ],
            'Darius': [
                { icon: '&#129656;', tip: 'Hemorrhage passive stacks to 5 - get full stacks before all-inning' },
                { icon: '‚öîÔ∏è', tip: 'Apprehend (E) pulls and slows - use it to interrupt enemy escapes' },
                { icon: 'üå™Ô∏è', tip: 'Decimate (Q) heals and deals more damage at max range - space properly' },
                { icon: 'üíÄ', tip: 'Noxian Guillotine (R) resets on kills - look for multi-kill opportunities' },
                { icon: 'üõ°Ô∏è', tip: 'Use your sustain to trade aggressively in lane without backing' },
                { icon: '‚öîÔ∏è', tip: 'Look for enemies with low mobility to pull with your E' }
            ],
            'Zed': [
                { icon: 'üë§', tip: 'Living Shadow (W) can be reactivated to swap - use for escapes or gap closing' },
                { icon: '‚ö°', tip: 'Razor Shuriken (Q) deals reduced damage through units - hit from angles' },
                { icon: 'üíÄ', tip: 'Death Mark (R) spawns shadow behind target - use it for guaranteed W+E+Q combo' },
                { icon: 'üîÑ', tip: 'You can swap to any shadow within 4 seconds - plan your escape route' },
                { icon: 'üë§', tip: 'Use your shadows to scout vision and track enemy movements' },
                { icon: '‚ö°', tip: 'Look for enemies low on resources to use your ultimate effectively' }
            ],
            'Leona': [
                { icon: '‚òÄÔ∏è', tip: 'Sunlight passive marks enemies - coordinate with ADC to proc marks' },
                { icon: '‚öîÔ∏è', tip: 'Zenith Blade (E) is your main engage - aim for carries behind frontline' },
                { icon: 'üõ°Ô∏è', tip: 'Eclipse (W) provides armor/MR and explodes for damage - activate before engaging' },
                { icon: '‚òÄÔ∏è', tip: 'Solar Flare (R) has huge range - use it to start fights from unexpected angles' },
                { icon: 'üõ°Ô∏è', tip: 'Use your tankiness to soak up damage and protect your carries' },
                { icon: '‚öîÔ∏è', tip: 'Look for opportunities to peel for your ADC with your crowd control' }
            ],
            'Ezreal': [
                { icon: '‚ö°', tip: 'Mystic Shot (Q) reduces all cooldowns on hit - spam it for more abilities' },
                { icon: 'üîÆ', tip: 'Essence Flux (W) marks enemies - detonate with Q for extra damage' },
                { icon: 'üìç', tip: 'Arcane Shift (E) can go through walls - learn wall jump spots' },
                { icon: 'üåü', tip: 'Trueshot Barrage (R) hits all enemies - use for waveclear and teamfight damage' },
                { icon: '&#127919;', tip: 'Use your mobility to reposition and avoid enemy abilities' },
                { icon: '‚ö°', tip: 'Focus on landing Q consistently to reduce your ability cooldowns' }
            ],
            'Annie': [
                { icon: 'üî•', tip: 'Pyromania passive stuns on 4th ability - keep track of your stacks' },
                { icon: 'üß∏', tip: 'Summon: Tibbers (R) with stun passive is devastating - flash+R for surprise engages' },
                { icon: 'üí´', tip: 'Disintegrate (Q) refunds mana and reduces cooldown on kill - use for farming' },
                { icon: 'üî•', tip: 'Molten Shield (E) reflects damage - activate before trading or teamfights' },
                { icon: 'üß∏', tip: 'Use Tibbers to scout vision and zone enemies from objectives' },
                { icon: 'üî•', tip: 'Save your stun for key enemy abilities or escapes' }
            ],
            'Master Yi': [
                { icon: '‚öîÔ∏è', tip: 'Alpha Strike (Q) can dodge abilities - time it to avoid key enemy cooldowns' },
                { icon: 'üßò', tip: 'Meditate (W) reduces damage taken - use it to tank jungle monsters or tower shots' },
                { icon: '‚ö°', tip: 'Wuju Style (E) gives true damage - activate before fighting tanky enemies' },
                { icon: 'üèÉ', tip: 'Highlander (R) resets on takedowns - look for cleanup opportunities in teamfights' },
                { icon: 'üßò', tip: 'Use Meditate to sustain in lane and avoid backing' },
                { icon: '‚öîÔ∏è', tip: 'Look for opportunities to split push when teamfights are unfavorable' }
            ],
            'Soraka': [
                { icon: '‚≠ê', tip: 'Starcall (Q) heals you when hitting enemies - stay healthy by landing Qs' },
                { icon: 'üåô', tip: 'Astral Infusion (W) costs your health - balance healing with your own survival' },
                { icon: 'üîá', tip: 'Equinox (E) silences in center, roots after delay - zone enemies from objectives' },
                { icon: 'üí´', tip: 'Wish (R) heals all allies globally - save low health teammates across the map' },
                { icon: 'üåô', tip: 'Use your heal to sustain your ADC in lane and avoid backing' },
                { icon: '‚≠ê', tip: 'Position safely to maximize your healing and avoid being focused' }
            ],
            'Malphite': [
                { icon: 'üóø', tip: 'Granite Shield passive blocks damage - let it recharge before trading' },
                { icon: 'üî®', tip: 'Seismic Shard (Q) steals movement speed - use it to stick to enemies or escape' },
                { icon: 'üåç', tip: 'Ground Slam (E) reduces enemy attack speed - great against ADCs and auto-attackers' },
                { icon: 'üí•', tip: 'Unstoppable Force (R) is unstoppable - use it to engage teamfights or escape' },
                { icon: 'üõ°Ô∏è', tip: 'Use your tankiness to initiate fights and soak up damage' },
                { icon: 'üî®', tip: 'Look for opportunities to peel for your carries with your crowd control' }
            ],
            'Katarina': [
                { icon: 'üó°Ô∏è', tip: 'Shunpo (E) resets on kills/assists - look for reset opportunities in teamfights' },
                { icon: 'üíÄ', tip: 'Death Lotus (R) deals massive damage - position safely before channeling' },
                { icon: 'üå™Ô∏è', tip: 'Bouncing Blade (Q) bounces to nearby enemies - use minions to hit champions' },
                { icon: '‚ö°', tip: 'Preparation (W) gives movement speed - use it for mobility and gap closing' },
                { icon: 'üó°Ô∏è', tip: 'Use your mobility to dodge key enemy abilities and reposition' },
                { icon: 'üíÄ', tip: 'Look for enemies low on health to use your ultimate effectively' }
            ],
            'Jhin': [
                { icon: 'üé≠', tip: 'Whisper passive makes 4th shot crit and reload - count your shots carefully' },
                { icon: 'üå∏', tip: 'Deadly Flourish (W) roots marked enemies - combo with Q or grenade marks' },
                { icon: 'üí•', tip: 'Dancing Grenade (Q) gains damage per kill - try to execute minions first' },
                { icon: '&#127919;', tip: 'Curtain Call (R) has massive range - use walls and bushes for surprise snipes' },
                { icon: 'üéØ', tip: 'Use your long range to control minion waves and deny farm to enemy ADC' },
                { icon: 'üé≠', tip: 'Focus on landing your abilities to maximize your passive damage' }
            ],
            'Blitzcrank': [
                { icon: 'ü§ñ', tip: 'Rocket Grab (Q) is game-changing - practice hooks through minion gaps' },
                { icon: 'üí™', tip: 'Power Fist (E) knocks up - combo it immediately after landing hook' },
                { icon: '‚ö°', tip: 'Static Field (R) passively damages nearby enemies and can silence on activation' },
                { icon: 'üõ°Ô∏è', tip: 'Mana Barrier passive gives huge shield when low - don\'t be afraid to engage' }
            ],
            'Vayne': [
                { icon: 'üèπ', tip: 'Silver Bolts (W) deals true damage every 3rd hit - focus same target' },
                { icon: '&#127919;', tip: 'Condemn (E) can stun against walls - position enemies near terrain' },
                { icon: 'üåô', tip: 'Tumble (Q) becomes invisible during Final Hour - use it for repositioning' },
                { icon: '‚ö°', tip: 'Final Hour (R) gives massive AD and stealth on Q - save for teamfights' },
                { icon: 'üåô', tip: 'Use your mobility to reposition and avoid enemy abilities' },
                { icon: 'üèπ', tip: 'Focus on landing your condemn to proc your silver bolts effectively' }
            ],
            'Riven': [
                { icon: '‚öîÔ∏è', tip: 'Broken Wings (Q) can be cancelled with movement - animation cancel for faster combos' },
                { icon: 'üõ°Ô∏è', tip: 'Valor (E) gives shield and mobility - use it to engage or escape' },
                { icon: 'üå™Ô∏è', tip: 'Ki Burst (W) stuns around you - combo it after gap closing with E+Q' },
                { icon: 'üí•', tip: 'Blade of the Exile (R) increases damage and gives execute - time the recast perfectly' },
                { icon: '‚öîÔ∏è', tip: 'Use your mobility to dodge key enemy abilities and reposition' },
                { icon: 'üõ°Ô∏è', tip: 'Look for opportunities to split push when teamfights are unfavorable' }
            ],
            'Miss Fortune': [
                { icon: 'üèπ', tip: 'Double Up (Q) bounces and crits - position to hit enemies behind minions' },
                { icon: 'üí•', tip: 'Bullet Time (R) deals massive damage - channel from safe positions' },
                { icon: 'üåä', tip: 'Make It Rain (E) slows enemies - use it to zone or set up other abilities' },
                { icon: '‚ö°', tip: 'Love Tap passive gives bonus damage - switch targets between auto attacks' },
                { icon: '&#127919;', tip: 'Use your long range to control minion waves and deny farm to enemy ADC' },
                { icon: '&#127993;', tip: 'Position for teamfights where you can land your ultimate on multiple enemies' }
            ],
            'Nami': [
                { icon: 'üíß', tip: 'Surging Tides passive gives movement speed to ability-hit allies' },
                { icon: 'üåä', tip: 'Aqua Prison (Q) has travel time - predict enemy movement' },
                { icon: 'üí´', tip: 'Ebb and Flow (W) bounces between enemies and allies - position for optimal bounces' },
                { icon: 'üåä', tip: 'Tidal Wave (R) knocks up and buffs allies it passes through' },
                { icon: 'üíß', tip: 'Use your heal to sustain your ADC in lane and avoid backing' },
                { icon: 'üåä', tip: 'Position safely to maximize your healing and avoid being focused' }
            ],
            // Default tips for other champions based on role
            'Tank': [
                { icon: '&#128737;', tip: 'Engage when your team is ready and enemies are grouped together' },
                { icon: '&#127919;', tip: 'Focus on peeling for your carries rather than diving their backline' },
                { icon: 'üë•', tip: 'Use your crowd control abilities to set up kills for your team' },
                { icon: '‚ö°', tip: 'Build according to enemy team composition - armor vs AD, MR vs AP' },
                { icon: 'üõ°Ô∏è', tip: 'Use your tankiness to soak up damage and protect your carries' },
                { icon: 'üë•', tip: 'Look for opportunities to initiate fights and create space for your team' }
            ],
            'Fighter': [
                { icon: '‚öîÔ∏è', tip: 'Look for extended trades where you can use your full combo' },
                { icon: 'üèÉ', tip: 'Use teleport to join teamfights or split push when ahead' },
                { icon: 'üí™', tip: 'Build a mix of damage and survivability to stay relevant' },
                { icon: 'üéØ', tip: 'Target the enemy backline but don\'t dive too deep alone' }
            ],
            'Assassin': [
                { icon: 'üíÄ', tip: 'Wait for enemy cooldowns before going in for the kill' },
                { icon: 'üë§', tip: 'Use fog of war and flanking to catch enemies off guard' },
                { icon: '‚ö°', tip: 'Burst down high-priority targets quickly then get out' },
                { icon: 'üåô', tip: 'Roam frequently to get kills and help other lanes snowball' },
                { icon: 'üë§', tip: 'Use your mobility to dodge key enemy abilities and reposition' },
                { icon: 'üíÄ', tip: 'Look for enemies low on health to use your ultimate effectively' }
            ],
            'Marksman': [
                { icon: 'üèπ', tip: 'Position safely behind your team and focus nearest target' },
                { icon: 'üí∞', tip: 'Farm consistently and avoid risky trades early game' },
                { icon: '&#127919;', tip: 'Use attack-move to maintain DPS while kiting backwards' },
                { icon: '&#9889;', tip: 'Build lifesteal to sustain through teamfights' },
                { icon: '&#127919;', tip: 'Use your long range to control minion waves and deny farm to enemy ADC' },
                { icon: 'üèπ', tip: 'Position for teamfights where you can maximize your damage output' }
            ],
            'Mage': [
                { icon: 'üîÆ', tip: 'Manage your mana carefully and look for ability combos' },
                { icon: 'üìè', tip: 'Use your range advantage to poke before teamfights' },
                { icon: 'üõ°Ô∏è', tip: 'Position safely and use crowd control to protect yourself' },
                { icon: 'üí•', tip: 'Save your ultimate for maximum impact in teamfights' },
                { icon: 'üîÆ', tip: 'Use your abilities to zone enemies from minion waves and control CS' },
                { icon: 'üìè', tip: 'Position for teamfights where you can land your abilities on multiple enemies' }
            ],
            'Support': [
                { icon: 'üëÅÔ∏è', tip: 'Ward key areas and deny enemy vision with control wards' },
                { icon: '&#129309;', tip: 'Roam to help other lanes when your ADC is safe' },
                { icon: '&#128737;', tip: 'Protect your carries and peel for them in teamfights' },
                { icon: 'üí°', tip: 'Build according to team needs - tank items or enchanter items' },
                { icon: '&#128065;', tip: 'Use your vision control to set up ganks and avoid enemy ganks' },
                { icon: '&#129309;', tip: 'Look for opportunities to create picks with your crowd control' }
            ]
        };

        // Get champion-specific pro tips
        function getChampionProTips(championName) {
            // First try exact match
            if (championProTips[championName]) {
                return championProTips[championName];
            }
            
            // Try normalized name (without special characters)
            const normalizedName = championName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
            for (const key in championProTips) {
                const normalizedKey = key.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
                if (normalizedKey === normalizedName) {
                    return championProTips[key];
                }
            }
            
            // Fall back to role-based tips
            const champion = allChampions[championName];
            if (champion && championProTips[champion.role]) {
                return championProTips[champion.role];
            }
            
            // Final fallback to Fighter tips
            return championProTips['Fighter'] || [
                { icon: '‚öîÔ∏è', tip: 'Adapt your playstyle based on the enemy team composition' },
                { icon: 'üõ°Ô∏è', tip: 'Focus on farming safely and scaling into the late game' }
            ];
        }

function restartQuestionnaire() {
            answers = {};
            currentQuestion = 1;
            mlResults = {};
            
            document.getElementById('detailed-analysis').classList.remove('active');
            document.querySelectorAll('.question-card').forEach(card => {
                card.classList.remove('active');
            });
            
            document.getElementById('start-screen').style.display = 'block';
            
            document.querySelectorAll('.option').forEach(opt => opt.classList.remove('selected'));
            document.querySelectorAll('[id^="next-"]').forEach(btn => btn.disabled = true);
        }

        // Function to save the current recommendation and display all results on a web page
        // Global variables to store metric data
        let currentMetricData = null;

        // Function to show metric modal with detailed information
        function showMetricModal(metricType, value, relevantCount, recommendedCount) {
            const modal = document.getElementById('metric-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');
            
            // Store metric data globally for access
            currentMetricData = { metricType, value, relevantCount, recommendedCount };
            
            // Get recommended champions from current ML results
            const recommendedChampions = window.currentMLResults ? 
                EvaluationMetrics.getRecommendedChampions(window.currentMLResults) : [];
            
            // Get relevant champions
            const relevantChampions = window.currentRelevantChampions || new Set();
            
            let content = '';
            let title = '';
            let scoreClass = value >= 0.7 ? '' : (value >= 0.4 ? 'warning' : 'poor');
            
            if (metricType === 'p1') {
                title = 'üìä Precision@1 - Top Recommendation Quality';
                const topChampion = recommendedChampions[0] || 'N/A';
                const isRelevant = relevantChampions.has(topChampion);
                
                content = `
                    <div class="modal-score ${scoreClass}">
                        <div class="modal-score-value">${(value * 100).toFixed(1)}%</div>
                        <div class="modal-score-label">Precision@1 Score</div>
                    </div>
                    
                    <h3>What is Precision@1?</h3>
                    <p>Precision@1 measures whether our <strong>top recommendation</strong> matches your preferences. A score of 100% means the #1 champion is highly relevant to what you're looking for.</p>
                    
                    <h3>Your Top Recommendation</h3>
                    <div class="champion-list">
                        <div class="champion-list-item">
                            <span class="champion-list-icon">üèÜ</span>
                            <span class="champion-list-name">${topChampion}</span>
                            <span class="champion-list-badge ${isRelevant ? 'relevant' : 'not-relevant'}">
                                ${isRelevant ? '‚úì Relevant' : '‚úó Not Optimal'}
                            </span>
                        </div>
                    </div>
                    
                    <h3>Why This Score?</h3>
                    <p>${isRelevant ? 
                        `<strong>${topChampion}</strong> is an excellent match for your preferences! The champion aligns well with your desired role, difficulty level, and playstyle.` :
                        `<strong>${topChampion}</strong> doesn't perfectly match all your preferences. This could mean the champion has a different difficulty level or playstyle than what you specified. Consider trying the other recommendations or adjusting your preferences.`
                    }</p>
                    
                    <h3>How It's Calculated</h3>
                    <p>We compare your top recommendation against ${relevantCount} champions that match your preferences (role, difficulty, damage output, and toughness). The recommendation is considered successful if it falls within this relevant set.</p>
                `;
                
            } else if (metricType === 'p3') {
                title = 'üìä Precision@3 - Top 3 Recommendations Quality';
                const top3 = recommendedChampions.slice(0, 3);
                const relevantInTop3 = top3.filter(champ => relevantChampions.has(champ)).length;
                
                content = `
                    <div class="modal-score ${scoreClass}">
                        <div class="modal-score-value">${(value * 100).toFixed(1)}%</div>
                        <div class="modal-score-label">Precision@3 Score</div>
                    </div>
                    
                    <h3>What is Precision@3?</h3>
                    <p>Precision@3 measures how many of your <strong>top 3 recommendations</strong> are relevant to your preferences. This gives you confidence that you have multiple good options to choose from.</p>
                    
                    <h3>Your Top 3 Recommendations</h3>
                    <div class="champion-list">
                        ${top3.map((champ, idx) => {
                            const isRelevant = relevantChampions.has(champ);
                            return `
                                <div class="champion-list-item">
                                    <span class="champion-list-icon">#${idx + 1}</span>
                                    <span class="champion-list-name">${champ}</span>
                                    <span class="champion-list-badge ${isRelevant ? 'relevant' : 'not-relevant'}">
                                        ${isRelevant ? '‚úì Relevant' : '‚úó Not Optimal'}
                                    </span>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    
                    <h3>Why This Score?</h3>
                    <p><strong>${relevantInTop3} out of 3</strong> recommendations match your preferences well. ${
                        relevantInTop3 === 3 ? 'Excellent! All three suggestions are great matches for your playstyle.' :
                        relevantInTop3 === 2 ? 'Good! Most of your top picks align with what you\'re looking for.' :
                        relevantInTop3 === 1 ? 'You have at least one strong option, but consider reviewing the others or adjusting preferences.' :
                        'None of the top 3 perfectly match your preferences. Try adjusting your criteria for better results.'
                    }</p>
                    
                    <h3>Scoring Details</h3>
                    <p>Score = (Relevant Champions in Top 3) √∑ 3 = ${relevantInTop3}/3 = ${(value * 100).toFixed(1)}%</p>
                `;
                
            } else if (metricType === 'p5') {
                title = 'üìä Precision@5 - Top 5 Recommendations Quality';
                const top5 = recommendedChampions.slice(0, 5);
                const relevantInTop5 = top5.filter(champ => relevantChampions.has(champ)).length;
                
                content = `
                    <div class="modal-score ${scoreClass}">
                        <div class="modal-score-value">${(value * 100).toFixed(1)}%</div>
                        <div class="modal-score-label">Precision@5 Score</div>
                    </div>
                    
                    <h3>What is Precision@5?</h3>
                    <p>Precision@5 measures how many of your <strong>top 5 recommendations</strong> are relevant. This metric shows the overall quality of our recommendation system for giving you multiple viable options.</p>
                    
                    <h3>Your Top 5 Recommendations</h3>
                    <div class="champion-list">
                        ${top5.map((champ, idx) => {
                            const isRelevant = relevantChampions.has(champ);
                            return `
                                <div class="champion-list-item">
                                    <span class="champion-list-icon">#${idx + 1}</span>
                                    <span class="champion-list-name">${champ}</span>
                                    <span class="champion-list-badge ${isRelevant ? 'relevant' : 'not-relevant'}">
                                        ${isRelevant ? '‚úì Relevant' : '‚úó Not Optimal'}
                                    </span>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    
                    <h3>Why This Score?</h3>
                    <p><strong>${relevantInTop5} out of 5</strong> recommendations are good matches. ${
                        relevantInTop5 >= 4 ? 'Excellent diversity! You have multiple great options to experiment with.' :
                        relevantInTop5 >= 3 ? 'Good variety! You should find several champions that fit your style.' :
                        relevantInTop5 >= 2 ? 'Decent options available, though some may require adaptation to your playstyle.' :
                        'Limited optimal matches. Consider broadening your preferences or trying the top-ranked champions.'
                    }</p>
                    
                    <h3>Scoring Details</h3>
                    <p>Score = (Relevant Champions in Top 5) √∑ 5 = ${relevantInTop5}/5 = ${(value * 100).toFixed(1)}%</p>
                    <p>Out of ${relevantCount} total relevant champions from our database of ${recommendedCount} analyzed champions.</p>
                `;
                
            } else if (metricType === 'mrr') {
                title = 'üìä Mean Reciprocal Rank (MRR)';
                const firstRelevantIndex = recommendedChampions.findIndex(champ => relevantChampions.has(champ));
                const rank = firstRelevantIndex >= 0 ? firstRelevantIndex + 1 : 'N/A';
                const firstRelevantChampion = firstRelevantIndex >= 0 ? recommendedChampions[firstRelevantIndex] : 'None found';
                
                content = `
                    <div class="modal-score ${scoreClass}">
                        <div class="modal-score-value">${(value * 100).toFixed(1)}%</div>
                        <div class="modal-score-label">MRR Score</div>
                    </div>
                    
                    <h3>What is Mean Reciprocal Rank?</h3>
                    <p>MRR measures <strong>how quickly</strong> we show you a relevant champion. It answers the question: "Do I have to scroll through many recommendations before finding a good match?"</p>
                    
                    <h3>First Relevant Match</h3>
                    <div class="champion-list">
                        <div class="champion-list-item">
                            <span class="champion-list-icon">üéØ</span>
                            <span class="champion-list-name">${firstRelevantChampion}</span>
                            ${rank !== 'N/A' ? `<span class="champion-list-badge relevant">Position #${rank}</span>` : ''}
                        </div>
                    </div>
                    
                    <h3>Why This Score?</h3>
                    <p>${rank !== 'N/A' ? 
                        `Your first relevant match appears at position <strong>#${rank}</strong>. ${
                            rank === 1 ? 'Perfect! The very first recommendation is a great match.' :
                            rank <= 2 ? 'Excellent! You found a relevant champion in the top 2.' :
                            rank <= 5 ? 'Good! A relevant champion appears in your top 5 recommendations.' :
                            'You may need to look through several recommendations to find the best match.'
                        }` :
                        'No relevant champions were found in the recommendations. Try adjusting your preferences for better matches.'
                    }</p>
                    
                    <h3>How It's Calculated</h3>
                    <p>MRR = 1 √∑ (Position of First Relevant Champion)</p>
                    ${rank !== 'N/A' ? `<p>MRR = 1 √∑ ${rank} = ${value.toFixed(3)} = ${(value * 100).toFixed(1)}%</p>` : '<p>MRR = 0 (no relevant matches found)</p>'}
                    <p>A score of 100% means the first recommendation is relevant. 50% means the second recommendation is the first relevant one, and so on.</p>
                    
                    <h3>What Makes a Champion Relevant?</h3>
                    <p>Champions are considered relevant when they score at least 45% on our weighted matching system:</p>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li><strong>Role Match:</strong> 40% weight - Most important factor</li>
                        <li><strong>Difficulty Match:</strong> 25% weight - Matches your skill preference</li>
                        <li><strong>Damage Output:</strong> 20% weight - Matches your playstyle</li>
                        <li><strong>Toughness/Durability:</strong> 15% weight - Tank vs. Squishy preference</li>
                    </ul>
                `;
            }
            
            modalTitle.textContent = title;
            modalBody.innerHTML = content;
            modal.classList.add('active');
        }

        // Function to close metric modal
        function closeMetricModal() {
            const modal = document.getElementById('metric-modal');
            modal.classList.remove('active');
        }

        // Close modal when clicking outside of it
        window.onclick = function(event) {
            const modal = document.getElementById('metric-modal');
            if (event.target === modal) {
                closeMetricModal();
            }
        }

        // Close modal on ESC key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeMetricModal();
                closeChampionModal();
            }
        });

        // Function to show champion modal with ML calculation details
        function showChampionModal(championData) {
            const modal = document.getElementById('champion-modal');
            const modalImg = document.getElementById('champion-modal-img');
            const modalName = document.getElementById('champion-modal-name');
            const modalSubtitle = document.getElementById('champion-modal-subtitle');
            const modalBody = document.getElementById('champion-modal-body');
            
            // Set champion image and name
            modalImg.src = getChampionImageUrl(championData.name);
            modalImg.onerror = function() {
                this.src = 'https://via.placeholder.com/100x100/667eea/white?text=' + encodeURIComponent(championData.name.substring(0, 2));
            };
            modalName.textContent = championData.name;
            modalSubtitle.textContent = `${championData.champion.role} ‚Ä¢ Tier ${championData.champion.stats?.tier || 'B'} ‚Ä¢ ${championData.champion.stats?.winRate || '50.0'}% WR`;
            
            // Build detailed ML explanation
            let content = '';
            
            // Final Score Section
            content += `
                <div class="final-score-section">
                    <h3>üéØ Unified ML Compatibility Score</h3>
                    <div class="final-score-value">${championData.scores.average.toFixed(1)}%</div>
                    <div class="score-interpretation">
                        ${championData.scores.average >= 80 ? 'Excellent Match! This champion aligns perfectly with your preferences.' :
                          championData.scores.average >= 70 ? 'Great Match! This champion fits well with what you\'re looking for.' :
                          championData.scores.average >= 60 ? 'Good Match! This champion should work well for your playstyle.' :
                          championData.scores.average >= 50 ? 'Decent Match! Give this champion a try, might surprise you.' :
                          'This champion may require adaptation to match your preferred playstyle.'}
                    </div>
                </div>
            `;
            
            // Random Forest Section
            content += `
                <div class="ml-algorithm-section">
                    <h3><span style="font-size: 1.4rem;">üå≤</span> Random Forest Algorithm</h3>
                    <div class="algorithm-score-card">
                        <div class="algorithm-header">
                            <div class="algorithm-name">
                                <span>Decision Tree Ensemble</span>
                            </div>
                            <div class="algorithm-score">${championData.scores.randomForest.toFixed(1)}%</div>
                        </div>
                        
                        <p style="color: #666; margin-bottom: 15px;">
                            Random Forest uses multiple decision trees to make predictions. Each tree votes, and the final score is the average of all votes.
                        </p>
                        
                        <div class="calculation-steps">
                            <div class="calculation-step">
                                <div class="step-label">Step 1: Role-Based Scoring</div>
                                <div class="step-formula">
                                    Base Score = ${championData.matches.role >= 100 ? '90' : '45'} (${championData.matches.role >= 100 ? 'Perfect Match' : 'Different Role'})
                                </div>
                            </div>
                            
                            <div class="calculation-step">
                                <div class="step-label">Step 2: Attribute Weighting</div>
                                <div class="step-formula">
                                    Damage Weight √ó ${championData.champion.damage}/10 = ${(championData.champion.damage * 1.2).toFixed(1)} points
                                </div>
                                <div class="step-formula">
                                    Toughness Weight √ó ${championData.champion.toughness}/10 = ${(championData.champion.toughness * 1.0).toFixed(1)} points
                                </div>
                                <div class="step-formula">
                                    Mobility Weight √ó ${championData.champion.mobility}/10 = ${(championData.champion.mobility * 0.8).toFixed(1)} points
                                </div>
                            </div>
                            
                            <div class="calculation-step">
                                <div class="step-label">Step 3: Difficulty Adjustment</div>
                                <div class="step-formula">
                                    Difficulty Match = ${championData.matches.difficulty.toFixed(0)}%
                                </div>
                                <div class="step-formula">
                                    Adjustment Factor = ${(championData.matches.difficulty / 100 * 10).toFixed(1)} points
                                </div>
                            </div>
                            
                            <div class="calculation-step">
                                <div class="step-label">Final Calculation</div>
                                <div class="step-formula">
                                    Final Score = (Base + Attributes + Difficulty) √∑ Max Points √ó 100
                                </div>
                                <div class="step-result">Result: ${championData.scores.randomForest.toFixed(1)}%</div>
                            </div>
                        </div>
                        
                        <div class="attributes-comparison">
                            <div class="attribute-item">
                                <div class="attribute-label">Damage Output</div>
                                <div class="attribute-value">${championData.champion.damage}/10</div>
                            </div>
                            <div class="attribute-item">
                                <div class="attribute-label">Toughness/Tank</div>
                                <div class="attribute-value">${championData.champion.toughness}/10</div>
                            </div>
                            <div class="attribute-item">
                                <div class="attribute-label">Mobility</div>
                                <div class="attribute-value">${championData.champion.mobility}/10</div>
                            </div>
                            <div class="attribute-item">
                                <div class="attribute-label">Crowd Control</div>
                                <div class="attribute-value">${championData.champion.control}/10</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Decision Tree Section
            content += `
                <div class="ml-algorithm-section">
                    <h3><span style="font-size: 1.4rem;">üéØ</span> Decision Tree Algorithm</h3>
                    <div class="algorithm-score-card">
                        <div class="algorithm-header">
                            <div class="algorithm-name">
                                <span>Rule-Based Classification</span>
                            </div>
                            <div class="algorithm-score">${championData.scores.decisionTree.toFixed(1)}%</div>
                        </div>
                        
                        <p style="color: #666; margin-bottom: 15px;">
                            Decision Tree follows a series of if-then rules to classify champions based on your preferences.
                        </p>
                        
                        <div class="calculation-steps">
                            <div class="calculation-step">
                                <div class="step-label">Decision Path 1: Role Classification</div>
                                <div class="step-formula">
                                    IF role = ${championData.champion.role} ‚Üí Score += 40 points
                                </div>
                                <div class="step-result">Applied: ${championData.matches.role >= 100 ? '+40' : '+0'} points</div>
                            </div>
                            
                            <div class="calculation-step">
                                <div class="step-label">Decision Path 2: Difficulty Level</div>
                                <div class="step-formula">
                                    IF difficulty_match ‚â• 70% ‚Üí Score += 25 points
                                </div>
                                <div class="step-result">Applied: ${championData.matches.difficulty >= 70 ? '+25' : '+' + (championData.matches.difficulty * 0.25).toFixed(0)} points</div>
                            </div>
                            
                            <div class="calculation-step">
                                <div class="step-label">Decision Path 3: Playstyle Match</div>
                                <div class="step-formula">
                                    Damage Rating (${championData.champion.damage}/10) √ó 2.0 = ${(championData.champion.damage * 2).toFixed(1)} points
                                </div>
                                <div class="step-formula">
                                    Toughness Rating (${championData.champion.toughness}/10) √ó 1.5 = ${(championData.champion.toughness * 1.5).toFixed(1)} points
                                </div>
                            </div>
                            
                            <div class="calculation-step">
                                <div class="step-label">Decision Path 4: Utility Factor</div>
                                <div class="step-formula">
                                    Control (${championData.champion.control}/10) + Utility (${championData.champion.utility}/10) = ${(championData.champion.control + championData.champion.utility).toFixed(1)} points
                                </div>
                            </div>
                            
                            <div class="calculation-step">
                                <div class="step-label">Final Classification</div>
                                <div class="step-formula">
                                    Total Points √∑ 100 √ó 100 = Final Score
                                </div>
                                <div class="step-result">Result: ${championData.scores.decisionTree.toFixed(1)}%</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // KNN Section
            content += `
                <div class="ml-algorithm-section">
                    <h3><span style="font-size: 1.4rem;">‚ö°</span> K-Nearest Neighbors (KNN)</h3>
                    <div class="algorithm-score-card">
                        <div class="algorithm-header">
                            <div class="algorithm-name">
                                <span>Similarity-Based Matching</span>
                            </div>
                            <div class="algorithm-score">${championData.scores.knn.toFixed(1)}%</div>
                        </div>
                        
                        <p style="color: #666; margin-bottom: 15px;">
                            KNN finds the most similar champions based on Euclidean distance calculation across all attributes.
                        </p>
                        
                        <div class="calculation-steps">
                            <div class="calculation-step">
                                <div class="step-label">Step 1: Calculate Distance Vector</div>
                                <div class="step-formula">
                                    Distance = ‚àö[(Œîdamage)¬≤ + (Œîtoughness)¬≤ + (Œîmobility)¬≤ + (Œîcontrol)¬≤ + (Œîutility)¬≤]
                                </div>
                            </div>
                            
                            <div class="calculation-step">
                                <div class="step-label">Step 2: Normalize Distances</div>
                                <div class="step-formula">
                                    Normalized Distance = Distance √∑ Max Distance
                                </div>
                            </div>
                            
                            <div class="calculation-step">
                                <div class="step-label">Step 3: Similarity Score</div>
                                <div class="step-formula">
                                    Similarity = (1 - Normalized Distance) √ó 100
                                </div>
                            </div>
                            
                            <div class="calculation-step">
                                <div class="step-label">Step 4: Role Bonus</div>
                                <div class="step-formula">
                                    IF same_role ‚Üí Similarity √ó 1.15 (15% bonus)
                                </div>
                                <div class="step-result">Applied: ${championData.matches.role >= 100 ? 'Yes (+15%)' : 'No'}</div>
                            </div>
                            
                            <div class="calculation-step">
                                <div class="step-label">Step 5: Difficulty Penalty</div>
                                <div class="step-formula">
                                    Penalty = |User Difficulty - Champion Difficulty| √ó 2%
                                </div>
                                <div class="step-result">Penalty: -${(100 - championData.matches.difficulty) / 10}%</div>
                            </div>
                            
                            <div class="calculation-step">
                                <div class="step-label">Final KNN Score</div>
                                <div class="step-formula">
                                    Final = (Similarity + Role Bonus - Difficulty Penalty)
                                </div>
                                <div class="step-result">Result: ${championData.scores.knn.toFixed(1)}%</div>
                            </div>
                        </div>
                        
                        <div class="attributes-comparison">
                            <div class="attribute-item">
                                <div class="attribute-label">Utility Factor</div>
                                <div class="attribute-value">${championData.champion.utility}/10</div>
                            </div>
                            <div class="attribute-item">
                                <div class="attribute-label">Difficulty</div>
                                <div class="attribute-value">${championData.champion.difficulty}/10</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Unified Score Explanation
            content += `
                <div class="ml-algorithm-section" style="background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);">
                    <h3 style="color: #1976d2;"><span style="font-size: 1.4rem;">üéì</span> How We Calculate Your Final Score</h3>
                    <div class="algorithm-score-card">
                        <p style="color: #666; margin-bottom: 15px;">
                            Your final compatibility score is the <strong>average of all three ML algorithms</strong>. This ensemble approach provides more accurate and reliable recommendations.
                        </p>
                        
                        <div class="calculation-steps">
                            <div class="calculation-step">
                                <div class="step-label">Random Forest Contribution</div>
                                <div class="step-formula">
                                    ${championData.scores.randomForest.toFixed(1)}% √∑ 3 = ${(championData.scores.randomForest / 3).toFixed(1)}%
                                </div>
                            </div>
                            
                            <div class="calculation-step">
                                <div class="step-label">Decision Tree Contribution</div>
                                <div class="step-formula">
                                    ${championData.scores.decisionTree.toFixed(1)}% √∑ 3 = ${(championData.scores.decisionTree / 3).toFixed(1)}%
                                </div>
                            </div>
                            
                            <div class="calculation-step">
                                <div class="step-label">KNN Contribution</div>
                                <div class="step-formula">
                                    ${championData.scores.knn.toFixed(1)}% √∑ 3 = ${(championData.scores.knn / 3).toFixed(1)}%
                                </div>
                            </div>
                            
                            <div class="calculation-step">
                                <div class="step-label">Final Unified Score</div>
                                <div class="step-formula">
                                    (${championData.scores.randomForest.toFixed(1)} + ${championData.scores.decisionTree.toFixed(1)} + ${championData.scores.knn.toFixed(1)}) √∑ 3
                                </div>
                                <div class="step-result">Result: ${championData.scores.average.toFixed(1)}%</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            modalBody.innerHTML = content;
            modal.classList.add('active');
        }

        // Function to close champion modal
        function closeChampionModal() {
            const modal = document.getElementById('champion-modal');
            modal.classList.remove('active');
        }

        // Update window click handler to close both modals
        window.onclick = function(event) {
            const metricModal = document.getElementById('metric-modal');
            const championModal = document.getElementById('champion-modal');
            if (event.target === metricModal) {
                closeMetricModal();
            }
            if (event.target === championModal) {
                closeChampionModal();
            }
        }

        // Close modal on ESC key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeMetricModal();
                closeChampionModal();
            }
        });

        function saveRecommendation() {
            // Get the current user data from localStorage
            const userData = JSON.parse(localStorage.getItem('championRecommenderUsers') || '[]');
            
            if (userData.length > 0) {
                // Display all user data in a table format on the web page
                displayAllResults(userData);
                
                console.log('‚úÖ Recommendation saved and results displayed on web page');
                alert('Results displayed on web page!');
            } else {
                alert('No user data available to display.');
            }
        }

        // Function to display all user results in a table format
        function displayAllResults(userData) {
            // Get the detailed analysis container
            const detailedAnalysis = document.getElementById('detailed-analysis');
            
            // Clear the existing content
            const analysisContent = document.getElementById('analysis-content');
            analysisContent.innerHTML = '';
            
            // Update the header
            const header = detailedAnalysis.querySelector('h2');
            header.innerHTML = '<i class="analysis-icon"></i> All Champion Recommendations';
            
            // Create the table
            const table = document.createElement('table');
            table.style.width = '100%';
            table.style.borderCollapse = 'collapse';
            table.style.marginTop = '20px';
            table.style.color = 'white';
            
            // Create table header
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            const headers = [
                'ID', 'Name', 'Email', 'Age', 'Gender', 'Experience',
                'Recommended Champion', 'Registration Date'
            ];
            
            headers.forEach(headerText => {
                const th = document.createElement('th');
                th.textContent = headerText;
                th.style.border = '1px solid #444';
                th.style.padding = '10px';
                th.style.backgroundColor = '#3E1E68';
                th.style.textAlign = 'left';
                headerRow.appendChild(th);
            });
            
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            // Create table body
            const tbody = document.createElement('tbody');
            
            userData.forEach((user, index) => {
                const row = document.createElement('tr');
                
                // Alternate row colors
                if (index % 2 === 0) {
                    row.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                } else {
                    row.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';
                }
                
                const cells = [
                    index + 1,
                    user.fullName || '',
                    user.email || '',
                    user.age || '',
                    user.gender || '',
                    user.experience || '',
                    user.recommendedChampion || '',
                    new Date(user.registrationDate).toLocaleDateString() || ''
                ];
                
                cells.forEach(cellText => {
                    const td = document.createElement('td');
                    td.textContent = cellText;
                    td.style.border = '1px solid #444';
                    td.style.padding = '8px';
                    row.appendChild(td);
                });
                
                tbody.appendChild(row);
            });
            
            table.appendChild(tbody);
            
            // Add table to analysis content
            analysisContent.appendChild(table);
            
            // Add buttons container
            const buttonsContainer = document.createElement('div');
            buttonsContainer.style.marginTop = '20px';
            buttonsContainer.style.display = 'flex';
            buttonsContainer.style.gap = '10px';
            
            // Add download CSV button
            const downloadButton = document.createElement('button');
            downloadButton.textContent = 'Download CSV';
            downloadButton.className = 'btn btn-primary';
            downloadButton.onclick = function() {
                downloadTableAsCSV(userData);
            };
            
            // Add close button
            const closeButton = document.createElement('button');
            closeButton.textContent = 'Close Results';
            closeButton.className = 'btn btn-primary';
            closeButton.onclick = function() {
                // Reset to show detailed analysis
                header.innerHTML = '<i class="analysis-icon"></i> Detailed ML Analysis';
                analysisContent.innerHTML = '';
                detailedAnalysis.classList.remove('active');
            };
            
            buttonsContainer.appendChild(downloadButton);
            buttonsContainer.appendChild(closeButton);
            analysisContent.appendChild(buttonsContainer);
            
            // Debug logs
            console.log('Buttons container added to DOM');
            console.log('Download button:', downloadButton);
            console.log('Close button:', closeButton);
        }

        // Function to download the table data as CSV
        function downloadTableAsCSV(userData) {
            // Create CSV content with headers
            const headers = ['ID', 'Name', 'Email', 'Age', 'Gender', 'Experience', 'Recommended Champion', 'Registration Date'];
            
            let csvContent = headers.join(',') + '\n';
            
            userData.forEach((user, index) => {
                const row = [
                    index + 1,
                    user.fullName || '',
                    user.email || '',
                    user.age || '',
                    user.gender || '',
                    user.experience || '',
                    user.recommendedChampion || '',
                    new Date(user.registrationDate).toLocaleDateString() || ''
                ].map(field => `"${field}"`);
                
                csvContent += row.join(',') + '\n';
            });
            
            // Download CSV
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'champion_recommendations.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            console.log('‚úÖ Table downloaded as CSV file');
        }

        // Function to download as CSV (fallback method)
function downloadAsCSV(data) {
    // Create CSV content with headers
    const headers = [
        'ID', 'Full Name', 'Email', 'Phone', 'Age', 'Gender', 
        'LoL Experience', 'Registration Date', 'Session ID',
        'Recommended Champion', 'Winning Algorithm', 'Confidence Score',
        'Random Forest Champion', 'Random Forest Confidence',
        'Decision Tree Champion', 'Decision Tree Confidence',
        'KNN Champion', 'KNN Confidence', 'Consensus Level',
        'User Answers', 'Completion Date',
        'Pressure Response', 'Aesthetic Preference', 'Team Contribution',
        'Character Identity', 'Problem Solving Approach'
    ];
    
    // Create a single row for the current recommendation
    const row = [
        data.id,
        data.fullName,
        data.email,
        data.phone,
        data.age,
        data.gender,
        data.experience,
        data.registrationDate,
        data.sessionId,
        data.recommendedChampion,
        data.winningAlgorithm,
        data.confidenceScore,
        data.randomForestChampion,
        data.randomForestConfidence,
        data.decisionTreeChampion,
        data.decisionTreeConfidence,
        data.knnChampion,
        data.knnConfidence,
        data.consensusLevel,
        data.userAnswers,
        data.completionDate,
        data.pressureResponse,
        data.aestheticPreference,
        data.teamContribution,
        data.characterIdentity,
        data.problemSolving
    ].map(field => '"' + field + '"');
    
    // Create CSV content
    const csvContent = headers.join(',') + '\n' + row.join(',') + '\n';
    
    // Download CSV
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', 'champion_recommendation_' + (data.sessionId || 'latest') + '.csv');
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    
    console.log('‚úÖ Recommendation downloaded as CSV file');
    alert('Recommendation saved as CSV file!');
}

// Function to manually download user data (for admin use)
function downloadUserData() {
    const userData = JSON.parse(localStorage.getItem('championRecommenderUsers') || '[]');
    if (userData.length > 0) {
        // Trigger download
        const csvContent = "Full Name,Email,Phone,Age,Gender,LoL Experience,Registration Date,Session ID,Recommended Champion,Winning Algorithm,Confidence Score,Random Forest Champion,Random Forest Confidence,Decision Tree Champion,Decision Tree Confidence,KNN Champion,KNN Confidence,Consensus Level,User Answers,Completion Date,Pressure Response,Aesthetic Preference,Team Contribution,Character Identity,Problem Solving Approach\n";
        let content = csvContent;
        
        userData.forEach(user => {
            const row = [
                user.fullName,
                user.email,
                user.phone,
                user.age,
                user.gender,
                user.experience,
                new Date(user.registrationDate).toLocaleString(),
                user.sessionId,
                user.recommendedChampion || '',
                user.winningAlgorithm || '',
                user.confidence || '',
                user.randomForestChampion || '',
                user.randomForestConfidence || '',
                user.decisionTreeChampion || '',
                user.decisionTreeConfidence || '',
                user.knnChampion || '',
                user.knnConfidence || '',
                user.consensusLevel || '',
                user.userAnswers || '',
                user.completionDate || '',
                user.pressureResponse || '',
                user.aestheticPreference || '',
                user.teamContribution || '',
                user.characterIdentity || '',
                user.problemSolving || ''
            ].map(field => `"${field}"`).join(',');
            
            content += row + "\n";
        });
        
        const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'champion_recommender_users.csv';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    } else {
        alert('No user data available to download.');
    }
}
        
// Manual CSV export function
function exportToCSV() {
    const userData = JSON.parse(localStorage.getItem('championRecommenderUsers') || '[]');
    if (userData.length === 0) {
        alert('No user data to export');
        return;
    }
            
    // Create CSV content
    const headers = [
        'ID', 'Full Name', 'Email', 'Phone', 'Age', 'Gender', 
        'LoL Experience', 'Registration Date', 'Session ID',
        'Recommended Champion', 'Winning Algorithm', 'Confidence Score',
        'Random Forest Champion', 'Random Forest Confidence',
        'Decision Tree Champion', 'Decision Tree Confidence',
        'KNN Champion', 'KNN Confidence', 'Consensus Level',
        'User Answers', 'Completion Date',
        'Pressure Response', 'Aesthetic Preference', 'Team Contribution',
        'Character Identity', 'Problem Solving Approach'
    ];
            
    let csvContent = headers.join(',') + '\n';
            
    userData.forEach((user, index) => {
        const row = [
            index + 1,
            user.fullName || '',
            user.email || '',
            user.phone || '',
            user.age || '',
            user.gender || '',
            user.experience || '',
            user.registrationDate || '',
            user.sessionId || '',
            user.recommendedChampion || '',
            user.winningAlgorithm || '',
            user.confidence || '',
            user.randomForestChampion || '',
            user.randomForestConfidence || '',
            user.decisionTreeChampion || '',
            user.decisionTreeConfidence || '',
            user.knnChampion || '',
            user.knnConfidence || '',
            user.consensusLevel || '',
            user.userAnswers || '',
            user.completionDate || '',
            user.pressureResponse || '',
            user.aestheticPreference || '',
            user.teamContribution || '',
            user.characterIdentity || '',
            user.problemSolving || ''
        ].map(field => '"' + field + '"');
                
        csvContent += row.join(',') + '\n';
    });
            
    // Download CSV
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', 'champion_recommender_users.csv');
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
            
    console.log(`üìä Exported ${userData.length} users to CSV file`);
    alert(`Successfully exported ${userData.length} users to CSV file!`);
}
        
// Keyboard shortcut for manual export
document.addEventListener('keydown', function(e) {
    if (e.ctrlKey && e.shiftKey && e.key === 'E') {
        e.preventDefault();
        exportToCSV();
    }
});

        /**
         * Display unified ML recommendations with all 5 champions
         * Shows each champion with scores from all 3 algorithms
         */
        function displayUnifiedRecommendations() {
            // Task 7.1: Clear existing results container
            const analysisContent = document.getElementById('analysis-content');
            if (!analysisContent) {
                console.error('Analysis content container not found');
                return;
            }
            analysisContent.innerHTML = '';
            
            // Verify mlResults structure
            if (!mlResults || !mlResults.top5 || !Array.isArray(mlResults.top5)) {
                console.error('Invalid mlResults structure:', mlResults);
                analysisContent.innerHTML = '<p style="color: red;">Error: No recommendations available</p>';
                return;
            }
            
            // Add header
            const header = document.createElement('div');
            header.className = 'analysis-header';
            header.innerHTML = `
                <h2>Your Top 5 Champion Recommendations</h2>
                <p>Each champion has been evaluated by all three ML algorithms</p>
            `;
            analysisContent.appendChild(header);
            
            // Task 7.2: Loop through top 5 champions
            mlResults.top5.forEach((champion, index) => {
                // Task 7.3: Create champion card HTML for each
                const card = document.createElement('div');
                card.className = 'unified-recommendation-card';
                card.setAttribute('data-champion', champion.championName);
                
                // Get champion data
                const championData = allChampions[champion.championName];
                if (!championData) {
                    console.warn(`Champion data not found for: ${champion.championName}`);
                    return;
                }
                
                // Build card HTML
                card.innerHTML = `
                    <div class="champion-header">
                        <img src="https://ddragon.leagueoflegends.com/cdn/13.24.1/img/champion/${champion.championName.replace(/[^a-zA-Z0-9]/g, '')}.png" 
                             alt="${champion.championName}" 
                             class="champion-image-large"
                             onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23667eea%22 width=%22100%22 height=%22100%22/%3E%3Ctext x=%2250%22 y=%2250%22 font-size=%2240%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22white%22%3E${champion.championName.charAt(0)}%3C/text%3E%3C/svg%3E'">
                        <div class="champion-info">
                            <h3 class="champion-name">${champion.championName}</h3>
                            <span class="champion-role">${championData.role}</span>
                            <span class="champion-tier">Rank #${index + 1}</span>
                        </div>
                        <div class="aggregate-score">
                            <div class="score-number">${champion.average.toFixed(1)}%</div>
                            <div class="score-label">Overall Match</div>
                        </div>
                    </div>
                    
                    <div class="ml-scores-section">
                        <h4>ML Algorithm Scores</h4>
                        
                        <!-- Random Forest Score -->
                        <div class="score-row">
                            <div class="score-label-col">
                                <span class="algorithm-icon">üå≥</span>
                                <span class="algorithm-name">Random Forest</span>
                            </div>
                            <div class="score-bar-col">
                                <div class="score-bar-container">
                                    <div class="score-bar rf-bar" data-width="${champion.randomForest}" style="width: 0%"></div>
                                </div>
                            </div>
                            <div class="score-value-col">${champion.randomForest.toFixed(1)}%</div>
                            <button class="details-btn" onclick="showCalculationDetails('randomForest', '${champion.championName}')">
                                Details
                            </button>
                        </div>
                        
                        <!-- Decision Tree Score -->
                        <div class="score-row">
                            <div class="score-label-col">
                                <span class="algorithm-icon">üéØ</span>
                                <span class="algorithm-name">Decision Tree</span>
                            </div>
                            <div class="score-bar-col">
                                <div class="score-bar-container">
                                    <div class="score-bar dt-bar" data-width="${champion.decisionTree}" style="width: 0%"></div>
                                </div>
                            </div>
                            <div class="score-value-col">${champion.decisionTree.toFixed(1)}%</div>
                            <button class="details-btn" onclick="showCalculationDetails('decisionTree', '${champion.championName}')">
                                Details
                            </button>
                        </div>
                        
                        <!-- KNN Score -->
                        <div class="score-row">
                            <div class="score-label-col">
                                <span class="algorithm-icon">‚ö°</span>
                                <span class="algorithm-name">K-Nearest Neighbors</span>
                            </div>
                            <div class="score-bar-col">
                                <div class="score-bar-container">
                                    <div class="score-bar knn-bar" data-width="${champion.knn}" style="width: 0%"></div>
                                </div>
                            </div>
                            <div class="score-value-col">${champion.knn.toFixed(1)}%</div>
                            <button class="details-btn" onclick="showCalculationDetails('knn', '${champion.championName}')">
                                Details
                            </button>
                        </div>
                    </div>
                    
                    <!-- Expandable Details Section (initially hidden) -->
                    <div class="calculation-details" id="details-${champion.championName.replace(/[^a-zA-Z0-9]/g, '')}">
                        <!-- Details will be populated dynamically -->
                    </div>
                `;
                
                // Task 7.4: Append cards to container
                analysisContent.appendChild(card);
            });
            
            // Task 7.5: Animate score bars
            setTimeout(() => {
                document.querySelectorAll('.score-bar').forEach(bar => {
                    const targetWidth = bar.getAttribute('data-width');
                    bar.style.width = targetWidth + '%';
                });
            }, 100);
            
            // Add restart button at the bottom
            const restartContainer = document.createElement('div');
            restartContainer.style.textAlign = 'center';
            restartContainer.style.marginTop = '30px';
            restartContainer.innerHTML = `
                <button class="btn btn-primary btn-large" onclick="restartQuestionnaire()">
                    Start New Recommendation
                </button>
            `;
            analysisContent.appendChild(restartContainer);
            
            console.log('‚úÖ Unified recommendations displayed successfully');
        }
        
        /**
         * Show detailed calculation breakdown for a specific algorithm and champion
         * @param {string} algorithm - Algorithm name ('randomForest', 'decisionTree', or 'knn')
         * @param {string} championName - Name of the champion
         */
        function showCalculationDetails(algorithm, championName) {
            // Task 8.1: Accept algorithm and championName parameters
            if (!mlResults || !mlResults.top5) {
                console.error('No ML results available');
                return;
            }
            
            // Task 8.2: Retrieve champion details
            const champion = mlResults.top5.find(c => c.championName === championName);
            if (!champion || !champion.details || !champion.details[algorithm]) {
                console.error(`Details not found for ${algorithm} - ${championName}`);
                return;
            }
            
            // TASK 13.2: Use details caching to load on demand
            const details = getCachedDetails(algorithm, championName, champion.details[algorithm]);
            const detailsContainer = document.getElementById(`details-${championName.replace(/[^a-zA-Z0-9]/g, '')}`);
            
            if (!detailsContainer) {
                console.error(`Details container not found for ${championName}`);
                return;
            }
            
            // Toggle visibility
            if (detailsContainer.classList.contains('show')) {
                detailsContainer.classList.remove('show');
                detailsContainer.style.display = 'none';
                return;
            }
            
            // Task 8.3: Build details HTML
            const algorithmNames = {
                'randomForest': 'Random Forest',
                'decisionTree': 'Decision Tree',
                'knn': 'K-Nearest Neighbors'
            };
            
            let html = `
                <div class="calculation-details-content">
                    <button class="details-close-btn" onclick="showCalculationDetails('${algorithm}', '${championName}')">
                        Close
                    </button>
                    <h4>${algorithmNames[algorithm]} Calculation for ${championName}</h4>
                    
                    <div class="score-summary">
                        <div class="detail-item">
                            <span class="label">Raw Score:</span>
                            <span class="value">${details.rawScore ? details.rawScore.toFixed(2) : 'N/A'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="label">Normalized Score:</span>
                            <span class="value">${champion[algorithm].toFixed(1)}%</span>
                        </div>
                    </div>
            `;
            
            // Contributing Factors Table
            if (details.contributingFactors && details.contributingFactors.length > 0) {
                html += `
                    <h5>Contributing Factors</h5>
                    <table class="factors-table">
                        <thead>
                            <tr>
                                <th>Factor</th>
                                <th>Weight</th>
                                <th>Contribution</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                details.contributingFactors.forEach(factor => {
                    html += `
                        <tr>
                            <td>${factor.factor}</td>
                            <td>${factor.weight}</td>
                            <td>${typeof factor.contribution === 'number' ? factor.contribution.toFixed(2) : factor.contribution}</td>
                        </tr>
                    `;
                });
                
                html += `
                        </tbody>
                    </table>
                `;
            }
            
            // Matched Criteria
            if (details.matchedCriteria && details.matchedCriteria.length > 0) {
                html += `
                    <h5>Matched Criteria</h5>
                    <ul class="criteria-list">
                `;
                
                details.matchedCriteria.forEach(criterion => {
                    html += `<li class="matched">${criterion}</li>`;
                });
                
                html += `</ul>`;
            }
            
            // Penalties Applied
            if (details.penalties && details.penalties.length > 0) {
                html += `
                    <h5>Penalties Applied</h5>
                    <ul class="criteria-list">
                `;
                
                details.penalties.forEach(penalty => {
                    html += `<li class="penalty">${penalty}</li>`;
                });
                
                html += `</ul>`;
            }
            
            html += `</div>`;
            
            // Task 8.4: Display details
            detailsContainer.innerHTML = html;
            detailsContainer.style.display = 'block';
            detailsContainer.classList.add('show');
            
            // Scroll to details
            detailsContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            
            console.log(`‚úÖ Displayed calculation details for ${algorithmNames[algorithm]} - ${championName}`);
        }

console.log(`Multi-ML Champion Recommender loaded with ${Object.keys(allChampions).length} champions and 3 ML algorithms!`);

// Admin panel (hidden) - Press Ctrl+Shift+A to access
document.addEventListener('keydown', function(e) {
    if (e.ctrlKey && e.shiftKey && e.key === 'A') {
        showEnhancedAdminPanel();
    }
});

function showAdminPanel() {
    const userData = JSON.parse(localStorage.getItem('championRecommenderUsers') || '[]');
    const userCount = userData.length;
            
    const message = `Admin Panel

Total registered users: ${userCount}

Options:
- OK: Export CSV file
- Cancel: Close panel

Note: Data is stored locally. Press Ctrl+Shift+E anytime to export CSV.`;
            
    if (confirm(message)) {
        exportToCSV();
    }
}

// Enhanced admin panel with local data
async function showEnhancedAdminPanel() {
    const userData = JSON.parse(localStorage.getItem('championRecommenderUsers') || '[]');
    const userCount = userData.length;
            
    const message = `Enhanced Admin Panel

Local storage users: ${userCount}

Options:
- OK: Export CSV file
- Cancel: Close panel

Note: Press Ctrl+Shift+E to export CSV.`;
            
    if (confirm(message)) {
        exportToCSV();
    }
}

// Auto-save user data periodically
setInterval(() => {
    const userData = JSON.parse(localStorage.getItem('championRecommenderUsers') || '[]');
    if (userData.length > 0) {
        console.log(userData.length + ' users registered so far');
    }
}, 60000); // Check every minute

// TASK 14.1 & 14.2: Expose performance profiling functions globally for testing
window.performanceTools = {
    // Display current performance metrics
    showMetrics: function() {
        displayPerformanceMetrics();
    },
    
    // Get performance statistics as object
    getStats: function() {
        return getPerformanceStats();
    },
    
    // Display bottleneck analysis
    showBottlenecks: function() {
        displayBottleneckAnalysis();
    },
    
    // Get bottleneck analysis as object
    getBottlenecks: function() {
        return identifyBottlenecks();
    },
    
    // Reset all performance metrics
    reset: function() {
        resetPerformanceMetrics();
    },
    
    // Clear all caches
    clearCaches: function() {
        clearAllCaches();
    },
    
    // Get cache statistics
    getCacheStats: function() {
        return {
            scoreCache: {
                size: scoreCache.size,
                maxSize: 50
            },
            detailsCache: {
                size: detailsCache.size,
                maxSize: 100
            }
        };
    },
    
    // Run a performance test
    runTest: function() {
        console.log('=== Running Performance Test ===');
        
        // Clear caches to get fresh measurements
        clearAllCaches();
        resetPerformanceMetrics();
        
        // Create test features
        const testFeatures = {
            role: 'Mage',
            position: 'Mid',
            difficulty: 5,
            damage: 8,
            toughness: 3,
            playstyle: 'aggressive',
            range: 'ranged',
            pressure_response: 'Get aggressive and take risks',
            aesthetic_preference: 'Mysterious',
            team_contribution: 'Stay independent and focus on my role',
            character_identity: 'No preference',
            problem_solving: 'Jump in and adapt on the fly'
        };
        
        console.log('Test Features:', testFeatures);
        console.log('\nRunning algorithms...\n');
        
        // Run each algorithm
        const rfResult = profilePredictAll('random-forest', algorithms['random-forest'], testFeatures);
        const dtResult = profilePredictAll('decision-tree', algorithms['decision-tree'], testFeatures);
        const knnResult = profilePredictAll('knn', algorithms['knn'], testFeatures);
        
        console.log('\n=== Test Results ===');
        console.log(`Random Forest: ${rfResult.executionTime.toFixed(3)}ms`);
        console.log(`Decision Tree: ${dtResult.executionTime.toFixed(3)}ms`);
        console.log(`KNN: ${knnResult.executionTime.toFixed(3)}ms`);
        
        // Show bottleneck analysis
        console.log('\n');
        displayBottleneckAnalysis();
        
        return {
            randomForest: rfResult.executionTime,
            decisionTree: dtResult.executionTime,
            knn: knnResult.executionTime
        };
    }
};

// Log availability of performance tools
console.log('‚úÖ Performance profiling tools available via window.performanceTools');
console.log('   - performanceTools.showMetrics() - Display performance metrics');
console.log('   - performanceTools.showBottlenecks() - Display bottleneck analysis');
console.log('   - performanceTools.runTest() - Run a performance test');
console.log('   - performanceTools.reset() - Reset metrics');
console.log('   - performanceTools.clearCaches() - Clear all caches');
console.log('   - performanceTools.getCacheStats() - Get cache statistics');
    </script>
    <script>
        // Vercel Analytics
        (function() {
            if (typeof window !== 'undefined') {
                fetch('https://vitals.vercel-insights.com/v1/vitals', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        dsn: 'https://vitals.vercel-insights.com/v1/vitals',
                        id: window.location.hostname,
                        page: window.location.pathname + window.location.search,
                        href: window.location.href
                    })
                }).catch(function() {});
            }
        })();
    </script>
    
    <!-- Google Analytics removed as per user request -->
    
</body>
</html>
