<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task 5 Implementation Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-section {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .success {
            color: #28a745;
            font-weight: bold;
        }
        .error {
            color: #dc3545;
            font-weight: bold;
        }
        .info {
            color: #007bff;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }
        th, td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        .champion-row {
            background: #f8f9fa;
        }
        .score-cell {
            font-weight: bold;
            color: #667eea;
        }
    </style>
</head>
<body>
    <h1>Task 5: Modify generateRecommendations() Function - Test Results</h1>
    
    <div class="test-section">
        <h2>Test Overview</h2>
        <p>This test verifies that the <code>runAllAlgorithms()</code> function correctly:</p>
        <ol>
            <li>Extracts user features from questionnaire answers</li>
            <li>Calls <code>predictAll()</code> on all 3 ML algorithms</li>
            <li>Aggregates scores using <code>ScoreAggregator.aggregateScores()</code></li>
            <li>Selects top 5 champions using <code>ScoreAggregator.selectTop5()</code></li>
            <li>Updates the global <code>mlResults</code> object with the correct structure</li>
        </ol>
    </div>

    <div id="results"></div>

    <script>
        // Minimal champion database for testing
        const allChampions = {
            'Ahri': { role: 'Mage', positions: ['Mid'], difficulty: 5, damage: 8, toughness: 3, control: 5, mobility: 7, utility: 6 },
            'Garen': { role: 'Fighter', positions: ['Top'], difficulty: 2, damage: 6, toughness: 7, control: 5, mobility: 5, utility: 5 },
            'Lux': { role: 'Mage', positions: ['Mid', 'Support'], difficulty: 5, damage: 7, toughness: 2, control: 8, mobility: 4, utility: 7 },
            'Jinx': { role: 'Marksman', positions: ['ADC'], difficulty: 6, damage: 9, toughness: 2, control: 7, mobility: 6, utility: 6 },
            'Thresh': { role: 'Support', positions: ['Support'], difficulty: 7, damage: 6, toughness: 6, control: 9, mobility: 5, utility: 9 },
            'Yasuo': { role: 'Fighter', positions: ['Mid', 'Top'], difficulty: 10, damage: 8, toughness: 4, control: 6, mobility: 8, utility: 4 },
            'Zed': { role: 'Assassin', positions: ['Mid'], difficulty: 8, damage: 9, toughness: 2, control: 5, mobility: 8, utility: 4 },
            'Leona': { role: 'Tank', positions: ['Support'], difficulty: 4, damage: 4, toughness: 9, control: 9, mobility: 4, utility: 8 }
        };

        // Mock ML Algorithm classes with predictAll() methods
        class SimpleRandomForest {
            predictAll(features) {
                const scores = {};
                for (const [name, champion] of Object.entries(allChampions)) {
                    let score = 50;
                    if (features.role === champion.role) score += 30;
                    if (Math.abs(features.difficulty - champion.difficulty) <= 2) score += 20;
                    scores[name] = {
                        score: Math.min(100, score),
                        rawScore: score,
                        details: { contributingFactors: [], matchedCriteria: [], penalties: [] }
                    };
                }
                return scores;
            }
        }

        class SimpleDecisionTree {
            predictAll(features) {
                const scores = {};
                for (const [name, champion] of Object.entries(allChampions)) {
                    let score = 40;
                    if (features.role === champion.role) score += 35;
                    if (Math.abs(features.damage - champion.damage) <= 2) score += 25;
                    scores[name] = {
                        score: Math.min(100, score),
                        rawScore: score,
                        details: { contributingFactors: [], matchedCriteria: [], penalties: [] }
                    };
                }
                return scores;
            }
        }

        class SimpleKNN {
            predictAll(features) {
                const scores = {};
                for (const [name, champion] of Object.entries(allChampions)) {
                    let distance = 0;
                    if (features.role !== champion.role) distance += 8;
                    distance += Math.abs(features.difficulty - champion.difficulty) * 0.5;
                    const score = Math.max(0, 100 - (distance * 3.33));
                    scores[name] = {
                        score: score,
                        rawScore: distance,
                        details: { contributingFactors: [], matchedCriteria: [], penalties: [] }
                    };
                }
                return scores;
            }
        }

        // ScoreAggregator class
        class ScoreAggregator {
            static aggregateScores(rfScores, dtScores, knnScores) {
                const aggregated = {};
                for (const championName of Object.keys(allChampions)) {
                    const rf = rfScores[championName]?.score || 0;
                    const dt = dtScores[championName]?.score || 0;
                    const knn = knnScores[championName]?.score || 0;
                    const average = (rf * 0.4) + (dt * 0.3) + (knn * 0.3);
                    const weighted = this.calculateWeightedScore(rf, dt, knn);
                    
                    aggregated[championName] = {
                        championName: championName,
                        randomForest: rf,
                        decisionTree: dt,
                        knn: knn,
                        average: average,
                        weighted: weighted,
                        details: {
                            randomForest: rfScores[championName]?.details || null,
                            decisionTree: dtScores[championName]?.details || null,
                            knn: knnScores[championName]?.details || null
                        }
                    };
                }
                return aggregated;
            }
            
            static calculateWeightedScore(rf, dt, knn) {
                return (rf * 0.4) + (dt * 0.3) + (knn * 0.3);
            }
            
            static selectTop5(aggregatedScores, diversityFilter = true) {
                let champions = Object.values(aggregatedScores);
                champions.sort((a, b) => b.average - a.average);
                return champions.slice(0, 5);
            }
        }

        // Initialize algorithms
        const algorithms = {
            'random-forest': new SimpleRandomForest(),
            'decision-tree': new SimpleDecisionTree(),
            'knn': new SimpleKNN()
        };

        // Test user features
        const testFeatures = {
            role: 'Mage',
            position: 'Mid',
            difficulty: 5,
            damage: 7,
            toughness: 3,
            playstyle: 'High Damage Output',
            range: 'ranged',
            pressure_response: 'Stay calm and strategic',
            aesthetic_preference: 'Mysterious',
            team_contribution: 'Balance between both',
            character_identity: 'No preference',
            problem_solving: 'Analyze carefully before acting'
        };

        // Global mlResults object
        let mlResults = {};

        // Run the test
        function runTest() {
            let html = '<div class="test-section">';
            html += '<h2>Test Execution</h2>';
            
            try {
                // TASK 5.2: Run all 3 algorithms with predictAll()
                html += '<h3>Step 1: Call predictAll() on all algorithms</h3>';
                const rfScores = algorithms['random-forest'].predictAll(testFeatures);
                const dtScores = algorithms['decision-tree'].predictAll(testFeatures);
                const knnScores = algorithms['knn'].predictAll(testFeatures);
                
                html += '<p class="success">✓ Successfully called predictAll() on all 3 algorithms</p>';
                html += `<p class="info">Random Forest returned scores for ${Object.keys(rfScores).length} champions</p>`;
                html += `<p class="info">Decision Tree returned scores for ${Object.keys(dtScores).length} champions</p>`;
                html += `<p class="info">KNN returned scores for ${Object.keys(knnScores).length} champions</p>`;
                
                // TASK 5.3: Aggregate scores
                html += '<h3>Step 2: Aggregate scores</h3>';
                const aggregated = ScoreAggregator.aggregateScores(rfScores, dtScores, knnScores);
                
                html += '<p class="success">✓ Successfully aggregated scores</p>';
                html += `<p class="info">Aggregated object contains ${Object.keys(aggregated).length} champions</p>`;
                
                // TASK 5.4: Select top 5 champions
                html += '<h3>Step 3: Select top 5 champions</h3>';
                const top5 = ScoreAggregator.selectTop5(aggregated);
                
                html += '<p class="success">✓ Successfully selected top 5 champions</p>';
                html += `<p class="info">Top 5 array contains ${top5.length} champions</p>`;
                
                // TASK 5.5: Update mlResults global object
                html += '<h3>Step 4: Update mlResults global object</h3>';
                mlResults = {
                    scores: {
                        randomForest: rfScores,
                        decisionTree: dtScores,
                        knn: knnScores
                    },
                    aggregated: aggregated,
                    top5: top5
                };
                
                html += '<p class="success">✓ Successfully updated mlResults object</p>';
                html += '<p class="info">mlResults structure:</p>';
                html += '<ul>';
                html += '<li>scores.randomForest: ' + Object.keys(mlResults.scores.randomForest).length + ' champions</li>';
                html += '<li>scores.decisionTree: ' + Object.keys(mlResults.scores.decisionTree).length + ' champions</li>';
                html += '<li>scores.knn: ' + Object.keys(mlResults.scores.knn).length + ' champions</li>';
                html += '<li>aggregated: ' + Object.keys(mlResults.aggregated).length + ' champions</li>';
                html += '<li>top5: ' + mlResults.top5.length + ' champions</li>';
                html += '</ul>';
                
                // Display top 5 results
                html += '<h3>Step 5: Display Top 5 Results</h3>';
                html += '<table>';
                html += '<thead><tr><th>Rank</th><th>Champion</th><th>RF Score</th><th>DT Score</th><th>KNN Score</th><th>Average</th><th>Weighted</th></tr></thead>';
                html += '<tbody>';
                
                top5.forEach((champion, index) => {
                    html += '<tr class="champion-row">';
                    html += `<td>${index + 1}</td>`;
                    html += `<td><strong>${champion.championName}</strong></td>`;
                    html += `<td class="score-cell">${champion.randomForest.toFixed(1)}%</td>`;
                    html += `<td class="score-cell">${champion.decisionTree.toFixed(1)}%</td>`;
                    html += `<td class="score-cell">${champion.knn.toFixed(1)}%</td>`;
                    html += `<td class="score-cell">${champion.average.toFixed(1)}%</td>`;
                    html += `<td class="score-cell">${champion.weighted.toFixed(1)}%</td>`;
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                
                // Verification
                html += '<h3>Verification</h3>';
                let allPassed = true;
                
                // Check 1: All algorithms returned scores
                if (Object.keys(rfScores).length > 0 && Object.keys(dtScores).length > 0 && Object.keys(knnScores).length > 0) {
                    html += '<p class="success">✓ All algorithms returned scores</p>';
                } else {
                    html += '<p class="error">✗ Not all algorithms returned scores</p>';
                    allPassed = false;
                }
                
                // Check 2: Aggregated scores exist
                if (Object.keys(aggregated).length > 0) {
                    html += '<p class="success">✓ Aggregated scores created successfully</p>';
                } else {
                    html += '<p class="error">✗ Aggregated scores not created</p>';
                    allPassed = false;
                }
                
                // Check 3: Top 5 has exactly 5 champions
                if (top5.length === 5) {
                    html += '<p class="success">✓ Top 5 contains exactly 5 champions</p>';
                } else {
                    html += `<p class="error">✗ Top 5 contains ${top5.length} champions (expected 5)</p>`;
                    allPassed = false;
                }
                
                // Check 4: mlResults has correct structure
                if (mlResults.scores && mlResults.aggregated && mlResults.top5) {
                    html += '<p class="success">✓ mlResults has correct structure</p>';
                } else {
                    html += '<p class="error">✗ mlResults structure is incorrect</p>';
                    allPassed = false;
                }
                
                // Check 5: All top 5 champions are unique
                const uniqueNames = new Set(top5.map(c => c.championName));
                if (uniqueNames.size === 5) {
                    html += '<p class="success">✓ All top 5 champions are unique</p>';
                } else {
                    html += '<p class="error">✗ Top 5 contains duplicate champions</p>';
                    allPassed = false;
                }
                
                // Final result
                html += '<h3>Final Result</h3>';
                if (allPassed) {
                    html += '<p class="success" style="font-size: 1.2em;">✓ ALL TESTS PASSED! Task 5 implementation is correct.</p>';
                } else {
                    html += '<p class="error" style="font-size: 1.2em;">✗ Some tests failed. Please review the implementation.</p>';
                }
                
            } catch (error) {
                html += '<p class="error">✗ Error during test execution: ' + error.message + '</p>';
                html += '<pre>' + error.stack + '</pre>';
            }
            
            html += '</div>';
            document.getElementById('results').innerHTML = html;
        }

        // Run test on page load
        window.onload = runTest;
    </script>
</body>
</html>
