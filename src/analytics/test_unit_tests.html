<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit Tests - Unified ML Recommendations</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        h1 {
            color: #667eea;
            text-align: center;
            margin-bottom: 30px;
        }
        .test-section {
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }
        .test-section h2 {
            color: #495057;
            margin-top: 0;
        }
        .result {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        .success {
            border-left: 4px solid #28a745;
            background: #d4edda;
        }
        .error {
            border-left: 4px solid #dc3545;
            background: #f8d7da;
        }
        .warning {
            border-left: 4px solid #ffc107;
            background: #fff3cd;
        }
        .info {
            border-left: 4px solid #17a2b8;
            background: #d1ecf1;
        }
        .test-summary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
        }
        .test-summary h2 {
            margin: 0 0 10px 0;
            color: white;
        }
        .summary-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
        }
        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }
        pre {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.9rem;
        }
        .champion-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
        }
        .champion-name {
            font-size: 1.2rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
        }
        .score-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        .score-label {
            font-weight: 600;
            color: #495057;
        }
        .score-value {
            color: #28a745;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß™ Unit Tests - Unified ML Recommendations</h1>
        
        <div id="test-summary" class="test-summary">
            <h2>Test Summary</h2>
            <div class="summary-stats">
                <div class="stat-item">
                    <div class="stat-value" id="total-tests">0</div>
                    <div class="stat-label">Total Tests</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="passed-tests" style="color: #d4edda;">0</div>
                    <div class="stat-label">Passed</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="failed-tests" style="color: #f8d7da;">0</div>
                    <div class="stat-label">Failed</div>
                </div>
            </div>
        </div>
        
        <div id="test-results"></div>
    </div>

    <script>
        // Mock champion data for testing
        const allChampions = {
            "Ahri": { role: "Mage", difficulty: 5, damage: 8, toughness: 3, utility: 6, control: 7, mobility: 8 },
            "Lux": { role: "Mage", difficulty: 4, damage: 7, toughness: 2, utility: 8, control: 9, mobility: 3 },
            "Zed": { role: "Assassin", difficulty: 8, damage: 9, toughness: 2, utility: 3, control: 4, mobility: 9 },
            "Garen": { role: "Fighter", difficulty: 3, damage: 6, toughness: 8, utility: 2, control: 3, mobility: 4 },
            "Thresh": { role: "Support", difficulty: 7, damage: 3, toughness: 5, utility: 10, control: 8, mobility: 4 },
            "Jinx": { role: "Marksman", difficulty: 6, damage: 9, toughness: 2, utility: 4, control: 5, mobility: 3 },
            "Yasuo": { role: "Fighter", difficulty: 9, damage: 8, toughness: 4, utility: 3, control: 6, mobility: 9 },
            "Leona": { role: "Tank", difficulty: 3, damage: 4, toughness: 9, utility: 7, control: 8, mobility: 3 },
            "Annie": { role: "Mage", difficulty: 2, damage: 8, toughness: 3, utility: 5, control: 8, mobility: 2 },
            "Ashe": { role: "Marksman", difficulty: 4, damage: 7, toughness: 2, utility: 7, control: 6, mobility: 3 }
        };

        // ML Algorithm Classes with normalizeScore methods
        class SimpleRandomForest {
            normalizeScore(rawScore) {
                const maxScore = 170;
                const minScore = 0;
                const normalized = ((rawScore - minScore) / (maxScore - minScore)) * 100;
                return Math.max(0, Math.min(100, normalized));
            }
        }

        class SimpleDecisionTree {
            normalizeScore(rawScore) {
                const maxScore = 250;
                const minScore = -50;
                const normalized = ((rawScore - minScore) / (maxScore - minScore)) * 100;
                return Math.max(0, Math.min(100, normalized));
            }
        }

        class SimpleKNN {
            normalizeScore(rawDistance) {
                const maxDistance = 30;
                const normalized = Math.max(0, 100 - ((rawDistance / maxDistance) * 100));
                return Math.max(0, Math.min(100, normalized));
            }
        }

        // ScoreAggregator class
        class ScoreAggregator {
            static aggregateScores(rfScores, dtScores, knnScores) {
                const aggregated = {};
                
                for (const championName of Object.keys(allChampions)) {
                    const rf = rfScores[championName]?.score || 0;
                    const dt = dtScores[championName]?.score || 0;
                    const knn = knnScores[championName]?.score || 0;
                    
                    const average = (rf * 0.4) + (dt * 0.3) + (knn * 0.3);
                    const weighted = this.calculateWeightedScore(rf, dt, knn);
                    
                    aggregated[championName] = {
                        championName: championName,
                        randomForest: rf,
                        decisionTree: dt,
                        knn: knn,
                        average: average,
                        weighted: weighted,
                        details: {
                            randomForest: rfScores[championName]?.details || null,
                            decisionTree: dtScores[championName]?.details || null,
                            knn: knnScores[championName]?.details || null
                        }
                    };
                }
                
                return aggregated;
            }
            
            static calculateWeightedScore(rf, dt, knn) {
                const weighted = (rf * 0.4) + (dt * 0.3) + (knn * 0.3);
                return Math.max(0, Math.min(100, weighted));
            }
            
            static selectTop5(aggregatedScores, diversityFilter = true) {
                let champions = Object.values(aggregatedScores);
                champions.sort((a, b) => b.average - a.average);
                
                if (diversityFilter) {
                    champions = this.applyDiversityFilter(champions);
                }
                
                const top5 = champions.slice(0, 5);
                
                const uniqueChampions = [];
                const seenNames = new Set();
                
                for (const champion of top5) {
                    if (!seenNames.has(champion.championName)) {
                        uniqueChampions.push(champion);
                        seenNames.add(champion.championName);
                    }
                }
                
                if (uniqueChampions.length < 5) {
                    for (const champion of champions) {
                        if (!seenNames.has(champion.championName)) {
                            uniqueChampions.push(champion);
                            seenNames.add(champion.championName);
                            
                            if (uniqueChampions.length >= 5) break;
                        }
                    }
                }
                
                return uniqueChampions;
            }
            
            static applyDiversityFilter(champions) {
                const selected = [];
                const roleCount = {};
                
                for (const champion of champions) {
                    const championData = allChampions[champion.championName];
                    const role = championData?.role || 'Unknown';
                    
                    if ((roleCount[role] || 0) < 2) {
                        selected.push(champion);
                        roleCount[role] = (roleCount[role] || 0) + 1;
                    }
                    
                    if (selected.length >= 5) break;
                }
                
                if (selected.length < 5) {
                    for (const champion of champions) {
                        if (!selected.find(c => c.championName === champion.championName)) {
                            selected.push(champion);
                            
                            if (selected.length >= 5) break;
                        }
                    }
                }
                
                return selected;
            }
        }

        // Test tracking
        let totalTests = 0;
        let passedTests = 0;
        let failedTests = 0;

        function assert(condition, message) {
            totalTests++;
            if (condition) {
                passedTests++;
                return `<div class="result success">‚úì ${message}</div>`;
            } else {
                failedTests++;
                return `<div class="result error">‚úó ${message}</div>`;
            }
        }

        function assertApprox(actual, expected, tolerance, message) {
            totalTests++;
            const diff = Math.abs(actual - expected);
            if (diff <= tolerance) {
                passedTests++;
                return `<div class="result success">‚úì ${message} (${actual.toFixed(2)} ‚âà ${expected.toFixed(2)})</div>`;
            } else {
                failedTests++;
                return `<div class="result error">‚úó ${message} (Expected: ${expected.toFixed(2)}, Got: ${actual.toFixed(2)}, Diff: ${diff.toFixed(2)})</div>`;
            }
        }

        // Test Suite
        function runTests() {
            const resultsDiv = document.getElementById('test-results');
            let html = '';

            // ===== TASK 10.1: Test Score Normalization =====
            html += '<div class="test-section">';
            html += '<h2>Task 10.1: Test Score Normalization</h2>';
            html += '<p>Testing normalization methods for all three ML algorithms with various raw scores.</p>';
            
            const rf = new SimpleRandomForest();
            const dt = new SimpleDecisionTree();
            const knn = new SimpleKNN();
            
            // Test Random Forest normalization
            html += '<h3>Random Forest Normalization (max: 170, min: 0)</h3>';
            html += assert(rf.normalizeScore(0) === 0, 'RF: Score 0 normalizes to 0');
            html += assert(rf.normalizeScore(170) === 100, 'RF: Score 170 normalizes to 100');
            html += assertApprox(rf.normalizeScore(85), 50, 0.1, 'RF: Score 85 normalizes to ~50');
            html += assertApprox(rf.normalizeScore(127.5), 75, 0.1, 'RF: Score 127.5 normalizes to ~75');
            html += assertApprox(rf.normalizeScore(42.5), 25, 0.1, 'RF: Score 42.5 normalizes to ~25');
            html += assert(rf.normalizeScore(-10) === 0, 'RF: Negative score clamps to 0');
            html += assert(rf.normalizeScore(200) === 100, 'RF: Score above max clamps to 100');
            html += assert(rf.normalizeScore(100) >= 0 && rf.normalizeScore(100) <= 100, 'RF: Mid-range score is within 0-100');
            
            // Test Decision Tree normalization
            html += '<h3>Decision Tree Normalization (max: 250, min: -50)</h3>';
            html += assert(dt.normalizeScore(-50) === 0, 'DT: Score -50 normalizes to 0');
            html += assert(dt.normalizeScore(250) === 100, 'DT: Score 250 normalizes to 100');
            html += assertApprox(dt.normalizeScore(100), 50, 0.1, 'DT: Score 100 normalizes to ~50');
            html += assertApprox(dt.normalizeScore(175), 75, 0.1, 'DT: Score 175 normalizes to ~75');
            html += assertApprox(dt.normalizeScore(25), 25, 0.1, 'DT: Score 25 normalizes to ~25');
            html += assert(dt.normalizeScore(0) >= 0 && dt.normalizeScore(0) <= 100, 'DT: Score 0 is within 0-100');
            html += assert(dt.normalizeScore(-100) === 0, 'DT: Score below min clamps to 0');
            html += assert(dt.normalizeScore(300) === 100, 'DT: Score above max clamps to 100');
            
            // Test KNN normalization (distance-based, inverse)
            html += '<h3>KNN Normalization (max distance: 30, inverse)</h3>';
            html += assert(knn.normalizeScore(0) === 100, 'KNN: Distance 0 normalizes to 100');
            html += assert(knn.normalizeScore(30) === 0, 'KNN: Distance 30 normalizes to 0');
            html += assertApprox(knn.normalizeScore(15), 50, 0.1, 'KNN: Distance 15 normalizes to ~50');
            html += assertApprox(knn.normalizeScore(7.5), 75, 0.1, 'KNN: Distance 7.5 normalizes to ~75');
            html += assertApprox(knn.normalizeScore(22.5), 25, 0.1, 'KNN: Distance 22.5 normalizes to ~25');
            html += assert(knn.normalizeScore(-5) === 100, 'KNN: Negative distance clamps to 100');
            html += assert(knn.normalizeScore(50) === 0, 'KNN: Distance above max clamps to 0');
            html += assert(knn.normalizeScore(10) >= 0 && knn.normalizeScore(10) <= 100, 'KNN: Mid-range distance is within 0-100');
            
            html += '</div>';

            // ===== TASK 10.2: Test Aggregation Logic =====
            html += '<div class="test-section">';
            html += '<h2>Task 10.2: Test Aggregation Logic</h2>';
            html += '<p>Testing score aggregation with sample scores from all three algorithms.</p>';
            
            const sampleRfScores = {
                "Ahri": { score: 85.3, details: {} },
                "Lux": { score: 78.2, details: {} },
                "Zed": { score: 72.1, details: {} }
            };
            
            const sampleDtScores = {
                "Ahri": { score: 78.2, details: {} },
                "Lux": { score: 84.1, details: {} },
                "Zed": { score: 69.5, details: {} }
            };
            
            const sampleKnnScores = {
                "Ahri": { score: 82.1, details: {} },
                "Lux": { score: 77.8, details: {} },
                "Zed": { score: 75.3, details: {} }
            };
            
            const aggregated = ScoreAggregator.aggregateScores(sampleRfScores, sampleDtScores, sampleKnnScores);
            
            // Test aggregation structure
            html += '<h3>Aggregation Structure</h3>';
            html += assert(Object.keys(aggregated).length === Object.keys(allChampions).length, 
                `All ${Object.keys(allChampions).length} champions aggregated`);
            html += assert(aggregated["Ahri"] !== undefined, 'Ahri exists in aggregated results');
            html += assert(aggregated["Ahri"].championName === "Ahri", 'Champion name stored correctly');
            html += assert(aggregated["Ahri"].randomForest === 85.3, 'RF score stored correctly');
            html += assert(aggregated["Ahri"].decisionTree === 78.2, 'DT score stored correctly');
            html += assert(aggregated["Ahri"].knn === 82.1, 'KNN score stored correctly');
            
            // Test average calculation
            html += '<h3>Average Score Calculation</h3>';
            const expectedAvgAhri = (85.3 + 78.2 + 82.1) / 3;
            html += assertApprox(aggregated["Ahri"].average, expectedAvgAhri, 0.01, 
                'Ahri average calculated correctly');
            
            const expectedAvgLux = (78.2 + 84.1 + 77.8) / 3;
            html += assertApprox(aggregated["Lux"].average, expectedAvgLux, 0.01, 
                'Lux average calculated correctly');
            
            // Test weighted calculation
            html += '<h3>Weighted Score Calculation (RF: 40%, DT: 30%, KNN: 30%)</h3>';
            const expectedWeightedAhri = (85.3 * 0.4) + (78.2 * 0.3) + (82.1 * 0.3);
            html += assertApprox(aggregated["Ahri"].weighted, expectedWeightedAhri, 0.01, 
                'Ahri weighted score calculated correctly');
            
            const expectedWeightedLux = (78.2 * 0.4) + (84.1 * 0.3) + (77.8 * 0.3);
            html += assertApprox(aggregated["Lux"].weighted, expectedWeightedLux, 0.01, 
                'Lux weighted score calculated correctly');
            
            // Test missing scores default to 0
            html += '<h3>Missing Score Handling</h3>';
            html += assert(aggregated["Garen"].randomForest === 0, 'Missing RF score defaults to 0');
            html += assert(aggregated["Garen"].decisionTree === 0, 'Missing DT score defaults to 0');
            html += assert(aggregated["Garen"].knn === 0, 'Missing KNN score defaults to 0');
            html += assert(aggregated["Garen"].average === 0, 'Average of missing scores is 0');
            
            // Test weighted score bounds
            html += '<h3>Weighted Score Bounds</h3>';
            const testWeighted1 = ScoreAggregator.calculateWeightedScore(100, 100, 100);
            html += assert(testWeighted1 === 100, 'Weighted score of (100,100,100) equals 100');
            
            const testWeighted2 = ScoreAggregator.calculateWeightedScore(0, 0, 0);
            html += assert(testWeighted2 === 0, 'Weighted score of (0,0,0) equals 0');
            
            const testWeighted3 = ScoreAggregator.calculateWeightedScore(50, 50, 50);
            html += assert(testWeighted3 === 50, 'Weighted score of (50,50,50) equals 50');
            
            const testWeighted4 = ScoreAggregator.calculateWeightedScore(80, 60, 70);
            const expectedWeighted4 = (80 * 0.4) + (60 * 0.3) + (70 * 0.3);
            html += assertApprox(testWeighted4, expectedWeighted4, 0.01, 
                'Weighted score of (80,60,70) calculated correctly');
            
            html += '</div>';

            // ===== TASK 10.3: Test Top 5 Selection =====
            html += '<div class="test-section">';
            html += '<h2>Task 10.3: Test Top 5 Selection</h2>';
            html += '<p>Testing selection of top 5 champions with correct ordering and uniqueness.</p>';
            
            // Create comprehensive test data
            const fullRfScores = {
                "Ahri": { score: 85.3, details: {} },
                "Lux": { score: 78.2, details: {} },
                "Zed": { score: 72.1, details: {} },
                "Garen": { score: 65.5, details: {} },
                "Thresh": { score: 70.0, details: {} },
                "Jinx": { score: 80.5, details: {} },
                "Yasuo": { score: 75.0, details: {} },
                "Leona": { score: 68.0, details: {} },
                "Annie": { score: 77.0, details: {} },
                "Ashe": { score: 73.5, details: {} }
            };
            
            const fullDtScores = {
                "Ahri": { score: 78.2, details: {} },
                "Lux": { score: 84.1, details: {} },
                "Zed": { score: 69.5, details: {} },
                "Garen": { score: 70.0, details: {} },
                "Thresh": { score: 75.5, details: {} },
                "Jinx": { score: 77.0, details: {} },
                "Yasuo": { score: 72.5, details: {} },
                "Leona": { score: 73.0, details: {} },
                "Annie": { score: 80.0, details: {} },
                "Ashe": { score: 74.0, details: {} }
            };
            
            const fullKnnScores = {
                "Ahri": { score: 82.1, details: {} },
                "Lux": { score: 77.8, details: {} },
                "Zed": { score: 75.3, details: {} },
                "Garen": { score: 68.0, details: {} },
                "Thresh": { score: 72.0, details: {} },
                "Jinx": { score: 79.0, details: {} },
                "Yasuo": { score: 74.0, details: {} },
                "Leona": { score: 70.5, details: {} },
                "Annie": { score: 76.5, details: {} },
                "Ashe": { score: 72.0, details: {} }
            };
            
            const fullAggregated = ScoreAggregator.aggregateScores(fullRfScores, fullDtScores, fullKnnScores);
            const top5NoDiversity = ScoreAggregator.selectTop5(fullAggregated, false);
            
            // Test exactly 5 champions returned
            html += '<h3>Count and Uniqueness</h3>';
            html += assert(top5NoDiversity.length === 5, 'Exactly 5 champions returned');
            
            // Test uniqueness
            const championNames = top5NoDiversity.map(c => c.championName);
            const uniqueNames = new Set(championNames);
            html += assert(championNames.length === uniqueNames.size, 'All 5 champions are unique');
            
            // Test correct ordering (descending by average)
            html += '<h3>Ordering</h3>';
            let isCorrectlyOrdered = true;
            for (let i = 0; i < top5NoDiversity.length - 1; i++) {
                if (top5NoDiversity[i].average < top5NoDiversity[i + 1].average) {
                    isCorrectlyOrdered = false;
                    break;
                }
            }
            html += assert(isCorrectlyOrdered, 'Champions sorted by average score (descending)');
            
            // Verify top champion has highest average
            const allChampionsList = Object.values(fullAggregated);
            const maxAverage = Math.max(...allChampionsList.map(c => c.average));
            html += assertApprox(top5NoDiversity[0].average, maxAverage, 0.01, 
                'First champion has highest average score');
            
            // Display top 5
            html += '<h3>Top 5 Champions (No Diversity Filter)</h3>';
            top5NoDiversity.forEach((champion, index) => {
                html += `
                    <div class="champion-card">
                        <div class="champion-name">${index + 1}. ${champion.championName}</div>
                        <div class="score-row">
                            <span class="score-label">Average:</span>
                            <span class="score-value">${champion.average.toFixed(2)}%</span>
                        </div>
                        <div class="score-row">
                            <span class="score-label">RF:</span>
                            <span class="score-value">${champion.randomForest.toFixed(1)}%</span>
                        </div>
                        <div class="score-row">
                            <span class="score-label">DT:</span>
                            <span class="score-value">${champion.decisionTree.toFixed(1)}%</span>
                        </div>
                        <div class="score-row">
                            <span class="score-label">KNN:</span>
                            <span class="score-value">${champion.knn.toFixed(1)}%</span>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';

            // ===== TASK 10.4: Test Diversity Filter =====
            html += '<div class="test-section">';
            html += '<h2>Task 10.4: Test Diversity Filter</h2>';
            html += '<p>Testing role distribution with max 2 champions per role.</p>';
            
            const top5WithDiversity = ScoreAggregator.selectTop5(fullAggregated, true);
            
            // Test exactly 5 champions returned
            html += '<h3>Count and Uniqueness</h3>';
            html += assert(top5WithDiversity.length === 5, 'Exactly 5 champions returned with diversity filter');
            
            // Test uniqueness
            const diverseNames = top5WithDiversity.map(c => c.championName);
            const uniqueDiverseNames = new Set(diverseNames);
            html += assert(diverseNames.length === uniqueDiverseNames.size, 'All 5 champions are unique with diversity filter');
            
            // Count roles
            html += '<h3>Role Distribution</h3>';
            const roleCounts = {};
            top5WithDiversity.forEach(champion => {
                const role = allChampions[champion.championName].role;
                roleCounts[role] = (roleCounts[role] || 0) + 1;
            });
            
            // Verify no more than 2 per role
            const maxRoleCount = Math.max(...Object.values(roleCounts));
            html += assert(maxRoleCount <= 2, `No more than 2 champions per role (max found: ${maxRoleCount})`);
            
            // Display role distribution
            html += '<div class="result info">';
            html += '<strong>Role Distribution:</strong><br>';
            for (const [role, count] of Object.entries(roleCounts)) {
                html += `${role}: ${count} champion${count > 1 ? 's' : ''}<br>`;
            }
            html += '</div>';
            
            // Verify each role has at most 2
            let allRolesValid = true;
            for (const [role, count] of Object.entries(roleCounts)) {
                if (count > 2) {
                    allRolesValid = false;
                    html += `<div class="result error">‚úó Role "${role}" has ${count} champions (max should be 2)</div>`;
                }
            }
            if (allRolesValid) {
                html += '<div class="result success">‚úì All roles have at most 2 champions</div>';
            }
            
            // Display top 5 with diversity
            html += '<h3>Top 5 Champions (With Diversity Filter)</h3>';
            top5WithDiversity.forEach((champion, index) => {
                const role = allChampions[champion.championName].role;
                html += `
                    <div class="champion-card">
                        <div class="champion-name">${index + 1}. ${champion.championName} (${role})</div>
                        <div class="score-row">
                            <span class="score-label">Average:</span>
                            <span class="score-value">${champion.average.toFixed(2)}%</span>
                        </div>
                        <div class="score-row">
                            <span class="score-label">RF:</span>
                            <span class="score-value">${champion.randomForest.toFixed(1)}%</span>
                        </div>
                        <div class="score-row">
                            <span class="score-label">DT:</span>
                            <span class="score-value">${champion.decisionTree.toFixed(1)}%</span>
                        </div>
                        <div class="score-row">
                            <span class="score-label">KNN:</span>
                            <span class="score-value">${champion.knn.toFixed(1)}%</span>
                        </div>
                    </div>
                `;
            });
            
            // Test edge case: all same role
            html += '<h3>Edge Case: All Champions Same Role</h3>';
            const sameRoleScores = {
                "Ahri": { score: 90, details: {} },
                "Lux": { score: 85, details: {} },
                "Annie": { score: 80, details: {} }
            };
            const sameRoleAggregated = ScoreAggregator.aggregateScores(sameRoleScores, sameRoleScores, sameRoleScores);
            const sameRoleTop5 = ScoreAggregator.selectTop5(sameRoleAggregated, true);
            
            const sameRoleRoleCounts = {};
            sameRoleTop5.forEach(champion => {
                const role = allChampions[champion.championName].role;
                sameRoleRoleCounts[role] = (sameRoleRoleCounts[role] || 0) + 1;
            });
            
            const mageCount = sameRoleRoleCounts["Mage"] || 0;
            html += assert(mageCount <= 2, `Mage role limited to 2 even when all top scorers are Mages (found: ${mageCount})`);
            html += assert(sameRoleTop5.length === 5, 'Still returns 5 champions even with role limitation');
            
            html += '</div>';

            // Update summary
            resultsDiv.innerHTML = html;
            document.getElementById('total-tests').textContent = totalTests;
            document.getElementById('passed-tests').textContent = passedTests;
            document.getElementById('failed-tests').textContent = failedTests;
            
            // Add final summary message
            const summaryDiv = document.getElementById('test-summary');
            if (failedTests === 0) {
                summaryDiv.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                summaryDiv.innerHTML += '<p style="margin-top: 15px; font-size: 1.2rem;">üéâ All tests passed!</p>';
            } else {
                summaryDiv.style.background = 'linear-gradient(135deg, #dc3545 0%, #c82333 100%)';
                summaryDiv.innerHTML += `<p style="margin-top: 15px; font-size: 1.2rem;">‚ö†Ô∏è ${failedTests} test(s) failed</p>`;
            }
        }

        // Run tests on page load
        window.addEventListener('DOMContentLoaded', runTests);
    </script>
</body>
</html>
