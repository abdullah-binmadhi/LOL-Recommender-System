<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EvaluationMetrics Test</title>
</head>
<body>
    <h1>EvaluationMetrics Class Test</h1>
    <div id="results"></div>

    <script>
        // Copy the EvaluationMetrics class from src/index.html
        class EvaluationMetrics {
            static precisionAtK(recommendedChampions, relevantChampions, k) {
                if (!recommendedChampions || recommendedChampions.length === 0 || k === 0) {
                    return 0.0;
                }
                const topK = recommendedChampions.slice(0, k);
                let relevantCount = 0;
                for (const champion of topK) {
                    if (relevantChampions.has(champion)) {
                        relevantCount++;
                    }
                }
                return relevantCount / topK.length;
            }
            
            static meanReciprocalRank(recommendedChampions, relevantChampions) {
                if (!recommendedChampions || recommendedChampions.length === 0) {
                    return 0.0;
                }
                for (let i = 0; i < recommendedChampions.length; i++) {
                    if (relevantChampions.has(recommendedChampions[i])) {
                        return 1.0 / (i + 1);
                    }
                }
                return 0.0;
            }
            
            static calculateUserRelevance(userAnswers, allChampions) {
                const relevantChampions = new Set();
                const userRole = userAnswers.role || 'No Preference';
                const userDifficulty = this.mapDifficultyToNumeric(userAnswers.difficulty);
                const { damage: userDamage, toughness: userToughness } = this.mapPlaystyleToAttributes(userAnswers.playstyle);
                
                for (const [championName, champion] of Object.entries(allChampions)) {
                    let isRelevant = true;
                    if (userRole !== 'No Preference' && userRole !== champion.role) {
                        isRelevant = false;
                    }
                    if (userDifficulty !== null && Math.abs(userDifficulty - champion.difficulty) > 2) {
                        isRelevant = false;
                    }
                    if (userDamage !== null && Math.abs(userDamage - champion.damage) > 2) {
                        isRelevant = false;
                    }
                    if (userToughness !== null && Math.abs(userToughness - champion.toughness) > 2) {
                        isRelevant = false;
                    }
                    if (isRelevant) {
                        relevantChampions.add(championName);
                    }
                }
                return relevantChampions;
            }
            
            static getRecommendedChampions(mlResults) {
                const championScores = {};
                for (const [algorithmName, result] of Object.entries(mlResults)) {
                    if (result && result.champion) {
                        const championName = result.champion;
                        const confidence = result.confidence || 0;
                        if (!championScores[championName] || championScores[championName] < confidence) {
                            championScores[championName] = confidence;
                        }
                    }
                }
                const sortedChampions = Object.entries(championScores)
                    .sort((a, b) => b[1] - a[1])
                    .map(entry => entry[0]);
                return sortedChampions;
            }
            
            static mapDifficultyToNumeric(difficulty) {
                const mapping = {
                    'Easy (1-3)': 2,
                    'Medium (4-6)': 5,
                    'Hard (7-8)': 7.5,
                    'Very Hard (9-10)': 9.5
                };
                return mapping[difficulty] !== undefined ? mapping[difficulty] : null;
            }
            
            static mapPlaystyleToAttributes(playstyle) {
                const mapping = {
                    'High Damage Output': { damage: 8, toughness: 3 },
                    'Tanky and Durable': { damage: 4, toughness: 8 },
                    'Support Team': { damage: 3, toughness: 5 },
                    'Balanced/Hybrid': { damage: 5, toughness: 5 }
                };
                return mapping[playstyle] || { damage: null, toughness: null };
            }
        }

        // Run tests
        const results = [];
        
        // Test 1: precisionAtK
        const recommended1 = ["Ahri", "Lux", "Zed"];
        const relevant1 = new Set(["Ahri", "Lux"]);
        const p3 = EvaluationMetrics.precisionAtK(recommended1, relevant1, 3);
        results.push(`Test 1 - Precision@3: ${p3.toFixed(3)} (Expected: 0.667) - ${Math.abs(p3 - 0.667) < 0.01 ? 'PASS' : 'FAIL'}`);
        
        // Test 2: precisionAtK with no relevant
        const recommended2 = ["Garen"];
        const relevant2 = new Set(["Ahri"]);
        const p1 = EvaluationMetrics.precisionAtK(recommended2, relevant2, 1);
        results.push(`Test 2 - Precision@1 (no match): ${p1.toFixed(3)} (Expected: 0.000) - ${p1 === 0.0 ? 'PASS' : 'FAIL'}`);
        
        // Test 3: meanReciprocalRank
        const recommended3 = ["Ahri", "Lux"];
        const relevant3 = new Set(["Ahri"]);
        const mrr1 = EvaluationMetrics.meanReciprocalRank(recommended3, relevant3);
        results.push(`Test 3 - MRR (first position): ${mrr1.toFixed(3)} (Expected: 1.000) - ${mrr1 === 1.0 ? 'PASS' : 'FAIL'}`);
        
        // Test 4: meanReciprocalRank
        const recommended4 = ["Zed", "Ahri"];
        const relevant4 = new Set(["Ahri"]);
        const mrr2 = EvaluationMetrics.meanReciprocalRank(recommended4, relevant4);
        results.push(`Test 4 - MRR (second position): ${mrr2.toFixed(3)} (Expected: 0.500) - ${mrr2 === 0.5 ? 'PASS' : 'FAIL'}`);
        
        // Test 5: meanReciprocalRank with no relevant
        const recommended5 = ["Zed", "Lux"];
        const relevant5 = new Set(["Ahri"]);
        const mrr3 = EvaluationMetrics.meanReciprocalRank(recommended5, relevant5);
        results.push(`Test 5 - MRR (no match): ${mrr3.toFixed(3)} (Expected: 0.000) - ${mrr3 === 0.0 ? 'PASS' : 'FAIL'}`);
        
        // Test 6: getRecommendedChampions
        const mlResults = {
            'random-forest': { champion: 'Ahri', confidence: 85 },
            'decision-tree': { champion: 'Lux', confidence: 90 },
            'knn': { champion: 'Ahri', confidence: 80 }
        };
        const recommended6 = EvaluationMetrics.getRecommendedChampions(mlResults);
        results.push(`Test 6 - getRecommendedChampions: [${recommended6.join(', ')}] (Expected: Lux first, then Ahri) - ${recommended6[0] === 'Lux' && recommended6[1] === 'Ahri' ? 'PASS' : 'FAIL'}`);
        
        // Test 7: calculateUserRelevance
        const userAnswers = {
            role: 'Mage',
            difficulty: 'Medium (4-6)',
            playstyle: 'High Damage Output'
        };
        const allChampions = {
            'Ahri': { role: 'Mage', difficulty: 5, damage: 8, toughness: 3 },
            'Lux': { role: 'Mage', difficulty: 4, damage: 9, toughness: 2 },
            'Garen': { role: 'Fighter', difficulty: 3, damage: 6, toughness: 8 },
            'Zed': { role: 'Assassin', difficulty: 8, damage: 9, toughness: 2 }
        };
        const relevant7 = EvaluationMetrics.calculateUserRelevance(userAnswers, allChampions);
        results.push(`Test 7 - calculateUserRelevance: ${relevant7.size} champions (Expected: 2 - Ahri and Lux) - ${relevant7.has('Ahri') && relevant7.has('Lux') && relevant7.size === 2 ? 'PASS' : 'FAIL'}`);
        
        // Test 8: Edge case - empty arrays
        const p_empty = EvaluationMetrics.precisionAtK([], new Set(['Ahri']), 3);
        results.push(`Test 8 - Precision@K (empty array): ${p_empty.toFixed(3)} (Expected: 0.000) - ${p_empty === 0.0 ? 'PASS' : 'FAIL'}`);
        
        // Display results
        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = '<h2>Test Results:</h2><ul>' + 
            results.map(r => `<li>${r}</li>`).join('') + 
            '</ul>';
        
        // Summary
        const passed = results.filter(r => r.includes('PASS')).length;
        const total = results.length;
        resultsDiv.innerHTML += `<h3>Summary: ${passed}/${total} tests passed</h3>`;
        
        console.log('All tests completed!');
    </script>
</body>
</html>
