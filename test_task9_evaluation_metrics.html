<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task 9: EvaluationMetrics Update Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        h1 {
            color: #667eea;
            border-bottom: 3px solid #764ba2;
            padding-bottom: 10px;
        }
        h2 {
            color: #764ba2;
            margin-top: 30px;
        }
        .test-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-family: monospace;
        }
        .pass {
            background: #d4edda;
            color: #155724;
            border-left: 4px solid #28a745;
        }
        .fail {
            background: #f8d7da;
            color: #721c24;
            border-left: 4px solid #dc3545;
        }
        .info {
            background: #d1ecf1;
            color: #0c5460;
            border-left: 4px solid #17a2b8;
        }
        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        .summary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-top: 30px;
            text-align: center;
        }
        .summary h3 {
            margin: 0 0 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß™ Task 9: EvaluationMetrics Update Test</h1>
        <p>Testing the updated EvaluationMetrics class to work with unified ML recommendations (5 champions).</p>

        <div id="test-results"></div>
        <div id="summary"></div>
    </div>

    <script>
        // Sample champion data
        const allChampions = {
            'Ahri': { role: 'Mage', difficulty: 5, damage: 8, toughness: 3, positions: ['Mid'] },
            'Lux': { role: 'Mage', difficulty: 4, damage: 7, toughness: 2, positions: ['Mid', 'Support'] },
            'Zed': { role: 'Assassin', difficulty: 7, damage: 9, toughness: 2, positions: ['Mid'] },
            'Yasuo': { role: 'Fighter', difficulty: 8, damage: 8, toughness: 4, positions: ['Mid', 'Top'] },
            'Annie': { role: 'Mage', difficulty: 3, damage: 8, toughness: 3, positions: ['Mid'] }
        };

        // Copy EvaluationMetrics class from src/index.html
        class EvaluationMetrics {
            static precisionAtK(recommendedChampions, relevantChampions, k) {
                if (!recommendedChampions || recommendedChampions.length === 0 || k === 0) {
                    return 0.0;
                }
                const topK = recommendedChampions.slice(0, k);
                let relevantCount = 0;
                for (const champion of topK) {
                    if (relevantChampions.has(champion)) {
                        relevantCount++;
                    }
                }
                return relevantCount / topK.length;
            }
            
            static meanReciprocalRank(recommendedChampions, relevantChampions) {
                if (!recommendedChampions || recommendedChampions.length === 0) {
                    return 0.0;
                }
                for (let i = 0; i < recommendedChampions.length; i++) {
                    if (relevantChampions.has(recommendedChampions[i])) {
                        return 1.0 / (i + 1);
                    }
                }
                return 0.0;
            }
            
            static calculateUserRelevance(userAnswers, allChampions) {
                const relevantChampions = new Set();
                const userRole = userAnswers.role || 'No Preference';
                const userDifficulty = this.mapDifficultyToNumeric(userAnswers.difficulty);
                const { damage: userDamage, toughness: userToughness } = this.mapPlaystyleToAttributes(userAnswers.playstyle);
                
                for (const [championName, champion] of Object.entries(allChampions)) {
                    let isRelevant = true;
                    
                    if (userRole !== 'No Preference' && userRole !== champion.role) {
                        isRelevant = false;
                    }
                    if (userDifficulty !== null && Math.abs(userDifficulty - champion.difficulty) > 2) {
                        isRelevant = false;
                    }
                    if (userDamage !== null && Math.abs(userDamage - champion.damage) > 2) {
                        isRelevant = false;
                    }
                    if (userToughness !== null && Math.abs(userToughness - champion.toughness) > 2) {
                        isRelevant = false;
                    }
                    
                    if (isRelevant) {
                        relevantChampions.add(championName);
                    }
                }
                
                return relevantChampions;
            }
            
            static getRecommendedChampions(mlResults) {
                // NEW: Check if mlResults has the unified structure with top5 array
                if (mlResults && mlResults.top5 && Array.isArray(mlResults.top5)) {
                    // Extract top 5 champion names from mlResults.top5
                    // Maintain order (highest score first)
                    return mlResults.top5.map(champion => champion.championName);
                }
                
                // Fallback to legacy structure for backward compatibility
                const championScores = {};
                
                for (const [algorithmName, result] of Object.entries(mlResults)) {
                    if (result && result.champion) {
                        const championName = result.champion;
                        const confidence = result.confidence || 0;
                        
                        if (!championScores[championName] || championScores[championName] < confidence) {
                            championScores[championName] = confidence;
                        }
                    }
                }
                
                const sortedChampions = Object.entries(championScores)
                    .sort((a, b) => b[1] - a[1])
                    .map(entry => entry[0]);
                
                return sortedChampions;
            }
            
            static mapDifficultyToNumeric(difficulty) {
                const mapping = {
                    'Easy (1-3)': 2,
                    'Medium (4-6)': 5,
                    'Hard (7-8)': 7.5,
                    'Very Hard (9-10)': 9.5
                };
                return mapping[difficulty] !== undefined ? mapping[difficulty] : null;
            }
            
            static mapPlaystyleToAttributes(playstyle) {
                const mapping = {
                    'High Damage Output': { damage: 8, toughness: 3 },
                    'Tanky and Durable': { damage: 4, toughness: 8 },
                    'Support Team': { damage: 3, toughness: 5 },
                    'Balanced/Hybrid': { damage: 5, toughness: 5 }
                };
                return mapping[playstyle] || { damage: null, toughness: null };
            }
        }

        // Test runner
        const results = [];
        let passCount = 0;
        let failCount = 0;

        function test(name, condition, details = '') {
            const passed = condition;
            results.push({ name, passed, details });
            if (passed) passCount++;
            else failCount++;
        }

        // Run tests
        console.log('Starting Task 9 Tests...');

        // Test 9.1: getRecommendedChampions with unified structure
        console.log('\n=== Test 9.1: getRecommendedChampions() with unified structure ===');
        
        const unifiedMLResults = {
            scores: {
                randomForest: { 'Ahri': 85.3, 'Lux': 78.2, 'Zed': 72.1, 'Yasuo': 68.5, 'Annie': 82.7 },
                decisionTree: { 'Ahri': 78.2, 'Lux': 84.1, 'Zed': 69.5, 'Yasuo': 71.3, 'Annie': 79.8 },
                knn: { 'Ahri': 82.1, 'Lux': 77.8, 'Zed': 75.3, 'Yasuo': 70.2, 'Annie': 80.5 }
            },
            aggregated: {
                'Ahri': { championName: 'Ahri', randomForest: 85.3, decisionTree: 78.2, knn: 82.1, average: 81.9 },
                'Lux': { championName: 'Lux', randomForest: 78.2, decisionTree: 84.1, knn: 77.8, average: 80.0 },
                'Annie': { championName: 'Annie', randomForest: 82.7, decisionTree: 79.8, knn: 80.5, average: 81.0 },
                'Zed': { championName: 'Zed', randomForest: 72.1, decisionTree: 69.5, knn: 75.3, average: 72.3 },
                'Yasuo': { championName: 'Yasuo', randomForest: 68.5, decisionTree: 71.3, knn: 70.2, average: 70.0 }
            },
            top5: [
                { championName: 'Ahri', randomForest: 85.3, decisionTree: 78.2, knn: 82.1, average: 81.9 },
                { championName: 'Annie', randomForest: 82.7, decisionTree: 79.8, knn: 80.5, average: 81.0 },
                { championName: 'Lux', randomForest: 78.2, decisionTree: 84.1, knn: 77.8, average: 80.0 },
                { championName: 'Zed', randomForest: 72.1, decisionTree: 69.5, knn: 75.3, average: 72.3 },
                { championName: 'Yasuo', randomForest: 68.5, decisionTree: 71.3, knn: 70.2, average: 70.0 }
            ]
        };

        const recommendedChampions = EvaluationMetrics.getRecommendedChampions(unifiedMLResults);
        
        test(
            'Returns exactly 5 champions',
            recommendedChampions.length === 5,
            `Got ${recommendedChampions.length} champions`
        );
        
        test(
            'Returns champion names in correct order',
            recommendedChampions[0] === 'Ahri' && 
            recommendedChampions[1] === 'Annie' && 
            recommendedChampions[2] === 'Lux',
            `Order: ${recommendedChampions.join(', ')}`
        );
        
        test(
            'All champions are unique',
            new Set(recommendedChampions).size === recommendedChampions.length,
            `Unique count: ${new Set(recommendedChampions).size}`
        );

        // Test 9.1b: Backward compatibility with legacy structure
        console.log('\n=== Test 9.1b: Backward compatibility with legacy structure ===');
        
        const legacyMLResults = {
            'random-forest': { champion: 'Ahri', confidence: 85 },
            'decision-tree': { champion: 'Lux', confidence: 90 },
            'knn': { champion: 'Zed', confidence: 80 }
        };

        const legacyRecommended = EvaluationMetrics.getRecommendedChampions(legacyMLResults);
        
        test(
            'Legacy structure: Returns champions',
            legacyRecommended.length > 0,
            `Got ${legacyRecommended.length} champions`
        );
        
        test(
            'Legacy structure: Sorted by confidence',
            legacyRecommended[0] === 'Lux',
            `First champion: ${legacyRecommended[0]} (expected Lux with 90 confidence)`
        );

        // Test 9.2: calculateUserRelevance works with 5 recommendations
        console.log('\n=== Test 9.2: calculateUserRelevance() works with 5 recommendations ===');
        
        const userAnswers = {
            role: 'Mage',
            difficulty: 'Medium (4-6)',
            playstyle: 'High Damage Output'
        };

        const relevantChampions = EvaluationMetrics.calculateUserRelevance(userAnswers, allChampions);
        
        test(
            'Calculates relevant champions',
            relevantChampions.size > 0,
            `Found ${relevantChampions.size} relevant champions`
        );
        
        test(
            'Includes Ahri (Mage, difficulty 5)',
            relevantChampions.has('Ahri'),
            'Ahri should be relevant'
        );
        
        test(
            'Includes Lux (Mage, difficulty 4)',
            relevantChampions.has('Lux'),
            'Lux should be relevant'
        );

        // Test 9.3: Full workflow with 5 recommendations
        console.log('\n=== Test 9.3: Full workflow with 5 recommendations ===');
        
        const p1 = EvaluationMetrics.precisionAtK(recommendedChampions, relevantChampions, 1);
        const p3 = EvaluationMetrics.precisionAtK(recommendedChampions, relevantChampions, 3);
        const p5 = EvaluationMetrics.precisionAtK(recommendedChampions, relevantChampions, 5);
        const mrr = EvaluationMetrics.meanReciprocalRank(recommendedChampions, relevantChampions);
        
        test(
            'Precision@1 calculated',
            p1 >= 0 && p1 <= 1,
            `P@1 = ${(p1 * 100).toFixed(1)}%`
        );
        
        test(
            'Precision@3 calculated',
            p3 >= 0 && p3 <= 1,
            `P@3 = ${(p3 * 100).toFixed(1)}%`
        );
        
        test(
            'Precision@5 calculated',
            p5 >= 0 && p5 <= 1,
            `P@5 = ${(p5 * 100).toFixed(1)}%`
        );
        
        test(
            'MRR calculated',
            mrr >= 0 && mrr <= 1,
            `MRR = ${(mrr * 100).toFixed(1)}%`
        );

        // Display results
        const resultsDiv = document.getElementById('test-results');
        let html = '<h2>Test Results</h2>';

        results.forEach(result => {
            const className = result.passed ? 'pass' : 'fail';
            const icon = result.passed ? '‚úÖ' : '‚ùå';
            html += `<div class="test-result ${className}">
                ${icon} ${result.name}
                ${result.details ? `<br><small>${result.details}</small>` : ''}
            </div>`;
        });

        resultsDiv.innerHTML = html;

        // Display summary
        const summaryDiv = document.getElementById('summary');
        const totalTests = passCount + failCount;
        const passRate = ((passCount / totalTests) * 100).toFixed(1);
        
        summaryDiv.innerHTML = `
            <div class="summary">
                <h3>Test Summary</h3>
                <p style="font-size: 2rem; margin: 10px 0;">
                    ${passCount} / ${totalTests} tests passed (${passRate}%)
                </p>
                <p>
                    ‚úÖ Passed: ${passCount} | ‚ùå Failed: ${failCount}
                </p>
            </div>
        `;

        // Display sample data
        resultsDiv.innerHTML += `
            <div class="test-section">
                <h2>Sample Data</h2>
                <div class="info">
                    <strong>Unified ML Results Structure:</strong>
                    <pre>${JSON.stringify(unifiedMLResults, null, 2)}</pre>
                </div>
                <div class="info">
                    <strong>Recommended Champions (from top5):</strong>
                    <pre>${JSON.stringify(recommendedChampions, null, 2)}</pre>
                </div>
                <div class="info">
                    <strong>Relevant Champions:</strong>
                    <pre>${JSON.stringify([...relevantChampions], null, 2)}</pre>
                </div>
                <div class="info">
                    <strong>Evaluation Metrics:</strong>
                    <pre>Precision@1: ${(p1 * 100).toFixed(1)}%
Precision@3: ${(p3 * 100).toFixed(1)}%
Precision@5: ${(p5 * 100).toFixed(1)}%
MRR: ${(mrr * 100).toFixed(1)}%</pre>
                </div>
            </div>
        `;

        console.log(`\n=== Test Summary ===`);
        console.log(`Total: ${totalTests} | Passed: ${passCount} | Failed: ${failCount}`);
        console.log(`Pass Rate: ${passRate}%`);
    </script>
</body>
</html>
